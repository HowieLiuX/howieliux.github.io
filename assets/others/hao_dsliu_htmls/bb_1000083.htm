<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] Understanding IRQL</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] Understanding IRQL</h2>
<p align="right">发布时间：2013-6-12 14:58
<br>分类名称：Driver</p><br>

<P><A rel="nofollow" href="http://prdownloads.sourceforge.net/ext2fsd/irql.zip"  ><STRONG>Download this acticle (zipped pdf format)</STRONG></A>. </P>
<P>System: Windows 2000 professional·free ? build ?2195 ?X86 ?Single CPU<BR><BR><STRONG>Part I: </STRONG><BR>In this part, I'll discuss the fundament of IRQL and the differences/relations between IRQL and CPU rings/thread priority/hardware IRQ.<BR><BR>Definitions:<BR><BR>For a kernel developer, IRQL is not strange. Almost every kernel support routine has a limit of the working IRQL. But what on earth an IRQL stands for ? This article is to disclose it's mysterious veil.<BR><BR>See it's definition from DDK:<BR><BR>Interrupt Request Level (IRQL)<BR><BR><EM>The priority ranking of an interrupt. A processor has an IRQL setting that threads can raise or lower. Interrupts that occur at or below the processor's IRQL setting are masked and will not interfere with the current operation. Interrupts that occur above the processor's IRQL setting take precedence over the current operation.<BR><BR>The particular IRQL at which a piece of kernel-mode code executes determines its hardware priority. Kernel-mode code is always interruptible: an interrupt with a higher IRQL value can occur at any time, thereby causing another piece of kernel-mode code with the system-assigned higher IRQL to be run immediately on that processor. In other words, when a piece of code runs at a given IRQL, the Kernel masks off all interrupt vectors with a lesser or equal IRQL value on the microprocessor.</EM><BR><BR>It says that higer IRQL interrupt can interrupt other task or interrupt with lower IRQL and all the interrupts with IRQL equal to or below current IRQL will be masked and wait until it get opportunity.<BR><BR>Each processor has an independent IRQL, which descripts the current IRQL of the processor, i.e. the IRQL of the current instructions / codes being executed by this processor.<BR><BR>System support a kernel routine (KeGetCurrentIRQL) to get current processor's IRQL. Let's see the assemble codes:<BR><BR>kd&gt; u KeGetCurrentIrql<BR>hal!KeGetCurrentIrql:<BR>80063124 0fb70524f0dfff movzx eax,word ptr [ffdff024]<BR>8006312b c3 ret<BR><BR>This routine is very simple. It tells us that current IRQL stores at krenel address 0xffdff024. And it's a WORD (2 bytes), in fact it's only one byte long, the upper 8 bits are zero.<BR><BR>The value of IRQL can be one of the followings.<BR><BR>Software IRQL:<BR><BR>PASSIVE_LEVEL 0 // Passive release level<BR>LOW_LEVEL 0 // Lowest interrupt level<BR>APC_LEVEL 1 // APC interrupt level<BR>DISPATCH_LEVEL 2 // Dispatcher level<BR><BR>Hardware IRQL:<BR><BR>DIRQL: from 3 to 26 for device ISR<BR><BR>PROFILE_LEVEL 27 (0x1B) // timer used for profiling.<BR>CLOCK1_LEVEL 28 (0x1C) // Interval clock 1 level - Not used on x86<BR>CLOCK2_LEVEL 28 (0x1C) // Interval clock 2 level<BR>SYNCH_LEVEL 28 (0x1C) // synchronization level<BR>IPI_LEVEL 29 (0x1D) // Interprocessor interrupt level<BR>POWER_LEVEL 30 (0x1E) // Power failure level<BR>HIGH_LEVEL 31 (0x1F) // Highest interrupt level<BR><BR>The IRQL values are divided into two groups: Software ( 0,1,2 ) / Hardware IRQL ( &gt;= 3). Hardware IRQL is for device ISRs and system, it is similar to (but distinguished with) the level of hardware IRQ, which implemented by i8259, but IRQL is only an action of Windows OS, not hardware's. It's realized by Windows OS. But hardware IRQ level is achieved by 8259A (programmable interrupt controlor). We will detail the hardware IRQ later.<BR><BR>The bigger of it's value, the higher level the IRQL has.<BR><BR>Let us see an example: </P>
<P><IMG title="[转] Understanding IRQL - Howie - Dspace"   alt=""   src="pic/img1.ph.126.net_664zezAmV9EEDd1zH5dYTg==_6597865813076565805.jpg"   ><BR><BR>Description:<BR><BR>1) Thread A is running at this time.<BR><BR>2) IRQL (0D) interrupt happends, then cpu interrupt the current running thread A and begin to run IRQL (0D).<BR><BR>3) With higher IRQL, IRQL 1A will take over the cpu ?BR&gt;[Here I use this example just to demonstrate the mechanism of IRQL. For a real system, when an hardware IRQ arises, the eflags IF bit will be set to zero, to mask all maskable-interrupts.]<BR><BR>4) When IRQL 1A is running, IRQL 18 arises, but is masked for it's IRQL (18)&lt; Current IRQL (1A).<BR><BR>5) IRQL 1A service finishes, then IRQL 18 will run instead of interrupted IRQL 0D routine.<BR><BR>6) Only after IRQL 18 finishes, IRQL 0D can get the cpu.<BR><BR>7) At last, cpu resume the thread A, when IRQL 0D finishes.<BR><BR><BR>IRQL can be prone to be confused with Thread priority, Cpu Rings, and hardware IRQ. Now let's discuss the differences between them.<BR><BR><BR><STRONG>IRQL vs. Thread priority:</STRONG><BR><BR><BR>See ddk about Thread priority:<BR><BR><STRONG>priority<BR></STRONG><BR>An attribute of a thread that determines when and how often the thread is scheduled to run. For a running thread, its priority falls into either of two classes, each class with sixteen levels:<EM><BR><BR>&nbsp;- Variable priority class has values in the range 0 to 15. This class is used by most threads.<BR><BR>Threads with variable priority are always preemptible; that is, they are scheduled to run round-robin with other threads at the same level. In general, the Kernel manages a variable-priority thread as follows: when the thread is interactive with a user, its priority is high (given a boost); otherwise, its priority decays by one level per quantum the thread runs until it reaches its original programmer-defined base priority level.<BR><BR>&nbsp;- Real-time priority class has values in the range 16 to 31. This class is used by time-critical threads, making such a thread preemptible only by a thread with higher priority.<BR><BR></EM>Note that any thread, whatever its priority attribute, is always preemptible by a software or hardware interrupt. </P>
<P><BR>A priority of a thread only affects the decisions of system scheduler:<BR>1) When to execute this thread ?<BR>2) How many will this thread take the time slices ?<BR>The scheuler will decide them based on the priority of the thread.<BR><BR>Generally all the threads (including system threads which runs in ring0, kernel space) run at PASSIVE_LEVEL IRQL: no interrupt vectors are masked. And the scheduler who determinates the state of all the threads runs at DISPATCH_LEVEL.<BR><BR>System realizes it's preemption attribution via thread priority, the executor is the scheduler,. but another attribution "interruptible? of windows nt, is implemented via IRQL.<BR><BR>Windows NT is interruptible, i.e., any codes could be interrupted by higher IRQL interrupt. Every developer should keep it in mind.<BR><BR><STRONG>IRQL vs.Cpu Rings:<BR></STRONG><BR>For x86 cpu, it has 4 rings: 0, 1, 2, 3<BR><BR>Every ring defines it's privilege, such as memory page access, io access ?Windows only uses ring0 and ring3. Kernel uses ring0, and user routines use ring3.<BR><BR>IRQL only exists in kernel space. For user space, it's meaningless. All user threads are running at PASSIVE_LEVEL, though they can result in a task switch to kernel space and change the IRQL. They could not access the IRQL directly.<BR>And also, from assemble codes of KeGetCurrentIRQL, we know that current IRQL locates at [ffdff024]. Address ffdff024 is in kernel space.<BR><BR><BR><STRONG>IRQL vs. Hardware IRQs:<BR></STRONG><BR><BR>For X86 system, it has two 8259 pics (programmable interrupt controller), each could handle 8 IRQs. But the slave 8259 pic is attached to master 8259 's pin 2 (IRQ2). So there are 15 IRQs available. </P>
<P><IMG title="[转] Understanding IRQL - Howie - Dspace"   alt=""   src="pic/img2.ph.126.net_mXxhlBdGrMsctrlzPtYfLQ==_1871808595226021816.jpg"   ><BR><BR>In general, IRQ 0 has the highest privilege, the next is IRQ 1, the last is IRQ7. (Irq 8 ?Irq 15 have the same privilage with IRQ2 ?).<BR><BR>For each IRQ, we can mask it by zero the correspond bit of IMR (interrupt mask register, port 21h for the master 8259, 0xA1h for the slave.). The IMR register is only writable, it is not readable. So system must store it's current value. For each IRQL, Windows NT maintains a table of IMR at hal!KiI8259MaskTable. (Softice's IRQ command possibly uses this value, I'm not sure.)<BR><BR>The realizaton of IRQ priorities is dependent to hardware (8259 pic). Windows uses hardware independent IRQL to mask all the differences of the various hardwares. IRQL can be looked as an extension of hardware IRQ levels. But IRQL is defined and manipulated by the OS, it's an action of software. The IRQLs of a lower priority IRQ may be a higher level. (See the output result of "intobj?under softice.)<BR><BR>To manager IRQs, windows uses Interrupt Object (KINTERRUPT). The interrupt object is initialized and tied to system interrupt objects chain, when device drivers call IoConnectInterrupt.<BR><BR>Structure Definition of Interrupt object:<BR><BR>typedef struct _KINTERRUPT { // Size: 0x1E4<BR>/*000*/ CSHORT Type<BR>/*002*/ USHORT Size<BR>/*004*/ LIST_ENTRY InterruptListEntry<BR>/*00C*/ ULONG ServiceRoutine<BR>/*010*/ ULONG ServiceContext<BR>/*014*/ SpinLock<BR>/*018*/ Spare1<BR>/*01C*/ ActualLock<BR>/*020*/ DispatchAddress<BR>/*024*/ Vector // The tied vector of this IRQ<BR>/*028*/ Irql // Current IRQ's IRQL<BR>/*029*/ SynchronizeIrql // The SynchronizeIRQL of the IRQ (To be detailed later)<BR>/*02A*/ FloatingSave<BR>/*02B*/ Connected<BR>/*02C*/ Number<BR>/*02D*/ ShareVector<BR>/*030*/ Mode<BR>/*034*/ Spare2<BR>/*038*/ Spare3<BR>/*03C*/ DispatchCode<BR>} KINTERRUPT, *PKINTERRUPT;<BR><BR>// List all the interrupt objecits in softice<BR>:intOBJ<BR><BR>Object Service Service Affinity<BR>Address Vector Address Context IRQL Mode Mask Symbol<BR>FF263408 31 F0470A0A FF2AF440 1A Edge 01 i8042prt!.text+070A<BR>FF264D88 33 FC8CEAA0 FF2991D4 18 Edge 01 NDIS!PAGENDSMqN<BR>FF25DA88 37 FC8CEAA0 FF25BBBC 14 Edge 01 NDIS!PAGENDSMqN<BR>FCD6DD88 39 FC999454 FCDB48E8 12 Level 01 ACPI!.text+9134<BR>FF285008 39 F06D2536 FCD615D0 12 Level 01 uhcd!.text+2256<BR>FF2853C8 39 F06D2536 FCD60030 12 Level 01 uhcd!.text+2256<BR>FF274988 39 F06D2536 FCD60AD0 12 Level 01 uhcd!.text+2256<BR>FF299D88 39 FC59AE4A FF2AC0F0 12 Level 01 ltmdmnt!.text+2B2A<BR>FF25C008 39 FC574CE0 FF25E208 12 Level 01 portcls!.text+19C0<BR>FF262D88 3C F0476F00 FF2AA020 0F Edge 01 i8042prt!PAGEMOUCk<BR>FCD6B668 3E FC926E42 FCD52030 0D Edge 01 atapi!.text+5AE2<BR>FCD67B48 3F FC926E42 FCD68030 0C Edge 01 atapi!.text+5AE2<BR><BR>E.g., from the output of "intobj? We see that the IRQL of IRQs. Eg: IRQ 1's vector is 0x31, it's IRQL is 0x1AH. And we also know that driver i8042prt connects this IRQ.<BR><BR>Each IRQ is associated with a vector and the system uses vector rather than IRQ. For widows nt, the vector equals (IRQ number + 0x30), See Softice's output of command "IRQ?<BR><BR>:irq<BR><BR>IRQ Vector Status<BR>00 30 Unmasked<BR>01 31 Unmasked<BR>02 32 Unmasked<BR>03 33 Unmasked<BR>04 34 Masked<BR>05 35 Masked<BR>06 36 Masked<BR>07 37 Unmasked<BR>08 38 Unmasked<BR>09 39 Unmasked<BR>0A 3A Masked<BR>0B 3B Masked<BR>0C 3C Unmasked<BR>0D 3D Masked<BR>0E 3E Unmasked<BR>0F 3F Unmasked<BR><BR>Generally, we call IRQ interrupt under the protect mode. It has two types:<BR><BR>1, NMI (NonMaskable Interrupt)<BR><BR>This type of interrupt is reported to cpu via the NMI pin, it can not be masked by zero the Eflags's IF bit. It's vector is 02h.<BR><BR>2, INTR (Maskable Interrupt)<BR><BR>This type could be masked by zero. Cpu Eflags IF bit. They are reported to cpu via INTR pin. But cpu needs to access the data bus to get the vector number.<BR>When eflags IF is zero, the INTR will wait until the IF is set to 1.<BR><BR>Besides interrupt, under protect mode, exceptions also use vector numbers.<BR><BR>Exception has three types: (For detail info, see intel cpu manual.)<BR><BR>1, Fault (Eg. Page Fault 0x0E)<BR>2, Trap ( Eg. NTCall, int 0x2E)<BR>2, Abort ( Severe Errors)<BR><BR>The difference of Fault of Trap is that: The instructions which result in the fault will be executived again after finishing the process of the fault. But for a trap, like (int 0x2e), the instructions which result in the trap will be skipped and the next instruction will be executived.<BR><BR>Exceptions use 0x0 ? 0x1f (0x02 is excluded) as their vector numbers.<BR><BR>When an interrupt or exception arise, cpu will clear the eflags IF bit automatically. But for a trap, it will not try to modify the IF bit of eflags.<BR><BR>Cpu register IDTR stores the start address of the table of the entries of vectors.<BR>In Softice, to get the entry of vector 31 (IRQ 1):<BR><BR>:idt 31<BR>Int Type Sel:Offset Attributes Symbol/Owner<BR>0031 IntG32 0008:FF263444 DPL=0 P<BR><BR>So, when IRQ 1 raises, cpu will automatically run the instructions at 0008:FF263444 as response to the interrupt.<BR><BR>For more detail information, please refer Intel CPU Mannuals.<BR><BR><BR><STRONG>Part II:</STRONG><BR>In this part, we'll discuss how the OS realize SpinLocks via IRQL<BR><BR>Realization of SpinLocks:<BR><BR>Spin locks are very commonly used in drivers to protect data that will be accessed by multiple driver routines running at varying IRQLs. But what's it's realizaton ?<BR>Every book about "Operating System?will tell us that an atomic test-and-set instruction will be adopted. Is windows os uses this way ? The answer is NO. What windows nt adopts is IRQL. That is the spinlock routines will change the IRQL.<BR><BR>There are some kernel routines to acquire/release SpinLocks available for driver developers. These routines are not strange faces, so I'll not introduce their functionalities here.<BR><BR>VOID<BR>KeAcquireSpinLock(<BR>IN PKSPIN_LOCK SpinLock,<BR>OUT PKIRQL OldIrql<BR>);<BR><BR>VOID<BR>KeReleaseSpinLock(<BR>IN PKSPIN_LOCK SpinLock,<BR>IN KIRQL NewIrql<BR>);<BR><BR>VOID<BR>KeAcquireSpinLockAtDpcLevel(<BR>IN PKSPIN_LOCK SpinLock<BR>);<BR><BR>VOID<BR>KeReleaseSpinLockFromDpcLevel(<BR>IN PKSPIN_LOCK SpinLock<BR>);<BR><BR>DDk says that "Callers of KeAcquireSpinLock must be running at IRQL &lt;= DISPATCH_LEVEL? for dispatch_level routines, .it would be better to use KeAcuireSpinLockAtDpcLevel, and that callers of KeReleaseSpinLock are running at IRQL DISPATCH_LEVEL, but why ?<BR><BR>The following codes tell us the answer:<BR><BR>kd&gt; u Hal!KeAcquireSpinLock<BR>hal!KeAcquireSpinLock:<BR>80066806 8b4c2404 mov ecx,[esp+0x4]<BR>8006680a e849c7ffff call hal!KfAcquireSpinLock (80062f58)<BR>8006680f 8b4c2408 mov ecx,[esp+0x8]<BR>80066813 8801 mov [ecx],al<BR>80066815 c20800 ret 0x8<BR><BR>hal!KfAcquireSpinLock:<BR>80062f58 33c0 xor eax,eax<BR><BR>// Save current IRQL to al<BR>80062f5a a024f0dfff mov al, [ffdff024]<BR><BR>// Change Current IRQL to Dispatch Level<BR>80062f5f c60524f0dfff02 mov byte ptr [ffdff024],0x2<BR>80062f66 c3 ret<BR><BR>Then we get the result: The acquiration of spin lock is just only improve current IRQL to DISPATCH_LEVEL. So the article "A Catalog of NT Synchronization Mechanisms?(refer. 2) says "Always relying on spin locks to protect access to shared data may be overkill? Because after the SpinLock is acquired , the current IRQL will be DISPATCH_LEVEL and then the NT dispatcher (scheduler) preemption will be disabled.<BR><BR>But for the routine which is already running at DISPATCH_LEVEL, they are advised .to use KeAcquireSpinLockAtDpcLevel instead. We can image what KeAcquireSpinLockAtDpcLevel do?<BR><BR>kd&gt; u KeAcquireSpinLockAtDpcLevel<BR>nt!KeAcquireSpinLockAtDpcLevel:<BR>804022e4 c20400 ret 0x4<BR><BR>nt!KeReleaseSpinLockFromDpcLevel:<BR>804022f4 c20400 ret 0x4<BR><BR>These two routines do nothing, and just return. As all DISPATCH_LEVEL all the routines will be executed synchronously, they can not interrupt each other, i.e. they are alreary synchronized.<BR><BR>When current IRQL &gt; DISPATCH_LEVEL, we are warned never to call spin lock routines , or we'll get BSOD. Here we get the reason: KeAcquireSpinLock will try to lower the current IRQL, which is not permitted by NT.<BR><BR><BR><STRONG>Part III:<BR></STRONG>I'll discuss how the OS realize IRQL with two examples: The process of ISR Synchronize Lock and interrupt service routine.<BR><BR><BR>1, ISR Synchronize Lock<BR><BR>SpinLocks have three types:<BR><BR>1, standard spin locks<BR>2, ISR synchronization spin locks. Each type has its own IRQL associations<BR>3, default ISR (Interrupt Service Request) spin locks<BR><BR>For "standard spin locks ? we've analyzed it at Part II. Now let's anaylize the left two locks.<BR><BR>Whne developing a video miniport driver, I've ever met such an case: to protect some shared data between StartIO and ISR. As we all know, IRQ runs at DIRQL, and we can not call the stand spinlocks.<BR><BR>I noticed that videoport supported an routine VideoPortAcquireDeviceLock. The ddk does not say more about the limits. So I got BSOD when calling this routine in the ISR.<BR><BR>I disassembled it and found it that it used a dispatch synchronize object (Mutex). See the assembles codes below,<BR><BR>:u VideoPortAcquireDeviceLock<BR><BR>0008:EB095392 XOR EAX,EAX<BR>0008:EB095394 PUSH EAX<BR>0008:EB095395 PUSH EAX<BR>0008:EB095396 PUSH EAX<BR>0008:EB095397 PUSH EAX<BR>0008:EB095398 MOV EAX,[ESP+14] //EAX = HwDeviceExtension<BR>0008:EB09539C MOV EAX,[EAX-0228] // The Mutex maintained by VideoPort<BR>0008:EB0953A2 ADD EAX,30<BR>0008:EB0953A5 PUSH EAX<BR>0008:EB0953A6 CALL [__imp__KeWaitForSingleObject]<BR>0008:EB0953AC RET 0004<BR><BR>:u VideoPortReleaseDeviceLock<BR><BR>0008:EB0953B0 MOV EAX,[ESP+04]<BR>0008:EB0953B4 PUSH 00<BR>0008:EB0953B6 MOV EAX,[EAX-0228]<BR>0008:EB0953BC ADD EAX,30<BR>0008:EB0953BF PUSH EAX<BR>0008:EB0953C0 CALL [__imp__KeReleaseMutex]<BR>0008:EB0953C6 RET 0004<BR><BR>Luckly the videoport supports another mechanism of VideoPortSynchronizeExecution, which will call KeSynchronizeExecution. So let us analyze KeSynchronizeExecution.<BR><BR><BR>BOOLEAN<BR>KeSynchronizeExecution(<BR>IN PKINTERRUPT Interrupt,<BR>IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,<BR>IN PVOID SynchronizeContext<BR>);<BR><BR>SynchronizeRoutine:<BR><BR>BOOLEAN<BR>(*PKSYNCHRONIZE_ROUTINE) ( IN PVOID SynchronizeContext );<BR><BR>KeSynchronizeExecution will call KfRaiseIRQL to raise current processor's IRQL to the InterruptObjects's SynchronzieIRQL and mask all the IRQs below the SynchronizeIRQL, then execute the SynchronizeRoutine which will operate shared sensitive data, and call KfLowerIrql to do the restoring.at the end.<BR><BR>At the time SynchronizeRoutine is called, the interrupt specified by the interrupt object: interrupt will be masked. The the protection of the access of the shared data is achieved.<BR><BR>Followings are the asm codes, from WinDbg.<BR><BR>kd&gt; u nt!KeSynchronizeExecution<BR>nt!KeSynchronizeExecution:<BR>80468a70 55 push ebp<BR>80468a71 8bec mov ebp,esp<BR>80468a73 83ec04 sub esp,0x4<BR>80468a76 53 push ebx<BR>80468a77 56 push esi<BR><BR>//Raise Current IRQL to Interrupt-&gt;SynchronizeIrql<BR>80468a78 8b5d08 mov ebx,[ebp+0x8] //ebx = Interrupt<BR>80468a7b 8b4b29 mov ecx,[ebx+0x29] //cl = Interrupt-&gt;SynchronizeIrql<BR>80468a7e ff15d8054080 call dword ptr [nt!_imp_KfRaiseIrql (804005d8)]<BR><BR>80468a84 8845fc mov [ebp-0x4],al // al = Old IRQL<BR>80468a87 8b731c mov esi,[ebx+0x1c]<BR>80468a8a 8b4510 mov eax,[ebp+0x10]<BR><BR>// Now call our SynchronizeRoutine<BR>80468a8d 50 push eax<BR>80468a8e ff550c call dword ptr [ebp+0xc] // SynchronizeRoutine<BR><BR>// Resotring ?BR&gt;80468a91 8bd8 mov ebx,eax<BR>80468a93 8b4dfc mov ecx,[ebp-0x4] // Restore Old IRQL<BR>80468a96 ff15dc054080 call dword ptr [nt!_imp_KfLowerIrql (804005dc)]<BR>80468a9c 8bc3 mov eax,ebx<BR>80468a9e 5e pop esi<BR>80468a9f 5b pop ebx<BR>80468aa0 c9 leave<BR>80468aa1 c20c00 ret 0xc<BR><BR><BR>kd&gt; u hal!kfRaiseIrql<BR>hal!KfRaiseIrql:<BR>80062ea0 33c0 xor eax,eax<BR>80062ea2 a024f0dfff mov al,[ffdff024] // Current IRQL<BR>80062ea7 0fb6c9 movzx ecx,cl<BR>80062eaa 80f902 cmp cl,0x2 // DISPATCH_LEVEL = 0x02<BR>80062ead 7625 jbe hal!KfRaiseIrql+0x34 (80062ed4)<BR>80062eaf 8bd0 mov edx,eax<BR>80062eb1 9c pushfd<BR>80062eb2 fa cli<BR><BR>// Change IRQL to new<BR>80062eb3 880d24f0dfff mov [ffdff024],cl<BR><BR>// Besides changing current IRQL, it also mask all the IRQs below the SynchronizeIRQL<BR>80062eb9 8b048dcc890680 mov eax,[hal!KiI8259MaskTable (800689cc)+ecx*4]<BR>80062ec0 0b0530f0dfff or eax,[ffdff030]<BR>80062ec6 e621 out 21,al // Mask I8259 ?1 (IMR1)<BR>80062ec8 c1e808 shr eax,0x8<BR>80062ecb e6a1 out 0xA1, al // Mask I8259 ?2 (IMR2)<BR>80062ecd 9d popfd<BR>80062ece 8bc2 mov eax,edx<BR>80062ed0 c3 ret<BR>80062ed1 8d4900 lea ecx,[ecx]<BR>80062ed4 880d24f0dfff mov [ffdff024],cl<BR>80062eda c3 ret<BR><BR>hal!KfLowerIrql:<BR>80062f10 9c pushfd<BR>80062f11 0fb6c9 movzx ecx,cl<BR><BR>80062f14 803d24f0dfff02 cmp byte ptr [ffdff024],0x2<BR><BR>80062f1b fa cli<BR>80062f1c 7614 jbe hal!KfLowerIrql+0x22 (80062f32)<BR><BR>// Only need running when Current IRQL &gt; DISPATCH_LEVEL<BR>// Restore the 8259 settings<BR>80062f1e 8b048dcc890680 mov eax,[hal!KiI8259MaskTable (800689cc)+ecx*4]<BR>80062f25 0b0530f0dfff or eax,[ffdff030]<BR>80062f2b e621 out 21,al<BR>80062f2d c1e808 shr eax,0x8<BR>80062f30 e6a1 out a1,al<BR><BR>// Restore current IRQL<BR>80062f32 880d24f0dfff mov [ffdff024],cl<BR><BR>80062f38 a128f0dfff mov eax,[ffdff028]<BR>80062f3d 8a80648a0680 mov al,[eax+0x80068a64]<BR>80062f43 38c8 cmp al,cl<BR>80062f45 7705 ja hal!KfLowerIrql+0x3c (80062f4c)<BR>80062f47 9d popfd<BR>80062f48 c3 ret<BR>80062f49 8d4900 lea ecx,[ecx]<BR>80062f4c ff14854c8a0680 call dword ptr [hal!SWInterruptHandlerTable (80068a4c)+eax*4]<BR>80062f53 9d popfd<BR>80062f54 c3 ret<BR><BR>2, Default ISR (Interrupt Service Request) spin locks<BR><BR>When an interrupt raises, cpu will be notified by a signal via the INTR pin, then the cpu will read the vector from the data bus. After saving the current executing envrioment, cpu will get the entry of the interrupt from IDTR and execute the ISR routine.<BR><BR>Here the ISR routine is not just the service routine supported by the specific driver when connecting the IRQ. It's hooked by Windows. Windows will decide whether the interrupt request is from the device. If it is surely form a device, KiInterruptDispatch will be called to process the interrupt request.<BR><BR>KiInterruptDispatch will first call HalBeginSystemInterrupt to raise current IRQL and mask 8259A. Then call the service routine at KINTERRUPT object offset 0x0C, which do the really work to perform the interrupt request. Then KiInterruptDispatch calls HalDisableSystemInterrupt to do the restoring work. Then the response of an interrupt request ends.<BR><BR>Here we will analyze the process of Vector 0x31 as example.<BR>// Get the entry address of Vector 31 (IRQ 1)<BR>:idt 31<BR>Int Type Sel:Offset Attributes Symbol/Owner<BR>0031 IntG32 0008:FF263444 DPL=0 P<BR><BR><BR>kd&gt; u 0008:FF263444<BR>ff263444 54 push esp<BR>ff263445 55 push ebp<BR>ff263446 53 push ebx<BR>ff263447 56 push esi<BR>ff263448 57 push edi<BR>ff263449 83ec54 sub esp,0x54<BR>ff26344c 8bec mov ebp,esp<BR>ff26344e 89442444 mov [esp+0x44],eax<BR>ff263452 894c2440 mov [esp+0x40],ecx<BR>ff263456 8954243c mov [esp+0x3c],edx<BR><BR>// Current Stack:<BR>// ESP + 0: db * 0x54<BR>// ESP + 54: edi<BR>// ESP + 58: esi<BR>// ESP + 5C: ebx<BR>// ESP + 60: ebp<BR>// ESP + 64: esp<BR><BR>// ESP + 68: Old EIP<BR>// ESP + 6C: Old CS<BR>// ESP + 70: Old Eflags<BR><BR>// Eflags bit 17 is VM bit, if VM = 1, it shows that the caller is from V86 mode,<BR>// If the caller is from V86 mode, jump to ff26357b<BR>ff26345a f744247000000200 test dword ptr [esp+0x70],0x20000<BR>ff263462 0f8513010000 jne ff26357b<BR><BR>// For kernel space, CS = 0x08, it need not save the segments<BR>// For user space (?), it will change current segments registers<BR><BR>ff263468 66837c246c08 cmp word ptr [esp+0x6c],0x8<BR>ff26346e 7423 jz ff263493<BR>ff263470 8c642450 mov [esp+0x50],fs<BR>ff263474 8c5c2438 mov [esp+0x38],ds<BR>ff263478 8c442434 mov [esp+0x34],es<BR>ff26347c 8c6c2430 mov [esp+0x30],gs<BR>ff263480 bb30000000 mov ebx,0x30<BR>ff263485 b823000000 mov eax,0x23<BR>ff26348a 668ee3 mov fs,bx<BR>ff26348d 668ed8 mov ds,ax<BR>ff263490 668ec0 mov es,ax<BR><BR>// ? Modify the exception record structure<BR>ff263493 648b1d00000000 mov ebx,fs:[00000000]<BR>ff26349a 64c70500000000ffffffff mov dword ptr fs:[00000000],0xffffffff<BR><BR>ff2634a5 895c244c mov [esp+0x4c],ebx<BR>ff2634a9 81fc00000100 cmp esp,0x10000<BR>ff2634af 0f829e000000 jb ff263553<BR>ff2634b5 c744246400000000 mov dword ptr [esp+0x64],0x0<BR>ff2634bd fc cld<BR>ff2634be f60550f0dfffff test byte ptr [ffdff050],0xff<BR>ff2634c5 750c jnz ff2634d3<BR><BR>ff2634c7 bf083426ff mov edi,0xff263408 // IntOBJ<BR>ff2634cc e9cf562081 jmp nt!KiInterruptDispatch (80468ba0)<BR><BR>ff2634d1 8bff mov edi,edi<BR>ff2634d3 f7457000000200 test dword ptr [ebp+0x70],0x20000<BR>ff2634da 7509 jnz ff2634e5<BR>ff2634dc f7456c01000000 test dword ptr [ebp+0x6c],0x1<BR>ff2634e3 74e2 jz ff2634c7<BR>ff2634e5 0f21c3 mov ebx,dr0<BR><BR>?BR&gt;<BR>kd&gt; u KiInterruptDispatch<BR>nt!KiInterruptDispatch:<BR>80468ba0 ff0560f5dfff inc dword ptr [ffdff560]<BR>80468ba6 8bec mov ebp,esp<BR>80468ba8 8b4724 mov eax,[edi+0x24]<BR>80468bab 8b4f29 mov ecx,[edi+0x29]<BR>80468bae 50 push eax<BR>80468baf 83ec04 sub esp,0x4<BR><BR>// Initialize Current IRQL &amp; 8259A<BR>80468bb2 54 push esp<BR>80468bb3 50 push eax<BR>80468bb4 51 push ecx<BR>80468bb5 ff1580054080 call dword ptr [nt!_imp__HalBeginSystemInterrupt (80400580)]<BR>80468bbb 0bc0 or eax,eax<BR>80468bbd 741a jz nt!KiInterruptDispatch+0x39 (80468bd9)<BR>80468bbf 8b771c mov esi,[edi+0x1c]<BR>80468bc2 8b4710 mov eax,[edi+0x10]<BR><BR>// Now call IntObj - ISR<BR>80468bc5 50 push eax<BR>80468bc6 57 push edi<BR>80468bc7 ff570c call dword ptr [edi+0xc]<BR>80468bca fa cli<BR><BR>// Restore ?BR&gt;80468bcb ff1584054080 call dword ptr [nt!_imp__HalEndSystemInterrupt (80400584)]<BR><BR>// Finish the process of the interrupt<BR>80468bd1 e9e0c7ffff jmp nt!Kei386EoiHelper (804653b6)<BR>80468bd6 83c408 add esp,0x8<BR>80468bd9 83c408 add esp,0x8<BR>80468bdc e9d5c7ffff jmp nt!Kei386EoiHelper (804653b6)<BR><BR>kd&gt; u hal!HalBeginSystemInterrupt<BR><BR>hal!HalBeginSystemInterrupt:<BR>80067ab8 0fb65c2408 movzx ebx,byte ptr [esp+0x8]<BR><BR>// Ebx = Vector Number, Ebx ?0x30 = IRQ number<BR>80067abd 83eb30 sub ebx,0x30<BR><BR>//hal!HalpSpecialDismissTable = 80068a6c<BR>80067ac0 ff249d6c8a0680 jmp dword ptr [hal!HalpSpecialDismissTable+ebx*4]<BR><BR><BR>hal!HalBeginSystemInterrupt+3b:<BR>// Entry of IRQ 1<BR>80067af3 8b44240c mov eax,[esp+0xc]<BR><BR>// Save current IRQL, and change to new value from CL<BR>80067af7 0fb70d24f0dfff movzx ecx,word ptr [ffdff024]<BR>80067afe 8808 mov [eax],cl<BR>80067b00 0fb6442404 movzx eax,byte ptr [esp+0x4]<BR>80067b05 a224f0dfff mov [ffdff024],al // al = 0x1a<BR><BR>// Mask 8259A IRQs<BR>80067b0a 8b0485cc890680 mov eax,[hal!KiI8259MaskTable (800689cc)+eax*4]<BR>80067b11 0b0530f0dfff or eax,[ffdff030]<BR><BR>// eax = fffffefa [ffdff030] = 70 2c ff ff | Result: fffffefa<BR>// Mask 8259A (IMR 1/2 (with Timer / Real Time exculed))<BR><BR>80067b17 e621 out 21,al<BR>80067b19 c1e808 shr eax,0x8<BR>80067b1c e6a1 out a1,al<BR><BR>80067b1e 8bc3 mov eax,ebx<BR>80067b20 83f808 cmp eax,0x8<BR>80067b23 7306 jnb hal!HalBeginSystemInterrupt+0x73 (80067b2b)<BR>80067b25 0c60 or al,0x60<BR>80067b27 e620 out 20,al<BR>80067b29 eb08 jmp hal!HalBeginSystemInterrupt+0x7b (80067b33)<BR>80067b2b b020 mov al,0x20<BR>80067b2d e6a0 out a0,al<BR><BR>80067b2f b062 mov al,0x62<BR>80067b31 e620 out 20,al<BR>80067b33 e421 in al,21<BR><BR>80067b35 fb sti<BR>80067b36 b801000000 mov eax,0x1<BR>80067b3b c20c00 ret 0xc<BR><BR><BR>// HalDisableSystemInterrupt is just reverse to HalBeginSystemInterrupt<BR><BR>hal!HalDisableSystemInterrupt:<BR>80067b40 0fb64c2404 movzx ecx,byte ptr [esp+0x4]<BR>80067b45 83e930 sub ecx,0x30<BR>80067b48 ba01000000 mov edx,0x1<BR>80067b4d d3e2 shl edx,cl<BR>80067b4f fa cli<BR>?BR&gt;800630b7 e621 out 21,al<BR>800630b9 c1e808 shr eax,0x8<BR>800630bc e6a1 out a1,al<BR>800630be 880d24f0dfff mov [ffdff024],cl<BR>800630c4 a128f0dfff mov eax,[ffdff028]<BR>800630c9 8a80648a0680 mov al,[eax+0x80068a64]<BR>800630cf 38c8 cmp al,cl<BR>800630d1 7703 ja hal!HalEndSystemInterrupt+0x3a (800630d6)<BR>800630d3 c20800 ret 0x8<BR>?BR&gt;<BR><BR><BR><BR>【References】<BR>1, www.osr.com Nt Insider 1997: "A Catalog of NT Synchronization Mechanisms?BR&gt;2, "practice of 80386/486 system programming?by XiaoQing Lieu (Chinese)<BR><BR><BR>Any questions or errors, just mail to me.<BR><BR>Thanks!<BR><BR>Matt<BR><BR>http://sys.xiloo.com<BR>mattwu@163.com<BR><BR>Written at Apr. 23 2002<BR>Updated at Apr. 28 2002 </P>
</body></html>