<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] 将程序移植到64位Windows</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] 将程序移植到64位Windows</h2>
<p align="right">发布时间：2010-2-11 15:31
<br>分类名称：windows</p><br>
<p><strong><span>简介：</span></strong><span>本文对如何将</span><span>32</span><span>位</span><span>Windows</span><span>程序平滑的支持和过渡到</span><span>64</span><span>位</span><span>Windows</span><span>操作系统做出了一个简单而系统的介绍。包括对于</span><span>64</span><span>位操作系统的版本，编程模型，一些移植原则甚至包括对驱动程序的移植原则的介绍。</span><span>   </span></p>  <p style="text-align: left;"  align="left"  ><span>作者介绍：系统分析员，现在<span>在</span>北京工作。作者的</span><span><span>blog</span></span><span>：</span><span>http://goooder.blogchina.com.</span></p>  <h2><span>前言：</span></h2>  <p><span>或许大家还对</span><span>32</span><span>位的</span><span>CPU</span><span>及操作系统使用还是觉得非常的合乎日常需要，但</span><span>Windows   64</span><span>位已经悄悄的来到了各位的身边。不少软件厂商也纷纷宣称自己的软件已经支持</span><span>64</span><span>位操作系统了。</span></p>  <p><span>笔者在几个月之前就成功的实施了一个软件的</span><span>64</span><span>位操作系统移植。大致方案是，上层应用程序仍然使用</span><span>32</span><span>位程序，但将该系统软件的驱动程序统统的变成了</span><span>64</span><span>位。这也是让应用程序支持</span><span>64</span><span>位的最小代价。整个过程前后不到一个月</span><span>(</span><span>两个人月</span><span>)</span><span>，就解决了大部分问题。而一些难啃的骨头都是因为以前的编码不太规范而引起的。因为这不是本文的主题，所以就此打住。</span><span>   </span></p>  <p><span>下面的内容就是我在工作过程中整理各种资料所得到的成果。为了文章的系统性，中间转贴了一些</span><span>MSDN</span><span>中文网站的内容。希望能对大家的工作有所帮助。</span></p>  <h2><span><span>一</span></span><span>．最有可能受益于</span><span>64</span><span>位的应用</span></h2>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要大量的可寻址内存，因而系统总体内存需求超过</span><span>4GB   </span><span>的应用。例如那些采用大型数据集的应用（金融和科学建模软件）和基于主机的桌面应用（在不降低性能的情况下同时运行多个线程）；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>必须同时管理大量的用户或者应用线程，例如大规模的瘦客户端解决方案，大型数据库，以及用于客户关系管理（</span><span>CRM</span><span>）、供应链管理（</span><span>SCM</span><span>）、企业资源规划（</span><span>ERP</span><span>）和数字版权管理（</span><span>DRM</span><span>）系统中的解决方案的数据仓库应用；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要通过实时加密和解密提高安全性的应用，包括电子商务应用和对专用或者分类数据的保护；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要数学精度和浮点性能的应用，包括建模、模拟、统计和金融分析、图像</span><span>/</span><span>视频</span><span>/</span><span>信号处理、物理、医学研究、远程通信、加密和压缩；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要大规模的、强大的数据库性能的应用，包括决策支持，搜索和索引，文档和内容管理，以及语音识别；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要</span><span>64   </span><span>位计算的大内存寻址功能的应用，包括很多高性能计算（</span><span>HPC</span><span>）群集应用；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要提供数字内容创建功能，例如计算机辅助设计、制造和工程（</span><span>CAD</span><span>、</span><span>CAM   </span><span>和</span><span>CAE</span><span>）、数字音乐制作和视频编辑，以及实时媒体<span>流解决</span>方案；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要通过最大限度的性能实现逼真的<span>影院级</span>消费者体验，包括计算机游戏、数字视频和协作；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>l<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>需要将以前只限于</span><span>64   </span><span>位工作站的功能移植到企业、消费者和计算机爱好者的台式机中，包括</span><span>3D   </span><span>建模、渲染、动画、模拟和软件开发。</span></p>  <h2><span>二．</span><span>Windows   XP</span><span>的</span><span>64</span><span>位版分类</span></h2>  <p><span>微软在</span><span>2003</span><span>年</span><span>3</span><span>月</span><span>28</span><span>日发布了</span><span>64</span><span>位的</span><span>Windows   XP</span><span>。</span><span>64</span><span>位的</span><span>Windows   XP</span><span>称</span><span>Windows XP 64-Bit   Edition</span><span>。其实就是</span><span>64</span><span>位版本的</span><span>Windows XP   Professional</span><span>。根据不同的微处理器架构，它分为两个不同版本：</span></p>  <h3 style="text-indent: -21pt; margin-left: 21pt;"  ><span>1.</span><span>IA-64</span><span>版的</span><span>Windows   XP</span></h3>  <p><span>针对英特尔</span><span>(Intel)</span><span>的</span><span>IA-64</span><span>架构的安腾</span><span>2(Itanium2)</span><span>纯</span><span>64</span><span>位微处理器的</span><span>Windows   XP 64-Bit Edition Version 2003 for Itanium-based   Systems</span><span>。它是拥有</span><span>64</span><span>位寻址能力的强大的操作系统，主要面向顶级的高端</span><span>IA-64</span><span>架构的工作站，用在高端的科学运算，石油探测工艺，立体绘图，复杂的动画制作等等，是一种用在高效能运算</span><span>(High   Performance Computing)</span><span>的强大的操作系统。估计它可能会改名为</span><span>Windows XP   Professional Itanium-based   Edition</span><span>。支持双处理器；最低支持</span><span>1GB</span><span>的内存，最高支持</span><span>16GB</span><span>的内存。</span></p>  <h3 style="text-indent: -21pt; margin-left: 21pt;"  ><span>2.</span><span>x64</span><span>版的</span><span>Windows   XP</span></h3>  <p><span>针对超微</span><span>(AMD)</span><span>的</span><span>x64</span><span>架构的<span>皓</span>龙</span><span>(<span>Opteron</span>)</span><span><span>与速龙</span></span><span>64(Athlon64)</span><span>所属的</span><span>64</span><span>位扩展微处理器的</span><span>Windows   XP 64-Bit Edition for 64-Bit Extended   Systems</span><span>。由于英特尔也发布了</span><span>x64</span><span>架构的</span><span>Intel   EM64T</span><span>技术的至强</span><span>(Xeon)</span><span>与奔腾</span><span>4(Pentium   4)</span><span>的</span><span>64</span><span>位扩展微处理器，故微软将该版本的<span>的</span></span><span>Windows XP 64-Bit   Edition</span><span>改为</span><span>Windows XP Professional x64   Edition</span><span>，它支持</span><span>AMD</span><span>与</span><span>Intel</span><span>的</span><span>x64</span><span>架构。可以使用在一般</span><span>x64</span><span>架构的工作站，桌面电脑以及笔记本电脑，用途与</span><span>32</span><span>位</span><span>Windows   XP   Professional</span><span>一样，但具有</span><span>64</span><span>位寻址能力。支持双处理器；最低支持</span><span>256MB</span><span>的内存，最高支持</span><span>16GB</span><span>的内存。</span></p><h2><span>三．</span><span>x64</span><span>版的</span><span>Windows</span><span>操作系统的设计目标</span></h2>  <p><span>x64</span><span>版有</span><span>5</span><span>大特征，即：</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>1.<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>同时轻松支持</span><span>32</span><span>位</span><span>Win32</span><span>程序及</span><span>64</span><span>位程序；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>2.<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>在</span><span>64</span><span>位运行的程序代码和</span><span>32</span><span>位运行的程序应该是同一份代码；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>3.<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>使现有程序具有企业级应用性能；（</span><span>Enable existing applications to   scale to enterprise capacities</span><span>）</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>4.<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>支持新的设计使之可以利用巨大地址空间及内存空间；</span></p>  <p style="text-indent: -21pt; margin-left: 21pt;"  ><span>5.<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>支持</span><span>32</span><span>位既有程序。</span></p>    <p><span>x64 </span><span>位平台并没有出现</span><span> Win64   API</span><span>，它仍然是熟悉的</span><span> Win32   API</span><span>（现在更合适的名称为</span><span> Windows   API</span><span>）。但它出现了一些新的兼容</span><span> 64   </span><span>位的数据类型，所以可能需要对代码进行少量的更改。这就意味着开发者可以从单个代码库构建代码的</span><span> 32   </span><span>位和</span><span> 64   </span><span>位版本，减少了由于维护两个代码库所带来的维护开销。</span></p>    <p><span>但是，在</span><span>x64</span><span>中，</span><span>Microsoft   </span><span>已经去除了一些旧的组件，如</span><span> Win16   </span><span>子系统。所以</span><span>Windows 64 </span><span>位代码不支持</span><span>16   </span><span>位的</span><span>Windows</span><span>程序。也不支持</span><span> POSIX   </span><span>和</span><span> OS/2 </span><span>子系统。又出现了一个新的子系统，称为</span><span>   WOW64</span><span>。</span></p><h2><span>四．</span><span>x64</span><span>新出现的子系统</span><span>―WOW64</span></h2>  <p><span>WOW64 </span><span>是</span><span>   Windows-32-on-Windows-64 </span><span>的缩写。它为现有的</span><span> 32   </span><span>位应用程序提供了</span><span> 32 </span><span>位的模拟环境，可以使大多数</span><span> 32   </span><span>位应用程序在无需修改而直接运行在</span><span> Windows 64   </span><span>位版本上。它类似于旧的</span><span> WOW32 </span><span>子系统，负责在</span><span>   Windows 32 </span><span>位版本下运行</span><span> 16 </span><span>位的代码。</span></p><p><a target="_blank" href="pic/img.ph.126.net_zQP_XER5xfIm2ERw89efRQ==_3222607008360808888.gif"  ><img title="[转] 将程序移植到64位Windows - Dsliu - Dspace"  alt="[转] 将程序移植到64位Windows - Dsliu - Dspace"  src="pic/img.ph.126.net_zQP_XER5xfIm2ERw89efRQ==_3222607008360808888.gif"  ></a></p><p><span>尽管</span><span>x64 CPU</span><span>本身具有</span><span> 32   </span><span>位兼容性模式，可以处理</span><span> IA-32   </span><span>指令的实际执行，但</span><span>WOW   </span><span>层仍然必不可少。</span><span>WOW</span><span>子系统负责诸如在</span><span>32</span><span>位和</span><span>64</span><span>位模式之间进程切换以及模拟</span><span>32</span><span>位系统的服务。例如，</span><span>32</span><span>位和</span><span>64   </span><span>位程序具有不同的注册表配置单元，还有一个用于</span><span> 32   </span><span>位二进制文件的不同的系统目录，而且</span><span>64</span><span>位二进制文件仍然使用</span><span>   System32 </span><span>目录。因此，当</span><span> 32   </span><span>位应用程序安装到系统中时，</span><span>WOW</span><span>层会确保将</span><span>32</span><span>位二进制文件置于一个新的目录</span><span>   SysWOW64</span><span>中。这是通过如下方式实现的：根据应用程序是否运行在</span><span> WOW   </span><span>下，截获对</span><span> API </span><span>的调用（如</span><span> <span>GetSystemDirectory</span></span><span>）并返回适当的目录。类似的问题可能会存在于注册表中。因为</span><span>   32 </span><span>位和</span><span> 64 </span><span>位的</span><span> COM   </span><span>服务器都可以安装在系统上，并位于相同的类标识符</span><span> (CLSID)   </span><span>下，因此</span><span> WOW   </span><span>层需要将对注册表的调用重定向到适当的</span><span>32</span><span>位或</span><span>64</span><span>位配置单元中。</span><span>WOW   </span><span>层也会处理注册表中某些区域之间的镜像更改，以便使其更简单地支持</span><span>32</span><span>位和</span><span>64</span><span>位代码之间的交互操作。</span><span>   </span></p>  <p><span>WOW64 </span><span>非常重要，因为当不关注性能和<span>可</span>伸缩性的问题时，它使开发者可以利用大多数现有的</span><span>32</span><span>位代码。它是两种方法的最佳结合。开发者可以将应用程序服务迁移到</span><span>64</span><span>位，同时将</span><span>   Microsoft </span><span>管理控制台</span><span> (MMC)   </span><span>配置管理单元保留为</span><span>32</span><span>位。</span><span>Windows 64   </span><span>位版本包括</span><span>   MMC</span><span>的</span><span>32</span><span>位和</span><span>64</span><span>位的版本。当选择保留管理工具为</span><span>32</span><span>位时，进程间的通讯可能会遇到某些问题，但是只要接口设计正确，诸如远程过程调用</span><span>   (RPC)   </span><span>的协议应该可以在</span><span>32</span><span>位和</span><span>64</span><span>位进程之间运行。有关</span><span>   WOW64   </span><span>的另外一点需要牢记：它并不是为要求高性能的应用程序而设计的。至少，</span><span>WOW64</span><span>子系统需要将</span><span>32</span><span>位参数扩展到</span><span>64</span><span>位，并且需要将</span><span>64</span><span>位的返回值截断为</span><span>32</span><span>位。在最糟糕的情况下，</span><span>WOW64   </span><span>子系统将需要进行内核调用，涉及到的不仅仅是到内核的转换，还有从处理器的</span><span>32</span><span>位兼容性模式到其本机</span><span>64</span><span>位模式的转换。在</span><span>   WOW64   </span><span>下运行时，应用程序将无法妥当地进行调整。对于那些要将其保留为</span><span>32</span><span>位的应用程序而言，必须在</span><span>WOW64</span><span>下测试它们。如果性能不能满足期望，则需要考虑将应用程序迁移到</span><span>64</span><span>位。</span><span>   </span></p>  <p><span>WOW64</span><span>是在用户模式下实现的，作为</span><span>ntdll.dll</span><span>和内核之间的层。</span><span>WOW64</span><span>及其支持的一些</span><span>   DLL</span><span>仅仅是可以加载到</span><span>32</span><span>位进程中的</span><span>64</span><span>位的</span><span>   DLL</span><span>。对于所有其他情况，进程保持为纯进程。</span><span>32</span><span>位的进程无法加载</span><span>64</span><span>位的</span><span>DLL</span><span>，反之亦然。所以，请检查代码中的所有</span><span>“<span>LoadLibrary</span>”</span><span>调用是否有效。</span><span> </span></p>  <p><span>有关</span><span> WOW64   </span><span>的详细信息，请参阅</span><span> Microsoft_ Platform SDK   </span><span>中的</span><span>“64-bit Windows Programming - Running 32-bit   Applications”</span><span>。</span></p>  <h2><span>五．</span><span>64</span><span>位</span><span>windows</span><span>内存地址空间映射</span></h2>  <p><span>默认情况下，</span><span>Windows   32</span><span>位版本的地址空间限制在</span><span>4GB</span><span>，其中一半是为内核保留的。这限制了普通的应用程序只能使用</span><span>2GB</span><span>的有效虚拟内存。</span><span>2   GB</span><span>看起来好像很多，但是由于错误的分配算法、大型文件映射甚至过多的使用</span><span>   DLL</span><span>，地址空间很容易在应用程序中变得零碎。看一下任务管理器中的</span><span>“VM   Size”</span><span>列，就会发现普通应用程序消耗的虚拟内存量。当然，就想过去的</span><span> DOS   </span><span>时期（利用</span><span> XMS/EMS</span><span>）一样，有很多种方法可以使</span><span>   32 </span><span>位的应用程序访问多于</span><span> 4 GB   </span><span>的物理内存。进入物理地址扩展</span><span> (PAE)   </span><span>和地址窗口扩展（</span><span>Address Windowing   Extensions</span><span>，</span><span>AWE</span><span>）。</span><span>PAE   </span><span>通过将<span>地址位</span>的数量从</span><span> 32   </span><span>扩展到</span><span> 36 </span><span>来工作，这样使应用程序可以寻址的空间达到</span><span>   64 GB</span><span>。</span><span>AWE </span><span>使应用程序可以将大于</span><span> 4 GB   </span><span>的物理内存范围映射到虚拟地址空间中。这两种方法都引入了开销并增加了代码的复杂性。</span><span> </span></p>  <p><span>Windows 64 </span><span>位版本提供</span><span> 16 TB   </span><span>的   有效寻址空间，其中一半可用于用户模式的应用程序。这意味着整个数据库可以移动到内存中，显著地提高了性能，或者整个网站可以缓存到内存中。它还可以使代   码保留并委托到巨型的邻近虚拟内存块中，无需实际地担心虚拟内存碎片问题。这也考虑到了巨型文件映射对象或共享的内存部分。</span><span>   </span></p>  <p><span>下面是</span><span>64 </span><span>位体系结构和</span><span> 32   </span><span>位体系结构的比较表格：</span></p>  <p>  <table style="border-width: medium medium 1pt; border-style: none none solid; border-color: -moz-use-text-color; width: 377px; height: 215px;"  border="1"  cellpadding="0"  cellspacing="0"  >  <thead>  <tr>  <td style="border: medium none; padding: 0cm; width: 29%; background: none repeat scroll 0% 0% rgb(216, 225, 248); -moz-background-inline-policy: continuous;"  valign="top"  width="29%"  >  <p><span style="color: black;"  >地址空间</span></p></td>  <td style="border: medium none; padding: 0cm; width: 37%; background: none repeat scroll 0% 0% rgb(216, 225, 248); -moz-background-inline-policy: continuous;"  valign="top"  width="37%"  >  <p><span style="color: black;"  >64 </span><span style="color: black;"  >位</span><span style="color: black;"  > Windows</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm; width: 33%; background: none repeat scroll 0% 0% rgb(216, 225, 248); -moz-background-inline-policy: continuous;"  valign="top"  width="33%"  >  <p><span style="color: black;"  >32 </span><span style="color: black;"  >位</span><span style="color: black;"  >   Windows</span></p></td></tr></thead>  <tbody>  <tr>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>虚拟内存</span><span> </span></p></td>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>16 TB</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm;"  valign="top"  >  <p><span>4 GB</span></p></td></tr>  <tr>  <td style="border: medium none; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>页面文件</span><span> </span></p></td>  <td style="border: medium none; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>512 TB</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>16 TB</span></p></td></tr>  <tr>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>页面缓冲池</span><span> </span></p></td>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>128 GB</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm;"  valign="top"  >  <p><span>470 MB</span></p></td></tr>  <tr>  <td style="border: medium none; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>非页面缓冲池</span><span> </span></p></td>  <td style="border: medium none; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>128 GB</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm; background: none repeat scroll 0% 0% rgb(233, 233, 230); -moz-background-inline-policy: continuous;"  valign="top"  >  <p><span>256 MB</span></p></td></tr>  <tr>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>系统缓存</span><span> </span></p></td>  <td style="border: medium none; padding: 0cm;"  valign="top"  >  <p><span>1 TB</span></p></td>  <td style="border-width: medium 1pt medium medium; border-style: none solid none none; border-color: -moz-use-text-color; padding: 0cm;"  valign="top"  >  <p><span>1 GB</span></p></td></tr></table></p><p><span><br></span></p><p><span>下面是</span><span>Windows</span><span>系列内存地址空间分配比较：</span></p><p><a target="_blank" href="pic/img165.ph.126.net_B9ePypsI8Zr9wzbxGAYghQ==_2252081288663336659.jpg"  ><img title="[转] 将程序移植到64位Windows - Dsliu - Dspace"  alt="[转] 将程序移植到64位Windows - Dsliu - Dspace"  src="pic/img165.ph.126.net_B9ePypsI8Zr9wzbxGAYghQ==_2252081288663336659.jpg"  ></a></p><h2><span>七．将驱动移植到</span><span>64</span><span>位</span><span>Windows</span><span>操作系统</span></h2>  <p><span>x64</span><span>位操作系统和</span><span>x32</span><span>位操作系统的最大区别就是内存寻址方式的不同。而</span><span>64</span><span>位操作系统不支持</span><span>32</span><span>位的驱动程序，因为驱动程序和</span><span>windows</span><span>内核同处于一个地址空间中。这是移植</span><span>32</span><span>位驱动到</span><span>64</span><span>位驱动的最大原因。当然，</span><span>64</span><span>位驱动程序可以使用更大的分页内存，非分页内存及系统缓存。而且，你的设备从此就支持</span><span>64</span><span>位</span><span>windows</span><span>操作系统了。</span></p>  <h3><span>1</span><span>．在</span><span>X64</span><span>下的驱动程序安装</span></h3>  <p><span>除了要把应用程序的</span><span>32</span><span>位驱动程序变成</span><span>64</span><spn>位程序之外，驱动的安装程序和其它配置文件同样需要修改。也就是说，对于要在<span>x64</span><span>上运行的</span><span>32</span><span>位程序，它所依赖的驱动仍然需要是</span><span>64</span><span>位的。这些相关程序包括</span><span><span>inf</span></span><span>文件，</span><span>device installers,   class   installers</span><span>和</span><span>co-installers</span><span>。相关资料可查看</span><span>MSDN   <span>Libarary</span> DDK</span><span>：</span><span><a rel="nofollow" href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/Other_394c38ae-a3e6-45fb-87f2-c3e227cb6b7c.xml.asp"  ><span style="color: windowtext; text-decoration: none;"  >Porting Your Driver to 64-Bit   Windows</span></a></span><span>。</span><span> </span></p>  <p><span>所以，要改造应用程序的安装程序。方法是，让</span><span>32</span><span>位版的驱动安装为缺省安装选项，即用户插入安装光盘之后，依然运行</span><span>32</span><span>位安装程序。但当程序调用</span><span><span>UpdateDriverForPlugAndPlayDevices</span></span><span>返回值为</span><span>ERROR_IN_WOW64</span><span>时，这说明该安装程序正运行在</span><span>64</span><span>位</span><span>Windows</span><span>环境中。此时，这个安装程序应该调用</span><span><span>CreateProcess</span></span><span>函数来启动</span><span>64</span><span>位的安装进程。这个</span><span>64</span><span>位的安装进程通过调用</span><span>64</span><span>位驱动目录下的</span><span><span>inf</span></span><span>文件进行驱动安装。</span></p>  <h3><span>2</span><span>．驱动要支持</span><span>32</span><span>位</span><span>IOCTL</span></h3>  <h3><span>某些</span><span>IOCTL</span><span>可能包含含有指针的结构，所以，要特别小心的区别对待它，必须根据被调用者解析结构或者输出结构。</span></h3>  <p><span>有三种办法可以解决这个问题：</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span>1．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>尽量避免使用</span><span>IOCTL</span><span>传递包含有指针的结构；</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span>2．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>通过</span><span>API   IoIs32bitProcess</span><span>（）来判断上层调用者的程序类型；</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span>3．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>在</span><span>64</span><span>位程序中采用新的</span><span>IOCTL</span><span>命令；</span><span>   </span></p>  <p><span>例子：</span></p>  <p><span>IOCTL structure in header file</span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span><span style="font-size: 9pt;"  >typedef</span></span><span style="font-size: 9pt;"  > <span>struct</span> _IOCTL_PARAMETERS {</span></p>  <p><span style="font-size: 9pt;"  >PVOID <span>Addr</span>;</span></p>  <p><span style="font-size: 9pt;"  >SIZE_T Length;</span></p>  <p><span style="font-size: 9pt;"  >HANDLE <span>Handle</span>;</span></p>  <p><span style="font-size: 9pt;"  >} IOCTL_PARAMETERS,   *PIOCTL_PARAMETERS;</span></p></td></tr></table>    <p><strong><span>32-bit IOCTL structure</span></strong></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="font-size: 9pt;"  >//</span></p>  <p><span style="font-size: 9pt;"  >// This structure is defined   </span></p>  <p><span style="font-size: 9pt;"  >// inside the driver source   co<wbr>de</span></p>  <p><span style="font-size: 9pt;"  >//</span></p>  <p><span><span style="font-size: 9pt;"  >typedef</span></span><span style="font-size: 9pt;"  > <span>struct</span> _IOCTL_PARAMETERS_32 {</span></p>  <p><span style="font-size: 9pt;"  >VOID*POINTER_32 <span>Addr</span>;</span></p>  <p><span style="font-size: 9pt;"  >INT32 Length;</span></p>  <p><span style="font-size: 9pt;"  >VOID*POINTER_32   Handle;</span></p>  <p><span style="font-size: 9pt;"  >} IOCTL_PARAMETERS_32,   *PIOCTL_PARAMETERS_32;</span></p></td></tr></table>    <p><strong><span>32-Bit and 64-Bit IOCTL</span></strong></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="font-size: 9pt;"  >#<span>ifdef</span>   _WIN64</span></p>  <p><span style="font-size: 9pt;"  >case IOCTL_REGISTER:</span></p>  <p><span style="font-size: 9pt;"  >if (IoIs32bitProcess(<span>Irp</span>)) {<br>/* If this is a 32 bit process */ <br>params32 =   (PIOCTL_PARAMETERS_32)(<span>Irp</span>&gt;<span>AssociatedIrp.SystemBuffer</span>);</span></p>  <p><span>) {</span></p>  <p><span style="font-size: 9pt;"  >status =   STATUS_INVALID_PARAMETER; </span></p>  <p><span style="font-size: 9pt;"  >} else {<br><span>LocalParam.Addr</span> = params32-&gt;<span>Addr</span>;<br><span>LocalParam.Handle</span> =   params32-&gt;Handle; <br><span>LocalParam.Length</span> =   params32-&gt;Length;</span></p>  <p><span style="font-size: 9pt;"  >/* Handle the <span>ioctl</span> here */</span></p>  <p><span style="font-size: 9pt;"  >status =   STATUS_SUCCESS;<br><span>Irp</span>-&gt;<span>IoStatus.Information</span> = <span>sizeof</span>(IOCTL_PARAMETERS);<br>}<br>} else { /* 64bit process   IOCTL */ </span></p>    <p><span style="font-size: 9pt;"  >} else { /* 64bit process IOCTL   */</span></p>  <p><span style="font-size: 9pt;"  ><span>params</span>   = (PIOCTL_PARAMETERS)<br>(<span>Irp</span>-&gt;<span>AssociatedIrp.SystemBuffer</span>);</span></p>  <p><span style="font-size: 9pt;"  >if (<span>irpSp</span>-&gt;<span>Parameters.DeviceIoControl.InputBufferLength</span><br>&lt; <span>sizeof</span>(IOCTL_PARAMETERS)) {<br>status =   STATUS_INVALID_PARAMETER; </span></p>  <p><span style="font-size: 9pt;"  >} else { <br><span>RtlCopyMemory</span>(&amp;<span>LocalParam</span>,   <span>params</span>,<br><span>sizeof</span>(IOCTL_PARAMETERS));</span></p>  <p><span style="font-size: 9pt;"  >/* Handle the <span>ioctl</span> here */<br>status = STATUS_SUCCESS;<br>}<br><span>Irp</span>-&gt;<span>IoStatus.Information</span> =   <span>sizeof</span>(IOCTL_PARAMETERS);<br>}<br>break;</span></p></td></tr></table>    <h3><span>3</span><span>．</span><span>64-Bit INF </span><span>文件要求</span></h3>  <p><span>在</span><span>Windows Server   2003SP1</span><span>之后，</span><span>64</span><span>位驱动的安装被提高了要求。这可以简化用户的操作及提高安全性。</span><span>   </span></p>  <p><span><span>Inf</span></span><span>文件中必须含有</span><span>NTAmd64</span><span>或者</span><span>NTIA64</span><span>之类的修饰符才行。具体做法是在</span><span>[Manufacturer]</span><span>和</span><span>Models</span><span>小节都需要添加此类的字段。</span><span>   </span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 32.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 393.7pt;"  valign="top"  width="525"  >  <p><span style="font-size: 9pt;"  >[Manufacturer]</span></p>  <p><span style="font-size: 9pt;"  >%<span>mycompany</span>% = <span>MyCompanyModels</span></span></p>    <p><span style="font-size: 9pt;"  >[<span>MyCompanyModels</span>]</span></p>  <p><span style="font-size: 9pt;"  >%<span>MyDev</span>% = <span>mydevInstall,mydevHwid</span></span></p></td></tr></table>    <table style="border: medium none; border-collapse: collapse; margin-left: 32.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 393.7pt;"  valign="top"  width="525"  >  <p><span style="font-size: 9pt;"  >[Manufacturer]</span></p>  <p><span>%<span>mycompany</span>% =   MyCompanyModels,NTx86,NTAmd64</span></p>    <p><span style="font-size: 9pt;"  >[MyCompanyModels.NTx86]</span></p>  <p><span style="font-size: 9pt;"  >%<span>MyDev</span>% = mydevInstallx86,mydevHwid</span></p>    <p><span style="font-size: 9pt;"  >[<span>MyCompanyModels</span>. NTAmd64]</span></p>  <p><span style="font-size: 9pt;"  >%<span>MyDev</span>% =   mydevInstallAmd64,mydevHwid</span></p></td></tr></table>  <p><span>如果只需要在</span><span>WindowsX64</span><span>系统上安装，则只需要使用</span><span>NTAmd64</span><span>修饰符就可以了。<span>更多请</span>参考</span></p><p><span style="color: black;"  ><a rel="nofollow" href="http://www.microsoft.com/whdc/driver/install/64INF_reqs.mspx"  >http://www.microsoft.com/whdc/driver/install/64INF_reqs.mspx</a></span><span style="color: black;"  >。</span></p><h3><span>4</span><span>．编程中容易碰到的问题</span></h3>  <h3><span>1</span><span>）指针的相关问题</span></h3>  <p><span>如果原有项目的编程风格控制不严，指针类型混用，强制转换使用过多等等可能对移植是一个巨大的考验。另外，程序中存在结构之中根据具体数据类型来计算其它变量的位置此类的代码也需要重新检查。</span></p>    <p><span>使用指针的原则如下：</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span>1．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>不要将指针强制转换为</span><span><span>int</span></span><span>, long, ULONG,   DWORD</span><span>等类型，而应该使用</span><span>UINT_PTR</span><span>和</span><span>INT_PTR</span><span>；</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span style="color: black;"  >2．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>使用</span><span><span style="color: black;"  >PtrToUlong</span></span><span style="color: black;"  >()</span><span style="color: black;"  >和</span><span><span style="color: black;"  >PtrToLong</span></span><span style="color: black;"  >()</span><span style="color: black;"  >来截断指针；</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span style="color: black;"  >3．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span>永远不要将已经截断的存贮在</span><span><span>int</span></span><span>或者</span><span>ULONG</span><span>中指针地址的重新合成一个新的指针地址；</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span style="color: black;"  >4．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span style="color: black;"  >小心的计算缓冲区的大小，说不定缓冲区的长度比</span><span style="color: black;"  >ULONG</span><span style="color: black;"  >所能存储的最大数都大！</span></p>  <p style="text-indent: -18pt; margin-left: 18pt;"  ><span style="color: black;"  >5．<span style="line-height: normal; font-variant: normal; font-style: normal; font-size: 7pt; font-weight: normal; font-size-adjust: none; font-stretch: normal;"  >   </span></span><span style="color: black;"  >小心的调用那些传出指针的函数；</span></p>    <p><span style="color: black;"  >对</span><span style="color: black;"  >4</span><span style="color: black;"  >可以举个例子：比如说有两个地址</span><span style="color: black;"  >ptr2</span><span style="color: black;"  >（高地址）</span><span style="color: black;"  >, ptr1</span><span style="color: black;"  >（低地址），则</span><span><span style="color: black;"  >len</span></span><span style="color: black;"  > = ptr2 – ptr1 </span><span style="color: black;"  >将有可能大于</span><span style="color: black;"  >2</span><span style="color: black;"  >的</span><span style="color: black;"  >32</span><span style="color: black;"  >次方。</span></p>  <h3><span>2</span><span>）结构的内存排列问题</span></h3>  <p><span>在</span><span>64</span><span>位的操作系统上，结构的内存排列（</span><span>structure   alignment</span><span>）也需要小心审查。内存排列的齐整有利于处理器的执行效率。如果打开了一些编译选项，为了对齐内存地址，编译器可能会将某些位置填空。在移植过程中，对结构中的变量顺序需要仔细检查，特别是在同一个头文件中使用不同的</span><span>pack</span><span>选项。比如下面的代码：</span></p>    <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="font-size: 9pt;"  >#<span>pragma</span> pack (1) /* </span><span style="font-size: 9pt;"  >也可以使用编译选项</span><span style="font-size: 9pt;"  >/<span>Zp</span></span><span style="font-size: 9pt;"  >（结构成员对齐）</span><span style="font-size: 9pt;"  >*/</span></p>  <p><span><span style="font-size: 9pt;"  >struct</span></span><span style="font-size: 9pt;"  > <span>AlignSample</span> {</span></p>  <p><span style="font-size: 9pt;"  >ULONG size;</span></p>  <p><span style="font-size: 9pt;"  >void *<span>ptr</span>; </span></p>  <p><span style="font-size: 9pt;"  >};</span></p>  <p><span><span style="font-size: 9pt;"  >struct</span></span><span style="font-size: 9pt;"  > <span>AlignSample</span> s;</span></p>  <p><span style="font-size: 9pt;"  >void <span>foo</span>(void *p) {</span></p>  <p><span style="font-size: 9pt;"  >*p = p; // </span><span style="font-size: 9pt;"  >将会导致访问异常</span></p>  <p><span style="font-size: 9pt;"  >...</span></p>  <p><span style="font-size: 9pt;"  >}</span></p>  <p><span><span style="font-size: 9pt;"  >foo</span></span><span style="font-size: 9pt;"  >((PVOID)&amp;<span>s.ptr</span>);</span></p></td></tr></table>    <p><span style="color: black; font-size: 12pt;"  >补救办法就是使用宏</span><span style="color: black; font-size: 12pt;"  >UNALIGNED:</span><span style="color: black; font-size: 12pt;"  > </span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="color: black; font-size: 9pt;"  >void <span>foo</span>(void *p) {</span></p>  <p><span style="color: black; font-size: 9pt;"  ><span>struct</span> <span>AlignSample</span> s; </span></p>  <p><span style="color: black; font-size: 9pt;"  >*(UNALIGNED void   *)&amp;<span>s.ptr</span> = p; </span></p>  <p><span style="color: black; font-size: 9pt;"  >}</span></p></td></tr></table>    <p><span style="color: black; font-size: 12pt;"  >当然，更好的办法就是首先将那些</span><span style="color: black; font-size: 12pt;"  >64</span><span style="color: black; font-size: 12pt;"  >位长度的数据类型变量放在结构的前端。</span></p>  <h3><span>3</span><span>）小心使用十六进制的常量，无符号整数</span></h3>  <p><span>小心使用十六进制的常量，无符号整数等等。比如说下面的一些断言在</span><span>64</span><span>位系统中是错误的：</span></p>    <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="color: black; font-size: 9pt;"  >~((UINT64)(PAGE_SIZE-1)) ==   (UINT64)~(PAGE_SIZE-1)</span></p>  <p><span style="color: black; font-size: 9pt;"  >PAGE_SIZE =   0x1000UL // Unsigned Long - 32 bits</span></p>  <p><span style="color: black; font-size: 9pt;"  >PAGE_SIZE - 1 =   0x00000fff </span></p></td></tr></table>    <p><span style="color: black;"  >等式左边</span><span style="color: black;"  >:</span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="color: black;"  >// </span><span style="color: black;"  >无符号转换</span></p>  <p><span style="color: black; font-size: 9pt;"  >(UINT64)(PAGE_SIZE   -1 ) = 0x0000000000000fff</span></p>  <p><span style="color: black; font-size: 9pt;"  >~((UINT64)(PAGE_SIZE -1 ))=   0xfffffffffffff000</span></p></td></tr></table>  <p><span style="color: black;"  >等式右边</span><span style="color: black;"  >:</span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span style="color: black; font-size: 9pt;"  >~(PAGE_SIZE-1) =   0xfffff000<br>(UINT64)(~(PAGE_SIZE-1))=0x00000000fffff000</span></p>  <p><span style="color: black; font-size: 9pt;"  >所以：</span></p>  <p><span style="color: black; font-size: 9pt;"  >~((UINT64)(PAGE_SIZE-1))!=   (UINT64)(~(PAGE_SIZE-1))</span></p></td></tr></table>  <p><span style="color: black;"  >还有：</span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border-left: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt; border-top: 1pt solid windowtext; border-right: 1pt solid windowtext;"  valign="top"  width="537"  >  <p><span style="color: black;"  >DWORD index = 0;</span></p>  <p><span style="color: black;"  >CHAR *p;</span></p>  <p><span style="color: black;"  >If (p[index – 1] == ‘0’)   </span></p></td></tr></table>  <p><span style="color: black;"  >上面的代码将会在</span><span style="color: black;"  >64</span><span style="color: black;"  >位系统上出错！因为在</span><span style="color: black;"  >32</span><span style="color: black;"  >位系统上</span></p>  <p style="text-indent: 42pt;"  ><span><span style="color: black;"  >p[</span></span><span style="color: black;"  >index-1] ==   p[0xffffffff] == p[-1] </span></p>  <p><span style="color: black;"  >这是对的。但在</span><span style="color: black;"  >64</span><span style="color: black;"  >位系统上：</span></p>  <p style="text-indent: 21pt; margin-left: 21pt;"  ><span><span style="color: black;"  >p[</span></span><span style="color: black;"  >index-1] == p[0x00000000ffffffff] != p[-1]</span></p>  <p><span style="color: black;"  >再如：</span></p>  <table style="border: medium none; border-collapse: collapse; margin-left: 23.4pt;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody>  <tr>  <td style="border: 1pt solid windowtext; padding: 0cm 5.4pt; width: 402.7pt;"  valign="top"  width="537"  >  <p><span>-1 != 0xFFFFFFFF</span></p>  <p><span>0xFFFFFFFF != invalid   handle</span></p></td></tr></table>  <p><span>DWORD</span><span>总是</span><span>32</span><span>位</span><span>,</span><span>所以要查找原有程序中所有用</span><span>DWORD</span><span>存贮指针的代码。另外，别忘了使用</span><span style="color: black;"  > %I</span><span style="color: black;"  >来打印指针地址，而且大于</span><span style="color: black;"  >0x80000000</span><span style="color: black;"  >的也未必是内核态地址了。</span></p>  <h3><span>5</span><span>．开发</span><span>64</span><span>位驱动的工具</span></h3>  <p><span style="color: black;"  >64</span><span style="color: black;"  >位的开发工具和</span><span style="color: black;"  >32</span><span style="color: black;"  >位的差不多，除了必须的</span><span style="color: black;"  >Windows DDK   2003</span><span style="color: black;"  >之外，</span><span><span style="color: black;"  >Windbg</span></span><span style="color: black;"  >，</span><span style="color: black;"  >Driver   Verifier</span><span style="color: black;"  >等都是拿手的好工具。最后，下载一份最新的</span><span style="color: black;"  >WHQL</span><span style="color: black;"  >测试包进行</span><span style="color: black;"  >WHQL</span><span style="color: black;"  >测试也是值得推荐的。</span></p>  <p><span style="color: black;"  >目前，学会使用</span><span><span style="color: black;"  >Windbg</span></span><span style="color: black;"  >来调试</span><span style="color: black;"  >64</span><span style="color: black;"  >位用户态和核心<span>态程序</span>的方法是尤为必要的。也可以购买支持</span><span style="color: black;"  >64</span><span style="color: black;"  >位的</span><span style="color: black;"  >VC</span><span style="color: black;"  >环境</span><span style="color: black;"  >Visual <span>Stdio</span> 2005</span><span style="color: black;"  >来进行</span><span style="color: black;"  >64</span><span style="color: black;"  >位程序开发。</span></p>  <h2><span>参考资料</span></h2>  <p><span>Windows XP Professional x64 Edition   </span><span>概述</span><span><a rel="nofollow" href="http://www.microsoft.com/china/windowsxp/64bit/evaluation/overviews/overview.mspx"  >http://www.microsoft.com/china/windowsxp/64bit/evaluation/overviews/overview.mspx</a></span></p>    <p><span>AMD64</span><span>计算平台</span><span>-</span><span>带您进入计算的未来白皮书</span><span><a rel="nofollow" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/kmarch/hh/kmarch/Other_f910e5d8-a732-4faa-a8d2-d4de021dc78d.xml.asp"  >http://msdn.microsoft.com/library/default.asp?url=/library/en-us/kmarch/hh/kmarch/Other_f910e5d8-a732-4faa-a8d2-d4de021dc78d.xml.asp</a></span><span>   </span></p>  <p><span style="color: black;"  >64-bit DDK</span><span style="color: black;"  >编程指导<br></span><span><a rel="nofollow" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/kmarch/hh/kmarch/Other_f910e5d8-a732-4faa-a8d2-d4de021dc78d.xml.asp"  >http://msdn.microsoft.com/library/default.asp?url=/library/en-us/kmarch/hh/kmarch/Other_f910e5d8-a732-4faa-a8d2-d4de021dc78d.xml.asp</a></span></p>  <p><span style="color: black;"  >硬件测试资料</span><span style="color: black;"  > <br></span><span style="color: black;"  ><a rel="nofollow" href="http://www.microsoft.com/whdc/system/platform/64bit/default.mspx"  >http://www.microsoft.com/whdc/system/platform/64bit/default.mspx</a></span></p><p><span><br></span></p>
</body></html>