<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Containers</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Containers</h2>
<p align="right">发布时间：2011-5-31 11:35
<br>分类名称：STL</p><br>
<p><span style="font-size:14pt;"><strong>[vector] </strong></span></p><p><span style="font-size:14pt;"><strong>性能： </strong></span></p><p>末端插入删除效率高，中间效率低。 </p><p><span style="font-size:14pt;"><strong>要求： </strong></span></p><p>assignable &amp;&amp; copyable </p><p><span style="font-size:14pt;"><strong>注意： </strong></span></p><ol><li><div style="text-align: justify;">一旦内存重新分配，所有的reference，pointers，iterators都将失效。 </div><p>保留内存的方法： </p><ol><li><div style="text-align: justify;">使用reverse()函数。（注意，reverse出来的内存，不能直接引用） </div></li><li><div style="text-align: justify;">初始化的时候，分配足够的空间 </div></li></ol></li><li><div style="text-align: justify;">vector使用reverse()不能缩减内存容量。所以，即便删除元素，不会导致内存重新分配，其reference，pointers，iterators都将继续有效。到如果是insert操作，可能会导致内存重新分配，从而导致reference，pointers，iterators失效。 </div></li><li><div style="text-align: justify;">缩减vector容量的办法，使用swap()函数。（vector&lt;T&gt;(v).swap(v);） </div></li><li><div style="text-align: justify;">将vector作为一般Arrary是来使用（而且是个动态数组）。C++标准规格书将确保vector中的元素都是连续分布的。将vector作为数组操作时（&amp;v[0]），要注意分配足够大的内存，不然会发生越界访问。 </div></li></ol><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>混淆： </strong></span></p><p><span style="font-size:14pt;"><strong>size(), max_size(), capacity() </strong></span></p><p>例子代码： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt; nTest(10, 0); </p><p>&nbsp;&nbsp;&nbsp;&nbsp;nTest.reserve(20); </p><p> &nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "size() " &lt;&lt; nTest.size() &lt;&lt; endl; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "max_size() " &lt;&lt; nTest.max_size() &lt;&lt; endl; </p><p>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "capacity() " &lt;&lt; nTest.capacity() &lt;&lt; endl; </p><p>输出 </p><p style="margin-left: 22pt;">size() 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（当前实际存储的元素数量） </p><p style="margin-left: 22pt;">max_size() 1073741823&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（vector能存储的最大元素数量） </p><p style="margin-left: 22pt;">capacity() 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（vector在重新分配空间之前，能容纳的最大数量） </p><p style="margin-left: 22pt;"> &nbsp;</p><p><span style="font-size:14pt;"><strong>reverse(), resize() </strong></span></p><p><strong>错误代码： </strong></p><p><span style="font-family:宋体; font-size:12pt;">vector&lt;char&gt; myVec;  </span></p><p><span style="font-family:宋体; font-size:12pt;">myVec.reserve(100); </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">char szTest[] = "how do you do"; </span></p><p><span style="font-family:宋体; font-size:12pt;">memcpy(&amp;myVec[0], szTest, sizeof(szTest)); </span></p><p><span style="font-family:宋体; font-size:12pt;">编译没有问题，运行的时候，可能你的运气比较好，不会崩溃；可能你的运气差，一运行就崩溃了。 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"><strong>原因： </strong></span></p><p><span style="font-family:宋体; font-size:12pt;">vector 的reverse只是增加了vector的capacity，但是size没有改变！ resize同时改变了vector的capacity和size！ </span></p><p><span style="font-family:宋体; font-size:12pt;">reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。 </span></p><p><span style="font-family:宋体; font-size:12pt;">resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。 </span></p><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>[Deque] </strong></span></p><p><span style="font-size:14pt;"><strong>性能： </strong></span></p><p>两端插入删除效率高，中间效率低。 </p><p><span style="font-size:14pt;"><strong>要求： </strong></span></p><p>assignable &amp;&amp; copyable </p><p><span style="font-size:14pt;"><strong>注意： </strong></span></p><ol><li><div style="text-align: justify;">存取元素时，deque内部多了一个间接过程，速度比vector稍微慢点。 </div></li><li><div style="text-align: justify;">不只一块内存，其max_size可能更大。 </div></li><li><div style="text-align: justify;">不支持对容量和内存重新分配时机的控制。除了头尾，在其他任何地方安插和删除元素，将导致reference，pointers，iterators都失效。deque重新分配由于vector，因为重新分配后，无需复制其中的元素。 </div></li><li><div style="text-align: justify;">内存可以缩减。（标准不保证） </div></li></ol><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>区别（vector）： </strong></span></p><p>deque不提供capacity和reserve支持。 </p><p>deque多了push_front和pop_front支持。 </p><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>[List] </strong></span></p><p><span style="font-size:14pt;"><strong>性能： </strong></span></p><p>不支持随机存取（所以不知道at(), []），在list遍历元素很缓慢。在任何位置安插和移除的速度都很快。 </p><p><span style="font-size:14pt;"><strong>要求： </strong></span></p><p>assignable &amp;&amp; copyable </p><p><span style="font-size:14pt;"><strong>注意： </strong></span></p><ol><li><div style="text-align: justify;">安插和移除操作不会使得reference，pointers，iterator失效。 </div></li><li><div style="text-align: justify;">lists对异常处理方式，要么操作成功，要么什么都不发生，不会"只成功一半"。 </div></li><li><div style="text-align: justify;">lists不提供容量，空间重新分配，没有必要，每个元素拥有独立的内存，删除之前一直有效。 </div></li><li><div style="text-align: justify;">lists提供不少特殊成员函数，比使用通用的算法函数效率更高。 </div></li><li><div style="text-align: justify;">back和front函数，不检测容器是否为空，所以需要手动检测。（所有的容器都不检测） </div></li></ol><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>[Sets &amp; Multisets] </strong></span></p><p><span style="font-size:14pt;"><strong>性能：</strong></span>更具特定的排序准则，自动将元素排序。（Multisets运行重复排序）。内部建立二叉树，使得搜索性能很高。<span style="font-size:14pt;"><strong>    </strong></span></p><p><span style="font-size:14pt;"><strong>要求： </strong></span></p><p>assignable &amp;&amp; copyable &amp;&amp; comparable </p><p><span style="font-size:14pt;"><strong>注意： </strong></span></p><ol><li><div style="text-align: justify;">排序准则： </div><ol><li><div style="text-align: justify;">反对称（antisymmetric） </div></li></ol></li></ol><p>if <strong>x &lt; y</strong> is <strong>true</strong>, then<strong> y &lt; x</strong> is <strong>false</strong>. </p><ol style="margin-left: 38pt;"><li><div style="text-align: justify;">可传递 </div></li></ol><p>if <strong>x &lt; y</strong> is <strong>true</strong> and <strong>y &lt; z</strong> is <strong>true , </strong>then <strong>x &lt; z</strong> is <strong>true.</strong>  </p><ol style="margin-left: 38pt;"><li><div style="text-align: justify;">非自反 </div><p>x &lt; x is false forever. </p></li></ol><ol><li><div style="text-align: justify;">其内部通常以平衡二叉树（或者红黑树）构建的。 </div></li><li><div style="text-align: justify;">一个重要限制：由于是自动排序，所以不能直接更改元素内部的值。改变元素的值，需要先删除之，在插入之。 </div></li><li><div style="text-align: justify;">迭代器的角度看，元素是常数。 </div></li><li><div style="text-align: justify;">元素的比较只能用在相同的类型中。（元素和排序准则必须有相同的型别） </div></li><li><div style="text-align: justify;">由于Sets和multisets优化了元素搜索速度，所以使用其成员函数来搜索。 </div></li><li><div style="text-align: justify;">sets insert(单参数)会返回一个pair&lt;iterator, bool&gt;值。 </div></li><li><div style="text-align: justify;">asdf </div></li></ol><p> &nbsp;</p><p><span style="font-size:14pt;"><strong>[Maps &amp; Multimaps] </strong></span></p><p><span style="font-size:14pt;"><strong>性能：</strong></span>和Sets multisets一样，只不过maps中的元素成了一个pair，而不是一个value。<span style="font-size:14pt;"><strong>    </strong></span></p><p><span style="font-size:14pt;"><strong>要求： </strong></span></p><p>value&nbsp;&nbsp;&nbsp;&nbsp;：assignable &amp;&amp;copyable  </p><p>key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：comparable</p>
</body></html>