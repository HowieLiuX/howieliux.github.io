<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Completion Routines</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Completion Routines</h2>
<p align="right">发布时间：2014-5-15 20:35
<br>分类名称：Driver</p><br>
<p><span style="font-family:宋体;"   >VOID <strong>IoSetCompletionRoutine</strong>(<br>  _In_      PIRP Irp,<br>  _In_opt_  PIO_COMPLETION_ROUTINE CompletionRoutine,<br>  _In_opt_  PVOID Context,<br>  _In_      BOOLEAN InvokeOnSuccess,<br>  _In_      BOOLEAN InvokeOnError,<br>  _In_      BOOLEAN InvokeOnCancel<br>);<br><br>#define <strong>IoSetCompletionRoutine</strong>( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \<br>    PIO_STACK_LOCATION __irpSp;                                               \<br>    ASSERT( ((Success) | (Error) | (Cancel)) ? (Routine) != NULL : TRUE );    \<br>    __irpSp = IoGetNextIrpStackLocation( (Irp) );                             \<br>    __irpSp-&gt;CompletionRoutine = (Routine);                                   \<br>    __irpSp-&gt;Context = (CompletionContext);                                   \<br>    __irpSp-&gt;Control = 0;                                                     \<br>    if ((Success)) { __irpSp-&gt;Control = SL_INVOKE_ON_SUCCESS; }               \<br>    if ((Error)) { __irpSp-&gt;Control |= SL_INVOKE_ON_ERROR; }                  \<br>if ((Cancel)) { __irpSp-&gt;Control |= SL_INVOKE_ON_CANCEL; } }<br>
</span></p><p><span style="font-family:宋体;"   >NTSTATUS <strong>CompletionRoutine</strong>(PDEVICE_OBJECT fdo, PIRP Irp, PVOID context)<br>{<br>    return &lt;some status code&gt;;<br>}
</span></p><p><span style="font-family:宋体;"   ><strong>IoSetCompletionRoutine</strong> installs the completion routine address and context argument <strong>in the next IO_STACK_LOCATION</strong> — that is, in the stack location in which the <strong>next lower driver will find its parameters</strong>. Consequently, the <strong>lowest-level driver</strong> in a particular stack of drivers doesn't dare attempt to install a completion routine. Doing so would be pretty futile, of course, because—by definition of lowest-level driver—there's no driver left to pass the request on to.
</span></p><p><span style="font-family:宋体;"   ><strong>CompletionRoutine</strong> receives pointers to the <strong>device object and the IRP</strong>, and it also receives whichever <strong>context value</strong> you specified in the call to IoSetCompletionRoutine. <strong>Completion routines can be called at DISPATCH_LEVEL in an arbitrary thread context but can also be called at PASSIVE_LEVEL or APC_LEVEL.</strong> To accommodate the worst case (DISPATCH_LEVEL), completion routines therefore need to be <strong>in nonpaged memory</strong> and must call only service functions that are callable at or below DISPATCH_LEVEL. To accommodate the possibility of being called at a lower IRQL, however, a completion routine shouldn't call functions such as KeAcquireSpinLockAtDpcLevel that assume they're at DISPATCH_LEVEL to start with.
</span></p><p><span style="font-family:宋体;"   >There are really just two possible return values from a completion routine:
</span></p><ol><li><span style="font-family:宋体;"   ><strong>STATUS_MORE_PROCESSING_REQUIRED, which aborts the completion process immediately.</strong> The spelling of this status code obscures its actual purpose, which is to short-circuit the completion of an IRP. Sometimes, a driver actually does some additional processing on the same IRP. Other times, the flag just means, "Yo, IoCompleteRequest! Like, don't touch this IRP no more, dude!" Future versions of the DDK will therefore define an enumeration constant, StopCompletion, that is numerically the same as STATUS_MORE_PROCESSING_REQUIRED but more evocatively named. (Future printings of this book may also employ better grammar in describing the meaning to be ascribed the constant, at least if my editors get their way.)
</span></li><li><span style="font-family:宋体;"   >Anything else, which allows the completion process to continue. <strong>Because any value besides STATUS_MORE_PROCESSING_REQUIRED has the same meaning as any other, I usually just code STATUS_SUCCESS.</strong> Future versions of the DDK will define <strong>STATUS_CONTINUE_COMPLETION</strong> and an enumeration constant, Con?tinueCompletion, that are numerically the <strong>same as STATUS_SUCCESS</strong>.
</span></li></ol><p><span style="font-family:宋体;"   ><strong>IoCompleteRequest</strong> is responsible for<strong> calling all of the completion routines </strong>that drivers installed in their respective stack locations. The way the process works, as shown in the flowchart in the following figure.
</span></p><p><img title="Completion Routines - Howie - Dspace"   src="pic/img2.ph.126.net_RDf5q1XHQ2NIiDBP2bdG8g==_6608237506260189188.jpg"   alt=""   /><span style="font-family:宋体;"   >
</span></p><p><span style="font-family:宋体;"   >注释：此流程可以参考<strong>IoCompleteRequest</strong>的代码实现，在我的其它文章中有。
</span></p><p><span style="font-family:宋体;"   >Within a completion routine, a call to <strong>IoGetCurrentIrpStackLocation</strong> will retrieve the same stack pointer that was current when somebody called IoSetCompletionRoutine.（<strong>IoCompleteRequest</strong>在调用完成函数时，已经将IRP的CurrentStackLocation等成员加了一） <strong>You shouldn't rely in a completion routine on the contents of any lower stack location.</strong> To reinforce this rule, IoCompleteRequest zeroes most of the next location just before calling a completion routine.
</span></p><p>
&nbsp;</p><p><span style="font-family:宋体; font-size:14pt;"   ><strong>IoMarkIrpPending
</strong></span></p><p>为何调用此函数（宏）？
</p><p>为何又要在完成函数中加入如下代码？
</p><p><span style="font-family:宋体;"   >if (Irp-&gt;PendingReturned) IoMarkIrpPending(Irp);
</span></p><p>如果你能看懂<span style="font-family:宋体;"   ><strong>IoCompleteRequest</strong>实现代码，这些问题都能找到答案。
</span></p><p><span style="font-family:宋体;"   >以下从示例中说明：
</span></p><p><span style="font-family:宋体;"   >KEVENT event;<br>IO_STATUS_BLOCK iosb;<br>KeInitializeEvent(&amp;event, ...);<br>PIRP Irp = IoBuildDeviceIoControlRequest(..., &amp;event, &amp;iosb);  // 构造一个同步IRP，IoBuildSynchronousFsdRequest也适用。<br>NTSTATUS status = IoCallDriver(SomeDeviceObject, Irp);<br>if (status == STATUS_PENDING)  // 如果调用完，返回的是STATUS_PENDING，说明处理还未完成，需要继续等待。<br>  {<br>  KeWaitForSingleObject(&amp;event, ...);  // 等待异步完成，完成后，event会被激活，继续往下执行。<br>  status = iosb.Status;<br>  }<br>else<br>  &lt;cleanup IRP&gt;<br>
</span></p><p><span style="font-family:宋体;"   >Call的这个Device的最上层派遣函数如果是：
</span></p><p><span style="font-family:宋体;"   >NTSTATUS TopDriverDispatchSomething(PDEVICE_OBJECT fdo, PIRP Irp)<br>{<br>  IoMarkIrpPending(Irp);<br>  // do something, deliver IRP somewhere, and complete it later.<br>  return STATUS_PENDING;<br>}
</span></p><p><span style="font-family:宋体;"   >这种情况将正常工作，示例中，调用IoCallDriver后，直接进入TopDriverDispatchSomething，它将IRP加入处理队列后，返回STATUS_PENDING，表示IRP还未完成。IoCallDriver的返回值将是派遣函数的返回值，发现是STATUS_PENDING，调用KeWaitForSingleObject等待完成。
</span></p><p><span style="font-family:宋体;"   ><strong>事件何时被激活？</strong><br><strong>IoCompleteRequest</strong> does this signaling indirectly by <strong>scheduling an APC</strong> to the same routine that performs the &lt;cleanup IRP&gt; step in the preceding pseudocode. That cleanup code will do many tasks, including calling <strong>IoFreeIrp</strong> to release the IRP and <strong>KeSetEvent</strong> to set the event on which the creator might be waiting. For some types of IRP, IoCompleteRequest will always schedule the APC. For other types of IRP, though, <strong>IoCompleteRequest will schedule the APC only if the SL_PENDING_RETURNED flag is set in the topmost stack location. </strong>
</span></p><p><span style="font-family:宋体;"   >IoCompleteRequest发现IRP对应的最高层IO堆栈的flag中有<strong>SL_PENDING_RETURNED</strong>,将会schedule APC，APC中，将会激活Evnet。
</span></p><p><span style="font-family:宋体;"   ><strong>IoMarkIrpPending </strong>is a macro whose only purpose is to <strong>set SL_PENDING_RETURNED in the current stack location.
</strong></span></p><p style="margin-left: 22pt;"   ><span style="font-family:宋体;"   >#define IoMarkIrpPending( Irp ) ( \<br>IoGetCurrentIrpStackLocation( (Irp) )-&gt;Control |= SL_PENDING_RETURNED )
</span></p><p><span style="font-family:宋体;"   >此示例中，设置的SL_PENDING_RETURNED只是本层，而且本层是最高层，所以没有问题。
</span></p><p>
&nbsp;</p><p><span style="font-family:宋体;"   >Call的这个Device的不止一层，如果是：
</span></p><p><span style="font-family:宋体;"   >NTSTATUS <strong>TopDriverDispatchSomething</strong>(PDEVICE_OBJECT fido,PIRP Irp)<br>{<br>  PDEVICE_EXTENSION pdx =<br>    (PDEVICE_EXTENSION) fido-&gt;DeviceExtension;<br>  IoCopyCurrentIrpStackLocationToNext(Irp);<br>  return IoCallDriver(pdx-&gt;LowerDeviceObject, Irp);<br>  }<br><br>NTSTATUS <strong>SecondDriverDispatchSomething</strong>(PDEVICE_OBJECT fdo,PIRP Irp)<br>{<br>  IoMarkIrpPending(Irp);<br>  … …<br>  return STATUS_PENDING;<br>}
</span></p><p><span style="font-family:宋体;"   >设置的SL_PENDING_RETURNED只是本层（<strong>SecondDriverDispatchSomething</strong>），上层（<strong>TopDriverDispatchSomething</strong>）并没有此标志，需要不停传递到最上层。如果没有安装完成函数，这种传递在IoCompleteRequest中自动进行。如果安装了完成函数，则需要在完成函数中调用if (Irp-&gt;PendingReturned) IoMarkIrpPending(Irp); 来辅助向上传递（不知道微软为何要这么搞，估计是增加灵活性吧）。为何判断的是Irp-&gt;PendingReturned？因为IoCompleteRequest，每次完成函数前会先设置此标识：Irp-&gt;PendingReturned = stackPointer-&gt;Control &amp; SL_PENDING_RETURNED; 来保存堆栈内到底有无SL_PENDING_RETURNED标志。
</span></p><p><span style="font-family:宋体;"   >现在，如果将<strong>IoCopyCurrentIrpStackLocationToNext</strong>替换为<strong>IoSkipCurrentIrpStackLocation</strong>，仍然能够正常工作，因为<strong>IoMarkIrpPending</strong>设置的是<strong>TopDriverDispatchSomething这层的堆栈，如果下面还有跟多层呢？也一样。只要有一层被设置为，则会从此层开始，层层传递。
</strong></span></p><p>
&nbsp;</p><p><span style="font-family:宋体;"   >Call的这个Device安装了完成函数，如果是：
</span></p><p><span style="font-family:宋体;"   >NTSTATUS <strong>TopDriverDispatchSomething</strong>(PDEVICE_OBJECT fido,PIRP Irp)<br>{<br>  PDEVICE_EXTENSION pdx =<br>    (PDEVICE_EXTENSION) fido-&gt;DeviceExtension;<br>  IoCopyCurrentIrpStackLocationToNext(Irp);<br>  IoSetCompletionRoutine(Irp, TopDriverCompletionRoutine, ...);<br>  return IoCallDriver(pdx-&gt;LowerDeviceObject, Irp);<br>  }<br><br>NTSTATUS <strong>SecondDriverDispatchSomething</strong>(PDEVICE_OBJECT fdo,PIRP Irp)<br>{<br>  IoMarkIrpPending(Irp);<br>  … … <br>  return STATUS_PENDING;<br>}
</span></p><p><span style="font-family:宋体;"   >NTSTATUS TopDriverCompletionRoutine(PDEVICE_OBJECT fido,PIRP Irp, ...)<br>{<br>  if (Irp-&gt;PendingReturned) // 向上传递<br>    IoMarkIrpPending(Irp);<br>
<br>return STATUS_SUCCESS;<br>}<br>如果完成函数不调用IoMarkIrpPending，标识将不会传递到最上层。IoCompleteRequest最终不会schedule APC，event无法触发。
</span></p><p>
&nbsp;</p><p><span style="font-family:宋体;"   >调用IoMarkIrpPending错误的情况：
</span></p><p><span style="font-family:宋体;"   ><strong><span style="color:black; font-size:13pt;"   >Bad Idea # 1—Conditionally Call <em>IoMarkIrpPending</em> in the Dispatch Routine</span>
</strong></span></p><p><span style="font-family:宋体; font-size:12pt;"   >NTSTATUS TopDriverDispatchSomething(PDEVICE_OBJECT fido,PIRP Irp)<br>{<br>  PDEVICE_EXTENSION pdx =<br>    (PDEVICE_EXTENSION) fido-&gt;DeviceExtension;<br>  IoCopyCurrentIrpStackLocationToNext(Irp);<br>  IoSetCompletionRoutine(Irp, TopDriverCompletionRoutine, ...);<br>  NTSTATUS status = IoCallDriver(pdx-&gt;LowerDeviceObject, Irp);<br>  if (status == STATUS_PENDING)<br>    IoMarkIrpPending(Irp); // &lt;== Argh! Don't do this!<br>  return status;<br>}<br>The reason this is a bad idea is that the IRP might already be complete, and someone might already have called <strong><em>IoFreeIrp</em></strong>, <strong>by the time <em>IoCallDriver</em> returns</strong>. You must treat the pointer as poison as soon as you give it away to a function that might complete the IRP.
</span></p><p><span style="color:black; font-family:宋体; font-size:13pt;"   ><strong>Bad idea # 2—Always Call <em>IoMarkIrpPending</em> in the Dispatch Routine
</strong></span></p><p><span style="font-family:宋体; font-size:12pt;"   >Here the dispatch routine <strong>unconditionally calls <em>IoMarkIrpPending</em></strong> and then returns <strong>whichever value <em>IoCallDriver</em> returns</strong>:
</span></p><p><span style="font-family:宋体; font-size:12pt;"   >NTSTATUS TopDriverDispatchSomething(PDEVICE_OBJECT fido,PIRP Irp)<br>{<br>  PDEVICE_EXTENSION pdx =<br>    (PDEVICE_EXTENSION) fido-&gt;DeviceExtension;<br>  IoMarkIrpPending(Irp); // &lt;== Don't do this either!<br>  IoCopyCurrentIrpStackLocationToNext(Irp);<br>  IoSetCompletionRoutine(Irp, TopDriverCompletionRoutine, ...);<br>  return IoCallDriver(pdx-&gt;LowerDeviceObject, Irp);<br>}
</span></p><p><span style="font-family:宋体; font-size:12pt;"   >This is a bad idea if the next driver happens to complete the IRP in its dispatch routine and returns a nonpending status. In this situation, <em>IoCompleteRequest</em> will cause all the completion cleanup to happen. When you return a nonpending status, the I/O Manager routine that originated the IRP <strong>might</strong> call the same completion cleanup routine a second time. This leads to a double-completion bug check.
</span></p><p><span style="font-family:宋体; font-size:12pt;"   >Remember always to pair the call to <em>IoMarkIrpPending</em> with returning <em>STATUS_PENDING</em>. That is,<strong> do both or neither, but never one without the other.</strong>
</span></p><p><span style="font-family:宋体;"   ><strong><span style="color:black; font-size:13pt;"   >Bad Idea # 3—Call <em>IoMarkPending</em> Regardless of the Return Code from the Completion Routine</span>
</strong></span></p><p><span style="font-family:宋体;"   >NTSTATUS TopDriverDispatchSomething(PDEVICE_OBJECT fido,PIRP Irp)<br>{<br>  PDEVICE_EXTENSION pdx =<br>    (PDEVICE_EXTENSION) fido-&gt;DeviceExtension;<br>  KEVENT event;<br>  KeInitializeEvent(&amp;event, NotificationEvent, FALSE);<br>  IoCopyCurrentIrpStackLocationToNext(Irp);<br>  IoSetCompletionRoutine(Irp, TopDriverCompletionRoutine, &amp;event,<br>    TRUE, TRUE, TRUE);<br>  IoCallDriver(pdx-&gt;LowerDeviceObject, Irp);<br>  KeWaitForSingleObject(&amp;event, ...);<br><br>  Irp-&gt;IoStatus.Status = status;<br>  IoCompleteRequest(Irp, IO_NO_INCREMENT);<br>  return status;<br>}<br><br>NTSTATUS TopDriverCompletionRoutine(PDEVICE_OBJECT fido,PIRP Irp, PVOID pev)<br>{<br>  if (Irp-&gt;PendingReturned)<br>
<strong>IoMarkIrpPending(Irp)</strong>; // &lt;== oops<br>  KeSetEvent((PKEVENT) pev, IO_NO_INCREMENT, FALSE);<br>  return <strong>STATUS_MORE_PROCESSING_REQUIRED</strong>;<br>}<br>What's probably going on here is that the programmer wants to forward the IRP synchronously and then resume processing the IRP after the lower driver finishes with it. (See IRP-handling scenario 7 at the end of this chapter.) That's how you're supposed to handle certain PnP IRPs, in fact. <strong>This example can cause a double-completion bug check, though, if the lower driver happens to return STATUS_PENDING. This is actually the same scenario as in the previous bad idea: your dispatch routine is returning a nonpending status, but your stack frame has the pending flag set.</strong> People often get away with this bad idea, which existed in the IRP_MJ_PNP handlers of many early Windows 2000 DDK samples, because no one ever posts a Plug and Play IRP. (Therefore, PendingReturned is never set, and the incorrect call to IoMarkIrpPending never happens.)
</span></p><p><span style="font-family:宋体;"   >Avoid these problems by remembering <strong>not to call IoMarkIrpPending from a completion routine that returns STATUS_MORE_PRO?CESSING_REQUIRED</strong>.
</span></p>
</body></html>