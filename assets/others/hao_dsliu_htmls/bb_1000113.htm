<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] Debug Tutorial Part 2: The Stack</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] Debug Tutorial Part 2: The Stack</h2>
<p align="right">发布时间：2012-9-25 17:58
<br>分类名称：Debug_Crack</p><br>
<p><span style="color:#ff9900; font-family:Segoe UI; font-size:15pt;"  ><strong>Introduction </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Welcome to the second installment of these debugging tutorials. In this article, I will investigate the stack and how it plays an integral part in debugging. Anytime you ask the question "What do you do when your program traps?", the most common answer is "Get a stack trace". This is definitely true, it's probably the very first thing you should do anytime you investigate a crash dump. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Sorry if this tutorial is too general and beginner-ish! I should probably set the level as beginner instead of intermediate. I only set it as intermediate since the article is requiring assembly knowledge. </span></p><p><span style="color:#ff9900; font-family:Segoe UI; font-size:15pt;"  ><strong>What is the Stack? </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is the first and most obvious question. Unfortunately, I did not cover or really answer this in the first tutorial as I was taking for granted that everyone was familiar with it. In order to explain what the stack is, let me start from where we begin, what a process is. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >What is a Process? </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >A process is basically an instance of an application in memory. The executable and supported libraries are mapped into this address space. A process does not execute, but just rather defines the memory boundaries, resources, and the like which are accessible from anyone operating within that process. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >What is a Thread? </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >A thread is an instance of execution that operates within the boundaries of a process. A process is not scheduled to execute, the threads within a process are. There may be many threads executing in the context of one process. Although a thread may have "thread specific storage", generally all memory and resources created in the context of the process can be used by any executing thread. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >Global and Local Resources </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Not to be confusing here, but there are exceptions. There are resources that are created globally rather than locally. That means these resources may be used outside the context of the process in which they were created. One such example is a window handle. These resources have their own boundaries outside of a process. Some resources may be system wide, others desktop or session wide. There are also "shared" resources where processes can negotiate sharing of a resource through other means and mechanisms. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >What is Virtual Memory? </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >In general, "Virtual Memory" is generally thought of as fooling the system into thinking there's more physical memory than there really is. This is true and false at the same time. It depends on who "the system" is and there's really more to it than that. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The system is not being fooled into thinking there's more memory than there really is. The hardware already knows there's less memory and is actually the one who implements the necessary mechanisms to support "Virtual Memory". The Operating System is the one which utilizes these capabilities to perform "Virtual Memory", so it is also not being fooled. So, who is being fooled? If anyone is being fooled, it's the processes running on the system. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >I don't believe that to be the case either. The application programmer generally knows the system he is programming for already. That means, he knows the Operating System uses "Virtual Memory" or not such as DOS and he programs for that platform. In general, it doesn't mean anything. A simple application really doesn't care as long as it gets to execute. The only time you really run into trouble would be a "cooperative multitasking" system verses a "preemptive multitasking" system. But, then again, the programmer knows his target platform and programs appropriately. The differences with those two types of Operating Systems is beyond the scope of this article and does not apply. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >So, back to answering this question. The first thing that "Virtual Memory" does is that it abstracts the physical address space of the machine. This means the application programs do not see or know about the physical address. They know a "Virtual" address. The CPU is then capable of converting a "Virtual" address to a "Physical" address based on certain characteristics setup by the Operating System. The details of that mechanism is beyond the scope of this document. Just understand that the application receives a "Virtual" address and the processor maps it to a physical address. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The next part of the equation is that the "Virtual" address does not need to point to a "Physical" address. The Operating System can use a swap file to keep memory on disk, that way, the entire program does not have to be in physical memory at the same time. This allows many programs to be in memory and execute. If a program attempts to access a memory location that is not in physical memory, the CPU knows this. The CPU will page fault and know that the memory that is being accessed is out on disk. The Operating System will then get told and will pull that memory from disk to Physical memory. Once this is complete, the program is given back execution and will continue where it left off. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >There are many algorithms to decide how to pull memory in from disk. Unless you plan to grow the footprint of a process in Physical memory, you usually swap a page out to swap one in. There are many algorithms that the OS can use to grow the process physical foot print and swap pages in and out. A simple one is basically, the least frequently used page in memory. You generally want to avoid writing programs that keep crossing page boundaries frequently, this will eliminate "thrashing" which is swapping in and out pages from memory to disk often. These topics are outside the scope of this tutorial. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The next advantage of "Virtual Memory" is protection. A process cannot directly access another process's memory. That means that at anyone time, the CPU has only the Virtual address mappings for that process. That means, it can't resolve a virtual address in another process. This makes sense because since they are separate mappings, the processes could and will have the same memory address pointed to different locations! </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >That doesn't mean it's impossible to read another process' memory. If the Operating System has built-in support, such as Windows does, you can access another process' memory. You could also do this if you could gain access to memory locations, and manipulate the CPU registers as they relate to Virtual Memory mapping. Luckily, you can't, as the CPU can check your privilege level before you attempt to execute sensitive assembly instructions, and "Virtual Memory" will keep you away from being a usermode process and manipulating page or descriptor tables (Although, there is a method in Windows 9x to get the LDT in usermode). </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >What is the stack? </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Now that I've described the basics of the system, I can get back to "What is a stack?". In general, a stack is a general-purpose data structure that allows items to be pushed onto it and popped off. Think of it as a stack of plates. You can put items on the top and you can only take items off the top (without cheating). If you followed that strict rule, you have a stack. A stack is generally referred to as "LIFO" or "Last In First Off". </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Programs generally use the stack as a means of temporary storage. This is generally unknown to the non-assembly programmer as the language hides these details. However, the generated code produced by your program will use a stack and the CPU has built-in stack support! </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >On Intel, the assembly instructions to put something on the stack and take something off are </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >PUSH</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > and </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >POP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. Note that some processors use </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >PUSH</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >/</span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >PULL</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, but in the Intel world, we use </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >PUSH</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >/</span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >POP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. This is just a "mnemonic" anyway, which basically means an English word for a machine operation. All assembly boils down to an opcode or number which is processed by the CPU. That means, you can call the instruction anything you want in English as long as you use it correctly and generate the correct "opcode". </span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Getting back on track, every "thread" executing in a process has its <strong>own</strong> stack. This is because we can't have multiple threads attempting to use the same temporary storage location as we will see in a moment. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>How is a function call made? </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The function call depends on the "calling convention". The "calling convention" is a basic method that the caller (the function making the call) and callee (the function being called) have agreed on in order to pass parameters to the function and clean up the parameters afterwards. In Windows, we generally support three different calling conventions. These are "this call", "standard call" and "CDECL or C Calling convention". </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>This Call </strong></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >This is a C++ calling convention. If you're familiar with C++ internals, member functions of an object require the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >this</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > pointer to be passed into the function. In general, the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >this</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > pointer is the first parameter on the stack. This is not the case with "this call". In "this call", the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >this</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > pointer is in a register, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ECX</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > to be exact. The parameters are pushed on the stack in reverse order and the callee cleans up the stack. </span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Standard Call </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >"Standard Call" is when the parameters are pushed backwards on to the stack and the callee cleans up the stack. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>CDECL or C Calling Convention </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >"C Calling" convention basically means that the parameters are pushed backwards onto the stack and the caller cleans up the stack. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Pascal Calling Convention </strong></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >If you've seen old programs, you will see "PASCAL" as their calling convention. In WIN32, you actually are not allowed to use </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >__pascal</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > anymore. The </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >PASCAL</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > macro has actually been redefined as "Standard Call". However, Pascal calling convention parameters are pushed <strong>forward</strong> onto the stack. The callee cleans up the stack. </span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Cleans up the stack? </strong></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The difference in who cleans up the stack is a big deal. The first is saving bytes. If the callee cleans up the stack, that means there doesn't have to be extra instructions generated at every function call to clean up the stack. The disadvantage to this is that you cannot use variable arguments. Variable arguments are used by functions like </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. The actual callee does not <em>REALLY</em> know how many arguments are pushed onto the stack. It can only <em>GUESS</em> by the information provided to it, in say, its format string. If you tell </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf "%i %i %i"</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, it will attempt to use 3 more values on the stack to fill those, whether or not you pushed them or not! This may or may not trap. If you push more parameters than you tell </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, there's no problem since the caller is cleaning up the stack anyway. They're just there for no reason, but </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > does not know they're there. Remember that, variable argument functions do not magically know how many parameters are there, they must implement some method for the caller to tell them through their parameter list. </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >Printf</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >'s just happen to be the format string, you could even pass a number down if you want, but the compiler isn't going to do it for you. </span></span></span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Also, although it is possible to then clean up the stack, it's not entirely feasible. Since the function does not know at compile time how many parameters are sent to it, it means it has to manipulate the stack and move around the return value in order to clean up. It's easier to just let the caller clean up the stack in this case. </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Intel supports an instruction to clean up the stack by the callee. It's </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >RET</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >      </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >&lt;Byte Count&gt;</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > where </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >Byte Count</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > is the size in bytes of the parameters on the stack. A 2 byte instruction. </span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>So, what is the stack? </strong></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >A stack is a location for temporary storage. Parameters are pushed onto the stack, then the return address is pushed onto the stack. The flow of execution must know where to return to. The CPU is stupid, it just executes one instruction after the other. You have to tell it where to go. In order to tell it how to get back, we need to save the return address, the location after the function call. There is an assembly instruction that does this for us: </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >CALL</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. There is an assembly instruction that uses the current value on the stack and the return address and transfers execution to that location. It's called </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >RET</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. Beyond this, we have local variables and possibly even other values that are pushed onto the stack for temporary storage. This is one of the reasons you can never return an array or an address of any local variable, they disappear when the function returns! </span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The layout of the stack would be the following: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Parameter n          ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >... </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Parameter 2          ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Parameter 1          ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Return Address       ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Previous Base Pointer] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Local Variables      ] </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Before returning, the stack is cleaned up to the return address and then a "return" is issued. If the stack is not kept in proper order, we may get out of sync and return to the wrong address! This can cause a trap, obviously! </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>What is the "base pointer"? </strong></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The "base pointer" in Intel is generally </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. What happens is since </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ESP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > is dynamic and always changing, you save the old </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > from the previous function, then set </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > to the current stack location. You can now reference variables directly on the stack from a standard offset. This means that the first parameter will always be </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > + </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >xx</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, etc. If you do not save </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ESP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > and always reference </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ESP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, you're going to have to keep track of how much data is on the stack. If you put more and more data on the stack, the offset to the first parameter changes. The assembler <strong>does</strong> generate functions when appropriate to not set </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, so it's not always the case that </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > is the base pointer but rather the function could be using </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ESP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > directly. </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Generally, it's </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > + </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >Value</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > to get to function parameters and </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > - </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >Value</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > to get to local variables. </span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Putting it all together </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >So, you can now see the reason each thread has its own stack. If they shared the same stack, they would overwrite each other's return values and data! Or, could eventually, if they ran out of stack space. That's the next problem we will discuss. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Stack Overflow </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >A Stack Overflow is when you reached the end of your stack. Windows generally gives the program a fixed amount of user mode stack space. The kernel has its own stack. It generally occurs when you run out of stack space! Recursion is a good way to run out of stack space. If you keep recursively calling a function you may eventually run out of stack and trap. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Windows generally does not allocate all of the stack at once, but instead grows the stack as you need it. This is an optimization obviously. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >We can write a small program to perform a stack overflow and then find out how much stack Windows gave us. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; g </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >(928.898): Stack overflow - code c00000fd (first chance) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >First chance exceptions are reported before any exception handling. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >This exception may be expected and handled. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >eax=00131ad8 ebx=7ffdf000 ecx=00131ad8 edx=00430df0 esi=00000000 edi=0003347c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >eip=00401029 esp=00032ffc ebp=00033230 iopl=0         nv up ei pl nz ac po nc </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010216 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >*** WARNING: Unable to verify checksum for COMSTRESS.exe </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >COMSTRESS!func+0x9: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401029 53               push    ebx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; !teb </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >TEB at 7ffde000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    ExceptionList:        0012ffb0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    StackBase:            00130000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    StackLimit:           00031000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    SubSystemTib:         00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    FiberData:            00001e00 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    ArbitraryUserPointer: 00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    Self:                 7ffde000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    EnvironmentPointer:   00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    ClientId:             00000928 . 00000898 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    RpcHandle:            00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    Tls Storage:          00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    PEB Address:          7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    LastErrorValue:       0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    LastStatusValue:      0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    Count Owned Locks:    0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >    HardErrorMode:        0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; ? 130000 - 31000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >Evaluate expression: 1044480 = 000ff000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >To do this, I simply used !teb, which displays all elements of the TEB or "Thread Environment Block" (found at FS:0 as mentioned in a previous tutorial). If you subtract the base of the stack from the stack limit, you get the size. 1,044,480 bytes is how big of a stack Windows gave us. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Stack Underflow </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >In general, a Stack Underflow is the opposite of an overflow. You've somehow thought you put more on the stack than you really have and you've popped off too much. You've reached the beginning of the stack and it's empty, but you thought there was more data and kept attempting to pop data off. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:12pt;"  ><strong>Overflows and Underflows </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Overflows and Underflows can also be said to occur when your program gets out of sync and crashes thinking the stack is in a different position. The stack could underflow if you clean up too much in a function and then attempt to return. Your stack is out of sync and you return to the wrong address. The reason your stack is out of sync is you thought you had more data on it than you did. You could consider that an underflow. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The opposite can also occur. You've cleaned up too little because you didn't think you had that much data on the stack and you return. You trap when you return because you went to the wrong address. You "could" consider this an overflow as you are out of sync, thinking you have less data on the stack than you really do. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >How does the debugger get a stack trace? </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This brings me to my next topic, how does a debugger get a stack trace? The first answer is simply by using "Symbols". The symbols can tell the debugger how many parameters are on the stack, how many local variables, etc., so the debugger can then use the symbols to determine how to walk the stack and display the information. </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >If there are no symbols, it uses the base pointer. Each base pointer points to the previous base pointer. The Base Pointer + 4 also points to the return address. This is how it then walks the stack. If everyone uses </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, the stack trace could be a perfect world. Although the debugger does not know how many parameters there are, it just dumps the location where the parameters <strong>WOULD</strong> be, it's up to you to interpret what the correct parameters are. </span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Here is a simple table of some function calls. I am going to use the stack trace from the first tutorial. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; kb </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 77f944a8 00000007 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff4c 00401147 00000001 00323d70 00322ca8 temp!main+0x44 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 77f944a8 00000007 7ffdf000 temp!mainCRTStartup+0xe3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Since </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >ESP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > will point to local variables, etc., we will dump </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. I will use the "DDS" command which means 'Dump Dwords with Symbols'. The debugger will attempt to match the value on the stack with the closest symbol. </span></span></span></span></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Our current </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > value is 0012fef4. This is a pointer on the stack, remember? This value points to the previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. Remember, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > + 4 == return value, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > + 8 == Parameters. The bold walks the stack to each </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > value. </span></span></span></span></span></span></span></span></span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Stack Address |  Value  | Description] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4  <strong>0012ff38</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef8  77c3e68d MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fefc  77c5aca0 MSVCRT!_iob+0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff00  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff04  0012ff44 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff08  77c5aca0 MSVCRT!_iob+0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff0c  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff10  000007e8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff14  7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff18  0012ffb0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff1c  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff20  0012ff0c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff24  0012f8c8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff28  0012ffb0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff2c  77c33eb0 MSVCRT!_except_handler3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff30  77c146e0 MSVCRT!`string'+0x16c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff34  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>0012ff38  0012ffc0</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff3c  00401044 temp!main+0x44 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff40  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff44  77f944a8 ntdll!RtlpAllocateFromHeapLookaside+0x42 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff48  00000007 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff4c  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff50  00401147 temp!mainCRTStartup+0xe3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff54  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff58  00323d70 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff5c  00322ca8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff60  00403000 temp!__xc_a </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff64  00403004 temp!__xc_z </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff68  0012ffa4 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff6c  0012ff94 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff70  0012ffa0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff74  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff78  0012ff98 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff7c  00403008 temp!__xi_a </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff80  0040300c temp!__xi_z </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff84  77f944a8 ntdll!RtlpAllocateFromHeapLookaside+0x42 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff88  00000007 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff8c  7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff90  c0000005 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff94  00323d70 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff98  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff9c  8053476f </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa0  00322ca8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa4  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa8  0012ff84 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffac  0012f8c8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb0  0012ffe0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb4  00401210 temp!except_handler3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb8  004020d0 temp!&amp;#8962;MSVCRT_NULL_THUNK_DATA+0x80 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffbc  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>0012ffc0  0012fff0</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc4  77e814c7 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc8  77f944a8 ntdll!RtlpAllocateFromHeapLookaside+0x42 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffcc  00000007 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffd0  7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffd4  c0000005 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffd8  0012ffc8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffdc  0012f8c8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffe0  ffffffff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffe4  77e94809 kernel32!_except_handler3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffe8  77e91210 kernel32!`string'+0x98 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffec  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>0012fff0  00000000</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff4  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff8  00401064 temp!mainCRTStartup </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >So, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > points to (0012fef4) which points to the previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > of 0012ff38. </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EIP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > == 77c3f10b, which is </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >MSVCRT!_output</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >+0x18. We can then dump </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > + 8 as the parameters. The debugger with "KB" generally dumps the first 3 values of the stack. It doesn't know if those are correct parameters or not, it's just a preview. If you want to know the rest, you simply find the location on the stack and dump. </span></span></span></span></span></span></span></span></span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fefc  77c5aca0 MSVCRT!_iob+0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff00  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff04  0012ff44 </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >So, we can assemble the first function: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!_output+0x18(77c5aca0, 00000000, 0012ff44); </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The second function is </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > + 4, the return address. Remember, it doesn't know where the functions start. So, the best it can do is match the return address specifying this as the function. </span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is the calling function: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef8  77c3e68d MSVCRT!printf+0x35 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >It then goes to the previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, 0012ff38, and adds 8 to get the parameters. </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff40  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff44  77f944a8 ntdll!RtlpAllocateFromHeapLookaside+0x42 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff48  00000007 </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is the calling function with its parameters. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf+0x35(00000000, 77f944a8, 00000007); </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >As you can see, if anything is off, this information is wrong. That is why you must use your judgment when interpreting these values. </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The next </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > was :0012ffc0. It's the memory location at 0012ff38. The previous return value is: </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff3c  00401044 temp!main+0x44 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The previous parameters were at 0012ffc0 + 8. Remember, this also assumes that </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > was the first value pushed onto the stack. If the debugger is smart enough, it could attempt to just walk the stack until it gets the first recognizable symbol and use that as the return value! That's in case something was pushed onto the stack before </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > was saved and set. </span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >These are the parameters: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc8  77f944a8 ntdll!RtlpAllocateFromHeapLookaside+0x42 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffcc  00000007 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffd0  7ffdf000 </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp!main+0x44(77f944a8, 00000007, 7ffdf000) </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Our next </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > was 0012ffc0, so + 4 is the return value. That's our function now. </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc4  77e814c7 kernel32!BaseProcessStart+0x23 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >So, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > = 0012ffc0, points to previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > 0012fff0 and we know that previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > + 8 == parameters. </span></span></span></span></span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; dds 0012fff0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff4  00000000  &lt;-- Previous return value is NULL so stop here. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff8  00401064 temp!mainCRTStartup  &lt;-- + 8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fffc  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00130000  78746341 </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >kernel32!BaseProcessStart+0x23(00401064, 00000000, 78746341) </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >This should be good enough since our previous return value is </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >NULL</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. So, this is our manual generation of the stack: </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!_output+0x18            (77c5aca0, 00000000, 0012ff44); </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf+0x35             (00000000, 77f944a8, 00000007); </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp!main+0x44                 (77f944a8, 00000007, 7ffdf000); </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >kernel32!BaseProcessStart+0x23 (00401064, 00000000, 78746341); </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This was our stack trace from the debugger: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 77f944a8 00000007 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff4c 00401147 00000001 00323d70 00322ca8 temp!main+0x44 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 77f944a8 00000007 7ffdf000 temp!mainCRTStartup+0xe3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >What's different and why? Well, we followed a simple rule to walk the stack. </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > points to the previous </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. Secondly, we didn't use symbol information to walk the stack. If I delete the symbols for <em>temp.exe</em>, I get the following stack trace: </span></span></span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; kb </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 77f944a8 00000007 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >WARNING: Stack unwind information not available. Following frames may be wrong. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 77f944a8 00000007 7ffdf000 temp+0x1044 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The same as ours! So, the debugger used symbolic information to walk the stack and display a more accurate picture. However, without symbolic information, there's function calls missing. That means, we cannot always trust the stack trace if symbols are wrong, missing or not complete. If we do not have symbol information for all modules, then we have a problem! </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >If I continue with these tutorials, one of the next ones will attempt to explain symbols and validating them. However, I will attempt to show you one trick to validating function calls in this tutorial. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >As we can see, we notice we are missing a function call. How do you validate function calls? By verifying they were made. </span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >Verifying Function Calls </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >I ran the program again and got a new stack trace. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; kb </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 00000000 00000000 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >WARNING: Stack unwind information not available. Following frames may be wrong. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 00000000 00000000 7ffdf000 temp+0x1044 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Some of the values on the stack are different, but that's what happens when you run programs again. You're not guaranteed the same run every time! </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is your first return value: 77c3e68d  </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >If you un-assemble it, you will get this: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 77c3e68d </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf+0x35: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e68d 8945e0           mov     [ebp-0x20],eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e690 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e691 ff75e4           push    dword ptr [ebp-0x1c] </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The listing reads like this: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >&lt;address&gt; &lt;opcode&gt; &lt;assembly instruction in english or mnemonic&gt; </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e691 ff75e4  push dword ptr [ebp-0x1c] </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e691 == Address </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ff75e4   == Opcode or machine code.  This is what the CPU understands </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >push dword ptr [ebp-0x1c]  == Assembly instruction in english. The mnemonic. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is the return value. What is a return value? It's the next instruction <strong>after</strong> a call is made. Thus, if we keep subtracting from this value, we will eventually un-assemble the call instruction. The trick is to un-assemble enough to make out the call function. Be warned though, Intel opcodes are variable. That means that they are <strong>not</strong> a fixed size and un-assembling in the <strong>middle</strong> of an instruction can generate a completely different instruction and even different instruction list! So, we have to guess. Usually if we go back enough, the instructions eventually get back on track and are unassembled correctly. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 77c3e68d - 20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf+0x15: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e66d bdadffff59       mov     ebp,0x59ffffad </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e672 59               pop     ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e673 8365fc00         and     dword ptr [ebp-0x4],0x0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e677 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e678 e8c7140000       call    MSVCRT!_stbuf (77c3fb44) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e67d 8945e4           mov     [ebp-0x1c],eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e680 8d450c           lea     eax,[ebp+0xc] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e683 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf+0x2c: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e684 ff7508           push    dword ptr [ebp+0x8] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e687 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>77c3e688 e8660a0000       call    MSVCRT!_output (77c3f0f3) </strong></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>77c3e68d 8945e0           mov     [ebp-0x20],eax</strong>   </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >As you can see, the return address is 77c3e68d. So, 77c3e688 is the function call. Thus, we are calling </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >_output</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >! So, that is a correct function call. Want to try another? </span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >The next return address listed in the stack trace is 00401044. Let's try the same: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 00401044  - 20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1024: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401024 2408             and     al,0x8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401026 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401027 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401028 6a04             push    0x4 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040102a 6820304000       push    0x403020 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040102f 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401030 ff1500204000     call    dword ptr [temp+0x2000 (00402000)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401036 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1037: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401037 ff1508204000     call    dword ptr [temp+0x2008 (00402008)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040103d 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>0040103e ff1510204000     call    dword ptr [temp+0x2010 (00402010)] </strong></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>00401044 59               pop     ecx</strong>   </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Unfortunately yes, this is assembly. This is basically a function pointer. It means call the function at address 00402010. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Use "DD" to get the value at the address. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; dd 00402010 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00402010  77c3e658 </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >We will now un-assemble this address since we know it's a function call. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 77c3e658 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >MSVCRT!printf: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77c3e658 6a10             push    0x10 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >So, yes, we're calling </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > here. </span></span></span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >The next return value is 77e814c7. Let's see if we're calling </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >temp</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 77e814c7 - 20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >kernel32!BaseProcessStart+0x3: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814a7 1012             adc     [edx],dl </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814a9 e977e8288e       jmp     0610fd25 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814ae ffff             ??? </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814b0 8365fc00         and     dword ptr [ebp-0x4],0x0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814b4 6a04             push    0x4 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814b6 8d4508           lea     eax,[ebp+0x8] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814b9 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814ba 6a09             push    0x9 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >kernel32!BaseProcessStart+0x18: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814bc 6afe             push    0xfe </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >77e814be ff159c13e677 call dword ptr [kernel32!_imp__NtSetInformationThread (77e </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >6139c)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>77e814c4 ff5508           call    dword ptr [ebp+0x8] </strong></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>77e814c7 50               push    eax</strong>   </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >It's calling the first parameter. This is the first parameter: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 <strong>00401064</strong> 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 00401064 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1064: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401064 55               push    ebp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401065 8bec             mov     ebp,esp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401067 6aff             push    0xff </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >So, it is calling something inside of </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >temp</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. Unfortunately, we can't be certain it's the same function. In order to find that out, we need to un-assemble this function and walk through it. Remember, the call to </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > is at: </span></span></span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040103e ff1510204000     call    dword ptr [temp+0x2010 (00402010)] </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >That means that we have to un-assemble this function from its start all the way to 0401064. Another way to do it would be to use DDS on the stack and find out if there are any other symbols on the stack and verify them. </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >If we do DDS on </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, we find this: </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; dds ebp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4  0012ff38 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef8  77c3e68d MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fefc  77c5aca0 MSVCRT!_iob+0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff00  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff04  0012ff44 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff08  77c5aca0 MSVCRT!_iob+0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff0c  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff10  000007e8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff14  7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff18  0012ffb0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff1c  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff20  0012ff0c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff24  ffffffff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff28  0012ffb0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff2c  77c33eb0 MSVCRT!_except_handler3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff30  77c146e0 MSVCRT!`string'+0x16c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff34  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38  0012ffc0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>0012ff3c  00401044 temp+0x1044</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff40  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff44  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff48  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff4c  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff50  00401147 temp+0x1147 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff54  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff58  00322470 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff5c  00322cf8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff60  00403000 temp+0x3000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff64  00403004 temp+0x3004 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff68  0012ffa4 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff6c  0012ff94 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff70  0012ffa0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; dds </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff74  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff78  0012ff98 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff7c  00403008 temp+0x3008 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff80  0040300c temp+0x300c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff84  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff88  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff8c  7ffdf000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff90  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff94  00322470 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff98  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff9c  8053476f </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa0  00322cf8 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa4  00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffa8  0012ff84 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffac  e3ce0b30 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb0  0012ffe0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb4  00401210 temp+0x1210 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffb8  004020d0 temp+0x20d0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffbc  00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0  0012fff0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc4  77e814c7 kernel32!BaseProcessStart+0x23 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >There are a lot of unknown </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >TEMP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > + </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >xxx</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > values on the stack! The one in bold is the one we know is the return value for the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf()</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. 00401064, we know is the start address of the function called from </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >BaseProcessStart()</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. What values are close to this one? </span></span></span></span></span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This is where guess work comes in. If you think that function does not jump backwards, you could attempt to only look at values that are &gt; than this one. You could attempt to un-assemble every single reference, but you have to start somewhere. I would say, look at the symbols closest to this one first. Here is one: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff50  00401147 temp+0x1147  </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 00401147 - 20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1127: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401127 40               inc     eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401128 00e8             add     al,ch </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040112a 640000           add     fs:[eax],al </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040112d 00ff             add     bh,bh </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040112f 1520204000       adc     eax,0x402020 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401134 8b4de0           mov     ecx,[ebp-0x20] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401137 8908             mov     [eax],ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401139 ff75e0           push    dword ptr [ebp-0x20] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x113c: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040113c ff75d4           push    dword ptr [ebp-0x2c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040113f ff75e4           push    dword ptr [ebp-0x1c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>00401142 e8b9feffff       call    temp+0x1000 (00401000)</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401147 83c430           add     esp,0x30 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >We found this function call and it looks to be a valid address. The way to distinguish an invalid return value on the stack is, the previous instruction is <strong>not</strong> a </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >CALL</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > instruction. That is one way to distinguish return values from just values on the stack that may be a symbol, but not return value. </span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Let's un-assemble this one: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 00401000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1000: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401000 51               push    ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401001 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401002 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401003 33ff             xor     edi,edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401005 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401006 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401007 6a03             push    0x3 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401009 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x100a: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040100a 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040100b 6800000080       push    0x80000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401010 6810304000       push    0x403010 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401015 ff1504204000     call    dword ptr [temp+0x2004 (00402004)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040101b 8bf0             mov     esi,eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040101d 83feff           cmp     esi,0xffffffff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401020 741b             jz      temp+0x103d (0040103d) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401022 8d442408         lea     eax,[esp+0x8] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1026: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401026 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401027 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401028 6a04             push    0x4 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040102a 6820304000       push    0x403020 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040102f 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401030 ff1500204000     call    dword ptr [temp+0x2000 (00402000)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401036 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401037 ff1508204000     call    dword ptr [temp+0x2008 (00402008)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x103d: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040103d 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >&lt;BB&gt;0040103e ff1510204000     call    dword ptr [temp+0x2010 (00402010)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401044 59               pop     ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401045 5f               pop     edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401046 33c0             xor     eax,eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401048 5e               pop     esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401049 59               pop     ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040104a c3               ret </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >This looks like a valid function call and looks like it calls </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >. So, we could then disassemble the original function call until we reached this call, to see if it called it, or if there's yet another function call in between. </span></span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u 0401064 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1064: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401064 55               push    ebp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401065 8bec             mov     ebp,esp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401067 6aff             push    0xff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401069 68d0204000       push    0x4020d0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040106e 6810124000       push    0x401210 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401073 64a100000000     mov     eax,fs:[00000000] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401079 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040107a 64892500000000   mov     fs:[00000000],esp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; u </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1081: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401081 83ec20           sub     esp,0x20 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401084 53               push    ebx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401085 56               push    esi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401086 57               push    edi </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401087 8965e8           mov     [ebp-0x18],esp </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040108a 8365fc00         and     dword ptr [ebp-0x4],0x0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040108e 6a01             push    0x1 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401090 ff153c204000     call    dword ptr [temp+0x203c (0040203c)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1096: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401096 59               pop     ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401097 830d40304000ff   or    dword ptr [temp+0x3040 (00403040)],0xffffffff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040109e 830d44304000ff   or    dword ptr [temp+0x3044 (00403044)],0xffffffff </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010a5 ff1538204000     call    dword ptr [temp+0x2038 (00402038)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010ab 8b0d3c304000     mov     ecx,[temp+0x303c (0040303c)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010b1 8908             mov     [eax],ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010b3 ff1534204000     call    dword ptr [temp+0x2034 (00402034)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010b9 8b0d38304000     mov     ecx,[temp+0x3038 (00403038)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x10bf: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010bf 8908             mov     [eax],ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010c1 a130204000       mov     eax,[temp+0x2030 (00402030)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010c6 8b00             mov     eax,[eax] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010c8 a348304000       mov     [temp+0x3048 (00403048)],eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010cd e8e1000000       call    temp+0x11b3 (004011b3) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010d2 833d2830400000   cmp     dword ptr [temp+0x3028 (00403028)],0x0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010d9 750c             jnz     temp+0x10e7 (004010e7) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010db 68b0114000       push    0x4011b0 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x10e0: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010e0 ff152c204000     call    dword ptr [temp+0x202c (0040202c)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010e6 59               pop     ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010e7 e8ac000000       call    temp+0x1198 (00401198) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010ec 680c304000       push    0x40300c </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010f1 6808304000       push    0x403008 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010f6 e897000000       call    temp+0x1192 (00401192) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >004010fb a134304000       mov     eax,[temp+0x3034 (00403034)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401100 8945d8           mov     [ebp-0x28],eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1103: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401103 8d45d8           lea     eax,[ebp-0x28] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401106 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401107 ff3530304000     push    dword ptr [temp+0x3030 (00403030)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040110d 8d45e0           lea     eax,[ebp-0x20] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401110 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401111 8d45d4           lea     eax,[ebp-0x2c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401114 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401115 8d45e4           lea     eax,[ebp-0x1c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1118: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401118 50               push    eax </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401119 ff1524204000     call    dword ptr [temp+0x2024 (00402024)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040111f 6804304000       push    0x403004 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401124 6800304000       push    0x403000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401129 e864000000       call    temp+0x1192 (00401192) </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040112e ff1520204000     call    dword ptr [temp+0x2020 (00402020)] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401134 8b4de0           mov     ecx,[ebp-0x20] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401137 8908             mov     [eax],ecx </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >temp+0x1139: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401139 ff75e0           push    dword ptr [ebp-0x20] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040113c ff75d4           push    dword ptr [ebp-0x2c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0040113f ff75e4           push    dword ptr [ebp-0x1c] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>00401142 e8b9feffff       call    temp+0x1000 (00401000)</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401147 83c430           add     esp,0x30 </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >If you know assembly, you can simply read through the logic and bet that it could have made it here or if it could not make it here. If it could, then provided two functions do not share the same assembled code base, there are two function calls missing. Now, if you just find their return values on the stack, you can find their parameter list. What can we assume from this? Some of these functions do not use </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >EBP</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >, thus we could not get an accurate stack trace. When that happens, we need to verify our trace. As we can see, the previous function did not call </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, but another one did that it called. </span></span></span></span></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >00401147 is the missing return value. If we find it on the stack, we can update the correct parameters: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00401147 temp+0x1147 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00000001 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322470 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322cf8 </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >So, here's the one generated from KB: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; kb </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 00000000 00000000 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >WARNING: Stack unwind information not available. Following frames may be wrong. </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 00000000 00000000 7ffdf000 temp+0x1044 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Here's our modified one: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >ChildEBP RetAddr  Args to Child </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fef4 77c3e68d 77c5aca0 00000000 0012ff44 MSVCRT!_output+0x18 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ff38 00401044 00000000 00000000 00000000 MSVCRT!printf+0x35 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >WARNING: Stack unwind information not available. Following frames may be wrong. </span></p><p style="background: #fbedbb;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  ><strong>xxxxxxxx  0401147  00000001 00322470 00322cf8 temp+0x1044</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012ffc0 77e814c7 00000000 00000000 7ffdf000 <strong>temp+0x1147</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0012fff0 00000000 00401064 00000000 78746341 kernel32!BaseProcessStart+0x23 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >We know that the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >temp</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > that calls </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >printf()</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > is </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >main()</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >. So, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >argc</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > = 1, </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >*argv[]</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > = 322470. </span></span></span></span></span></span></span></span></span></span></span></p><p><span style="color:#990000;"  ><span style="font-family:Consolas;"  >*argv[]</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > is a pointer to an array of pointers which are ANSI strings. </span></span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; dd 322470 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322470  <strong>00322478</strong> 00000000 706d6574 ababab00 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322480  abababab feeefeab 00000000 00000000 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322490  000500c5 feee0400 00325028 00320178 </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >003224a0  feeefeee feeefeee feeefeee feeefeee </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >003224b0  feeefeee feeefeee feeefeee feeefeee </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >003224c0  feeefeee feeefeee feeefeee feeefeee </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >003224d0  feeefeee feeefeee feeefeee feeefeee </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >003224e0  feeefeee feeefeee feeefeee feeefeee </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >0:000&gt; da <strong>00322478</strong>   </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >00322478  "temp" </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >Dumping the array, which only contains 1 string as per </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >argc</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, we can then use the "da" command to view that string as shown above. </span></span></span></p><p><span style="color:#ff9900; font-family:Segoe UI; font-size:15pt;"  ><strong>Multiple Return Addresses On The Stack? </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Why are there multiple return addresses on the stack? The stack may generally be initialized to zero, but as it's being used, it becomes dirty. You know that local variables aren't always initialized, so if you make a function call, those values aren't reset to zero when the stack moves up. If you pop a value off the stack, the stack may decrement, but the values stay unless they are physically cleaned up. Sometimes, the stack optimizes things and doesn't clean up variables as well. So, seeing "ghost" values on the stack is very common. </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >This is not always desirable to leave values on the stack. For example, if your function puts the password on the stack and traps sometime later. A stack dump may still show the password on the stack! So, sometimes when you have sensitive information, you may want to clean up the values on the stack before you return. One way to do this is with the </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >SecureZeroMemory()</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  > API. This can be used to clear memory securely as calling other APIs may be "optimized" out of the code, for example, if you call them before you return. The compiler knows you're not going to use the variable anymore and may not perform the clearing. </span></span></span></p><p><span style="color:#ff9900; font-family:Segoe UI; font-size:15pt;"  ><strong>Buffer Overflows </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Buffer overflows are a common occurrence on the stack. The stack grows down in memory, but arrays grow up in memory. This is because you usually "increment" a pointer or array when using it to get to the next index, rather than decrementing it. Thus let's say this was your C function: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >{ </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >      DWORD MyArray[4]; </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >      int Index; </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >That would evaluate to a stack like this: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >424 [Return Address               ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >420 [ Previous Base Pointer       ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >416 [ Local Array Variable Index 3] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >412 [ Local Array Variable Index 2] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >408 [ Local Array Variable Index 1] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >404 [ Local Array Variable Index 0] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >400 [ Local Integer Value         ] </span></p><p><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  >As you can see, if you index your array to </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >MyArray[4]</span><span style="color:#111111;"  ><span style="font-family:Segoe UI; font-size:10pt;"  > or </span><span style="color:#990000;"  ><span style="font-family:Consolas;"  >MyArray[5]</span><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >, you overwrite critical values that may cause you to trap! Overwriting the previous base pointer may not harm if the calling function does not use it anymore. However, overwriting the return address will most definitely cause a trap! This is why you must always be careful to stay within your array boundaries when dealing with local variables. You could overwrite other local variables, the return address, the parameters, or just about anything! </span></span></span></span></span></p><p><span style="color:#666666; font-family:Segoe UI; font-size:13pt;"  >Windows 2003 </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Windows 2003 has a new method to attempt to prevent buffer overflows. This can be compiled in VS.NET using the GS flags. A random value is generated as a cookie on startup of the application. The cookie is then XOR'd with the return address of the function and placed on the stack after the base pointer. This is a simple example: </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Return Address            ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Previous Base Pointer     ] </span></p><p style="background: #fbedbb;"  ><span style="color:black; font-family:Consolas; font-size:9pt;"  >[Cookie XOR Return Address ] </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >Upon return, the cookie is checked against the return value. If they're unchanged, then the return occurs, if not, then we have a problem. The reason for this security is not to prevent code from trapping without proper handling, but rather to protect code from executing injected code. A security risk is when someone finds out how to overflow a buffer with actual code and an address to that code. This will cause the program to return to and execute that code. </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >This URL provides the full details of this: </span></p><ul><li><div><a target="_blank" rel="nofollow" href="http://msdn.microsoft.com/library/?url=/library/en-us/dv_vstechart/html/vctchCompilerSecurityChecksInDepth.asp?frame=true"  ><span style="color:#005782; font-family:宋体; font-size:10pt;"  >MSDN</span></a><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >     </span></div><p><span style="color:#ff9900; font-family:Segoe UI; font-size:15pt;"  ><strong>Conclusion </strong></span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >I have confused beginners and probably bored advanced programmers, however, it's hard to portray advanced concepts in a simple manner. I am trying my best though. If you like or dislike these tutorials, leave me a comment. If you want these to end, let me know too! </span></p><p><span style="color:#111111; font-family:Segoe UI; font-size:10pt;"  >I've probably started off too simple then got too advanced too fast. I can't help it though, programmers should study this information and supplement it with other sources to gain full knowledge on the subject. Do not take what you read or posted on message boards as concrete fact. Everyone is human, everyone errors and not one person knows everything. These sites let just about anyone post information, so always be skeptical. Let me know if you found an error. Thanks. </span></p></li></ul>
</body></html>