<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Mutiplex DLL Call</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Mutiplex DLL Call</h2>
<p align="right">发布时间：2010-2-12 09:51
<br>分类名称：Private</p><br>
<h2><a rel="nofollow"   >Method On<wbr>e :</a></h2><h2><a rel="nofollow"   ></a></h2><p>  </p><p><a target="_blank" href="pic/img623.ph.126.net_LgMRUyvTvAeWQcpdV90WUw==_1946399463955743242.gif"    ><img title="Mutiplex DLL Call - Dsliu - Dspace"    alt="Mutiplex DLL Call - Dsliu - Dspace"    src="pic/img623.ph.126.net_LgMRUyvTvAeWQcpdV90WUw==_1946399463955743242.gif"    ></a></p><p>A和B的实现是一样的，都是在<em>DLL_PROCESS_ATTACH</em>中使用<em>LoadLibrary()</em>加载C。而且  都调用了<em>DisableThreadLibraryCalls()</em>函数禁止了<em>DLL_THREAD_XXXX</em>的通  知。  </p>    <p>  在C中有一个字符串指针的全局变量，在<em>DLL_PROCESS_ATTACH</em>时分配内存，在<em>DLL_PROCESS_DETACH</em>时  释放相应内存。  </p>    <p>  A和B在<em>DLL_PROCESS_DETACH</em>时会访问C的一个导出函数，该导出函数返回其全局变量指针。访问这个导出函数之后，A、  B都会调用<em>FreeLibrary()</em>卸载C。  </p>    <p>  执行结果表明了这些DLL的加载和卸载过程：  </p>    <p>  <strong>加载：</strong>  </p>    <p>  1.A被加载，A::DllMain(DLL_PROCESS_ATTACH)被调用。   </p>    <p>  2.C被加载，C::DllMain(DLL_PROCESS_ATTACH)被调用。   </p>    <p>  3.C的全局变量被初始化，分配内存，赋值。   </p>    <p>  4.C::DllMain()调用完成。   </p>    <p>  5.A::DllMain()调用完成。   </p>    <p>  6.B被加载，B::DllMain(DLL_PROCESS_ATTACH)被调用。   </p>    <p>  7.此时，B加载C，但是C的DllMain()不会被调用！C的引用计数(由系统维护的)会增加。   </p>    <p>  <strong>卸载：</strong>  </p>    <p>  1.A被卸载，<em>A::DllMain(DLL_PROCESS_DETACH)</em>被调用。   </p>    <p>  2.此时，调用<em>FreeLibrary(C)</em>并不会引起<em>C::DllMain()</em>被调用，因为目前C的引用计数值不  为1。   </p>    <p>  3.<em>A::DllMain()</em>调用完成。   </p>    <p>  4.B被卸载，<em>B::DllMain(DLL_PROCESS_DETACH)</em>被调用。   </p>    <p>  5.此时，调用<em>FreeLibrary(C)</em>没有什么作用，<em>C::DllMain()</em>不会被调用。(我还不知道为什  么会这样子！)   </p>    <p>  6.<em>B::DllMain()</em>调用完成。   </p>    <p>  7.<em>B::DllMain()</em>调用结束后，<em>C::DllMain(DLL_PROCESS_DETACH)</em>被调用。     </p>    <p>  8.此时，C作释放资源等工作，没有任何问题。   </p>    <p>  9.<em>C::DllMain()</em>调用完成。   </p>    <p>  注意：如果在卸载过程中A或者B没有显式地调用<em>FreeLibrary()</em>卸载C，那么A、B都被卸载后，C依然存在，直到应用程序退  出时才被系统释放。 <br></p><h2><a rel="nofollow"   >Method Two :</a></h2><p><br></p><p><a target="_blank" href="pic/img162.ph.126.net_xB0y7r7sUNNJk3dCcSxiqA==_2278258461497058988.gif"    ><img title="Mutiplex DLL Call - Dsliu - Dspace"    alt="Mutiplex DLL Call - Dsliu - Dspace"    src="pic/img162.ph.126.net_xB0y7r7sUNNJk3dCcSxiqA==_2278258461497058988.gif"    ></a></p><p><br>  </p><p>A在<em>DLL_PROCESS_ATTACH</em>时调用<em>LoadLibrary()</em>，先后加载B和C。在<em>DLL_PROCESS_DETACH</em>时  调用<em>FreeLibrary()</em>先后释放B和C。  </p>    <p>  B在<em>DLL_PROCESS_ATTACH</em>时加载C，在<em>DLL_PROCESS_DETACH</em>时卸载C。  </p>    <p>  执行结果表明了这些DLL的加载和卸载过程：  </p>    <p>  <strong>加载：</strong>  </p>    <p>   1.A被加载，<em>A::DllMain(DLL_PROCESS_ATTACH)</em>被调用。   </p>    <p>  2.B被加载，<em>B::DllMain(DLL_PROCESS_ATTACH)</em>被调用。   </p>    <p>  3.C被加载，<em>C::DllMain(DLL_PROCESS_ATTACH)</em>被调用。   </p>    <p>  4.C的全局变量被初始化，分配内存，赋值。   </p>    <p>  5.<em>C::DllMain()</em>调用完成。   </p>    <p>  6.B加载C完成，<em>B::DllMain()</em>调用完成。   </p>    <p>  7.A加载B完成，准备加载C。   </p>    <p>  8.A加载C，<em>C:DllMain()</em>不会被调用。   </p>    <p>  9.<em>A::DllMain()</em>调用完成。   </p>    <p>  <strong>卸载：</strong>  </p>    <p>   1.A被卸载，<em>A::DllMain(DLL_PROCESS_DETACH)</em>被调用。   </p>    <p>  2.此时，调用<em>FreeLibrary(B)</em>并不会引起<em>B::DllMain()</em>被调用。   </p>    <p>  3.A此时仍然可以访问C的函数和数据。   </p>    <p>  4.A调用<em>FreeLibrary(C)</em>来卸载<em>C，C::DllMain()</em>不会被立即调用。   </p>    <p>  5.<em>A::DllMain()</em>调用完成。   </p>    <p>  6.立刻，<em>B::DllMain(DLL_PROCESS_DETACH)</em>被调用。   </p>    <p>  7.此时，B仍然可以正常访问C的函数和数据。   </p>    <p>  8.B也会调用<em>FreeLibrary(C)</em>来卸载C，但是<em>C::DllMain()</em>不会被立即调用。   </p>    <p>  9.<em>B::DllMain()</em>调用完成。   </p>    <p>  10.<em>B::DllMain()</em>调用结束后，<em>C::DllMain(DLL_PROCESS_DETACH)</em>立刻被  调用。   </p>    <p>  11.此时，C作释放资源等工作，没有任何问题。   </p>    <p>  12.<em>C::DllMain()</em>调用完成。    </p>
</body></html>