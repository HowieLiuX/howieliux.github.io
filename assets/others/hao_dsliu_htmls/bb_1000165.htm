<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：BSTR 字符串</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>BSTR 字符串</h2>
<p align="right">发布时间：2012-5-3 11:19
<br>分类名称：COM</p><br>
<p><span style="font-family:宋体; font-size:12pt;"  >BSTR是"Basic String"的简称，微软在COM/OLE中定义的标准字符串数据类型。 <br>对于VC++，Windows头文件wtypes.h和WinNT.h中定义如下：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >typedef /* [wire_marshal] */ OLECHAR *BSTR; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >typedef WCHAR OLECHAR; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >typedef wchar_t WCHAR; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >由于COM是跨系统及不同开发语言间实现互操作的技术，常规以Null结尾的简单字符串在COM 组件间传递不太方便。因此，便出现了BSTR字符串类型，BSTR是指针类型，标准BSTR是一个有长度前缀和null结束符的OLECHAR数组。 BSTR的前4字节是一个表示字符串长度的前缀。BSTR长度域的值是字符串的字节数，但不包括字符串结束符。 BSTR实际上包含的是Unicode串，所以字符数是字节数的一半。这种方式的优点是允许程序员在BSTR串中间嵌入NULL字符，字符串的长度由 BSTR的前四个字节表示，（长度中可能包含NULL），bstr字符串是不能象基本数据类型一样直接进行定义的。 为处理BSTR字符串，微软在OleAuto.h中定义了BSTR API，分别是：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR SysAllocString(const OLECHAR * psz); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >INT  SysReAllocString(BSTR* pbstr,const OLECHAR* psz); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR SysAllocStringLen(const OLECHAR * strIn, UINT ui); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >INT  SysReAllocStringLen(BSTR* pbstr,const OLECHAR* psz,unsigned int len); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >void SysFreeString(BSTR bstrString); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >UINT SysStringLen(BSTR); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >UINT SysStringByteLen(BSTR bstr); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR SysAllocStringByteLen(LPCSTR psz,UINT len); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >下面对上述API用法进行说明。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >1、SysAllocString函数用于创建一个BSTR字符串，如：BSTR bstr=SysAllocString(L"create bstr string");就创建了一个BSTR字符串，上面说过BSTR字符串最初4个字节表示了字符串中字符个数，接下来是字符串中包含的真实字符，下面我们 验证一下是否是这样的。我们生成一个WIN32控制台工程，生成时选择支持ATL的头文件，也可以后添加相应的头文件，主要是atlbase.h和 atlstr.h，输入如下语句：<br><br>printf("bstr front 4 byte is %x",*((int*)(((int*)bstr-1))));<br><br>语句中的bstr是以上刚刚生成的BSTR组符串，此语句显示的结果是"bstr front 4 byte is 24"换算成10进制正好是34，是"create bstr string"长度的2倍因为BSTR字符串中的字符是用Unicode表示的，而语句<br><br>printf("bstr front 0 byte is %c",*((int*)((int*)bstr)));<br><br>输出的是"c"是语句中的第一个字符，语句<br><br>printf("bstr front 35 byte is %c\n",*((char*)(((char*)bstr+34))));<br><br>输出的是"g"语句中的最后一个字符，以上说明了SysAllocString函数用法及BSTR字符串在内存中的存储格式。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2、SysReAllocString用于在一个已有的BSTR字符串的基础上重新建立一个BSTR字符串，输入如下的语句，可以检测该函数使用后的效果： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR bstr=SysAllocString(L"create bstr string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    SysReAllocString (&amp;bstr,L"new string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 4 byte is %x\n",*((int*)(((int*)bstr-1)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 0 byte is %c\n",*((int*)((int*)bstr))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr front 35 byte is %c\n",*((char*)(((char*)bstr+34)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >该语句最后输出是"14，n，g"说明SysReAllocString (&amp;bstr,L"new string");语句是在已经生成的bstr字符串上建立一个新的字符串，因新串"new string"的长度是20，换算成16进制正好是14，而输出的g说明因新串短于旧串所以原字符串超出的部分为变化，但已经超出14所指出的长度范围。 但如果新的字符串如果超出原来串的长度，那么原来的字符串将被全部覆盖，长度以新的字符串为准，下面的语句说明了这一点。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  > SysReAllocString (&amp;bstr,L"new string new string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 4 byte is %x\n",*((int*)(((int*)bstr-1)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 0 byte is %c\n",*((int*)((int*)bstr))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr front 35 byte is %c\n",*((char*)(((char*)bstr+34)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3、SysAllocStringLen按照指定的长度分配一个BSTR字符串，例如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR bstr=SysAllocStringLen(L"create bstr string",6); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 4 byte is %x\n",*((int*)(((int*)bstr-1)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 0 byte is %c\n",*((int*)((int*)bstr))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr front 35 byte is %c\n",*((char*)(((char*)bstr+34)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >虽然"create bstr string"的长度是18个字符但此语句只分派6个字符的BSTR串。<br>4、SysReAllocStringLen函数是在已有的字符串的基础上按指定长度重新分配一个新的BSTR字符串。如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR bstr=SysAllocString(L"create bstr string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    SysReAllocStringLen(&amp;bstr,L"new string",3); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 4 byte is %x\n",*((int*)(((int*)bstr-1)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf("bstr front 0 byte is %c\n",*((int*)((int*)bstr))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr front 35 byte is %c\n",*((char*)(((char*)bstr+34)))); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >5、SysFreeString是释放一个BSTR字符串，BSTR字符串用后必须用此函数进行释放，例如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >SysFreeString(bstr); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >6、SysStringLen求一个BSTR字符串的长度，如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr size is %d\n",SysStringLen(bstr));其长度是指字符串中字符个数，而非字节数。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >7、SysStringByteLen求一个BSTR字符串的字节长度，如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >printf("bstr size is %d\n",SysStringByteLen(bstr)); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >8、SysAllocStringByteLen是按字节长度分配一个BSTR字符串。<br>以上大致就是BSTR API 的用法，为了方便操作BSTR字符串，在ATL中建立了CComBSTR类专门用于操作BSTR字符，下面大致说说该类的用法。<br>CComBSTR类维护了公有的BSTR类型成员变量m_str，定义了8个构造函数用于创建CComBSTR对象，在析构函数中释放了m_str,在类中定义了常用的操作符并提供了对象持久性支持。<br>1、构造一个CComBSTR对象 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr1.m_str ,L"bstr test",MB_OK); 创建一个空的CComBSTR 对象 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr2(L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2.m_str ,L"bstr test",MB_OK); 创建一个包含"this is a BSTR string"字符串的CComBSTR 对象 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr3(5); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr3.m_str ,L"bstr test",MB_OK);创建一个初始长度为5，含NULL的CComBSTR对象。 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr4(3,L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr4.m_str ,L"bstr test",MB_OK);创建一个长度为3的CComBSTR对象，后面的字符串舍去。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >我们也可以从一个已经存在的CComBSTR对象创建另一个CCOmBSTR对象，如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    CComBSTR bstr2(bstr1); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2.m_str ,L"bstr test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >最后的一个构造函数比较奇怪，他接受一个GUID参数，生成一个包含GUID字符串的CComBSTR对象，如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >static const GUID GUID_Sample={0X8a44e110,0xf134,0x11d1,{0x96,0xb1,0xba,0xdb,0xba,0xdb,0xad,0xcc}}; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    CComBSTR bstr1(GUID_Sample); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr1.m_str ,L"bstr test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2、CComBSTR定义的常用操作如下<br>（1）"="操作符（赋值操作），如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    CComBSTR bstr2=bstr1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2.m_str ,L"BSTR test",MB_OK);bstr2和bstr1包含相同内容。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（2）BSTR操作符把CComBSTR对象显式的或隐式的转换成BSTR字符串，如: </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR bstr2=bstr1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2 ,L"BSTR test",MB_OK);隐式转换 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,(BSTR)bstr1 ,L"BSTR test",MB_OK);显式转换 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（3）！= 操作符，用来直接比较两个CComBSTR对象，如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string1"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    CComBSTR bstr2(L"this is a BSTR string2"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    if (bstr1!=bstr2) </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        MessageBox(NULL,L"true",L"BSTR test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    else  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        MessageBox(NULL,L"false",L"BSTR test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3、CComBSTR定义的常用方法如下<br>（1）Copy 方法，该方法拷贝CComBSTR对象中的BSTR字符串并返回BSTR字符串，如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string1"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    BSTR bstr2=bstr1.Copy (); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2,L"BSTR test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（2）CopyTo 方法将CComBSTR对象中的BSTR字符串拷贝到新的位置，必须显式的调用SysStringFree来释放返回的字符串，如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >CComBSTR bstr1(L"this is a BSTR string1"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    BSTR bstr2; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    bstr1.CopyTo (&amp;bstr2); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2,L"BSTR test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（3）Attach方法把一个BSTR字符串附加到CComBSTR对象上，如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >BSTR bstr1=::SysAllocString (L"this is a BSTR string"); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    CComBSTR bstr2; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    bstr2.Attach (bstr1); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MessageBox(NULL,bstr2.m_str ,L"BSTR test",MB_OK); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（4）Detach方法分离BSTR字串与CComBSTR对象，用法： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >bstr2.Detach (); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >（5）Empty 方法，释放对象中的BSTR字符串。 CComBSTR对象还有一些其它的方法，如附加字符串、大小写转换、对象持久性等并不常用。 总之BSTR字符串是COM技术的基石，CComBSTR是处理BSTR字符串的利器，深入理解BSTR字符串是研究COM技术必须经过的关口。</span></p>
</body></html>