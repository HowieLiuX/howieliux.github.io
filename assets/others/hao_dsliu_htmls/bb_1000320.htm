<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：CppUnit源码解读 II</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>CppUnit源码解读 II</h2>
<p align="right">发布时间：2010-2-12 11:56
<br>分类名称：Private</p><br>
<p>     这里我们再次看到了wasDestroyed和needDestroy，正如前面所述，它们是为了防止多次销毁同一个  TestFactoryRegistry实例的。对于如下的代码：   </p>  <pre>  registerFactory<span>(</span> <span>"All Tests"</span>, getRegistry<span>(</span> <span>"Unit Tests"</span> <span>)</span> <span>)</span>;</pre>  <p>  在了解了TestFactoryRegistry::getRegistry的实际行为之后，你会发现，名为 “Unit   Tests”的注册项将同时被名为”All   Tests”的注册项和NamedRegistries所拥有。此外，morning以为，对于没有在NamedRegistries中注册的   TestFactoryRegistry实例，调用needDestroy的结果同样为true，此处也保证可以被及时销毁，而不致造成内存泄漏。由此足  见，此处的注册机制是相当灵活的。  </p>    <p>  上面出现的m_factories是TestFactoryRegistry的一个private属性的成员变量：   </p>  <pre>Factories m_factories;  <span>// 代表一个类工厂名称-类工厂实例的映射表</span></pre>  <p>  Factories的定义如下：   </p>  <pre><span>typedef</span> std::<span>map</span>&lt;std::<span>string</span>, TestFactory *&gt; Factories;</pre>  <p>  至于getRegistry方法，则有两个版本，一个有形参，另一个则没有：   </p>  <pre>TestFactoryRegistry &amp;<br>TestFactoryRegistry::<span>getRegistry</span><span>(</span><span>)</span><br><span>{</span><br>  <span>// 调用另一个版本的getRegistry，并传入“All Tests”</span><br>  <span>// 一般代表某组测试的“根节点”</span><br>  <span>return</span> getRegistry<span>(</span> <span>"All Tests"</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br>TestFactoryRegistry &amp;<br>TestFactoryRegistry::<span>getRegistry</span><span>(</span> <span>const</span> std::<span>string</span> &amp;name <span>)</span><br><span>{</span><br>  <span>// 获取NamedRegistries的实例，并调用其getRegistry方法</span><br>  <span>return</span> NamedRegistries::<span>getInstance</span><span>(</span><span>)</span>.<span>getRegistry</span><span>(</span> name <span>)</span>;<br><span>}</span></pre>  <p>     前面提到，某个类工厂的注册项，其下可能包含一组类工厂，即形成所谓的层状结构。为了支持这一功能，TestFactoryRegistry提供了  registerFactory方法，同样有两个不同版本：   </p>  <pre><span>// 给定类工厂的名称及其对应的实例指针</span><br><span>void</span> <br>TestFactoryRegistry::<span>registerFactory</span><span>(</span> <span>const</span> std::<span>string</span> &amp;name,<br>                                      TestFactory *factory <span>)</span><br><span>{</span><br>  m_factories<span>[</span>name<span>]</span> = factory;<br><span>}</span><br>&nbsp;<br><span>// 只给出了类工厂的实例指针，此之渭Unnamed TestFactory</span><br><span>void</span> <br>TestFactoryRegistry::<span>registerFactory</span><span>(</span> TestFactory *factory <span>)</span><br><span>{</span><br>  <span>// 通过serialNumber自动形成名称，再调用另一个版本的registerFactory</span><br>  <span>// static变量serialNumber从1开始，每次累加1</span><br>  <span>static</span> <span>int</span> serialNumber = <span>1</span>;<br>&nbsp;<br>  OStringStream ost;<br>  ost &lt;&lt; <span>"@Dummy@"</span> &lt;&lt; serialNumber++;<br>&nbsp;<br>  registerFactory<span>(</span> ost.<span>str</span><span>(</span><span>)</span>, factory <span>)</span>;<br><span>}</span></pre>  <p>   当层状结构构建好后，就可以调用makeTest方法，创建待运行的测试实例了，请留意morning的注释：   </p>  <pre>Test *<br>TestFactoryRegistry::<span>makeTest</span><span>(</span><span>)</span><br><span>{</span><br>  <span>// 创建一个测试包，并冠以m_name的名称</span><br>  TestSuite *suite = <span>new</span> TestSuite<span>(</span> m_name <span>)</span>;<br>  <span>// 调用addTestToSuite，以将其下所属的测试实例添加到suite中</span><br>  addTestToSuite<span>(</span> suite <span>)</span>;<br>  <span>// 返回测试包对应的指针</span><br>  <span>return</span> suite;<br><span>}</span><br>&nbsp;<br><span>void</span> <br>TestFactoryRegistry::<span>addTestToSuite</span><span>(</span> TestSuite *suite <span>)</span><br><span>{</span><br>  <span>// 遍历其下所属的各个TestFactory实例</span><br>  <span>for</span> <span>(</span> Factories::<span>iterator</span> it = m_factories.<span>begin</span><span>(</span><span>)</span>; <br>        it != m_factories.<span>end</span><span>(</span><span>)</span>; <br>        ++it <span>)</span><br>  <span>{</span><br>    TestFactory *factory = <span>(</span>*it<span>)</span>.<span>second</span>;<br>    <span>// 调用factory的makeTest方法创建测试实例</span><br>    <span>// 将指向实例的指针添加到suite中</span><br>    <span>// makeTest的调用可能形成连锁反应</span><br>    suite-&gt;addTest<span>(</span> factory-&gt;makeTest<span>(</span><span>)</span> <span>)</span>;<br>  <span>}</span><br>  <span>// 当所有的factory都遍历完后，即所有的测试实例都被创建成功后</span><br>  <span>// 整个测试实例的层状结构也就构建成功了</span><br><span>}</span></pre>  <p>   以下对CppUnit的注册机制作一个简单的小结：   </p>  <ul><li><div>   NamedRegistries以“线性”方式管理着所有的类工厂注册项——TestFactoryRegistry，负责维护其生命周期</div>  </li><li><div>   一个TestFactoryRegistry对应一个类工厂实例，其下可能包含一系列的类工厂实例，构成层状结构</div>  </li><li><div>   TestFactory(s)可以注册到NamedRegistries中，也可以不注册，它们要么被NamedRegistries销毁，要么被其所属  之TestFactoryRegistry销毁</div>  </li><li><div>   所有的类工厂都注册完毕后，TestFactoryRegistry::makeTest方法的一次调用，将形成连锁反映（即递归调用），以创建一组具有  层状结构的测试实例 </div>  </li></ul>    <p>   以下提供几个使用TestFactoryRegistry类的例子，以加深认识：   </p>  <pre><span>// 例1：创建一个空的测试包，并将与之对应的类工厂注册项注册到NamedRegistries中</span><br>CppUnit::<span>TestFactoryRegistry</span> &amp;registry = CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span><span>)</span>;<br>CppUnit::<span>TestSuite</span> *suite = registry.<span>makeTest</span><span>(</span><span>)</span>;<br>&nbsp;<br><span>// 例2：创建一个名为“Math”的测试包，并将与之对应的类工厂注册项注册到NamedRegistries中</span><br>CppUnit::<span>TestFactoryRegistry</span> &amp;mathRegistry = CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span> <span>"Math"</span> <span>)</span>;<br>CppUnit::<span>TestSuite</span> *mathSuite = mathRegistry.<span>makeTest</span><span>(</span><span>)</span>;<br>&nbsp;<br><span>// 例3：创建一个名为“All tests”的测试包，并将名为“Graph”和“Math”的测试包作为“All tests”测试包的子项</span><br><span>// 与全部三个测试包对应的类工厂注册项都被注册到NamedRegistries中</span><br>CppUnit::<span>TestSuite</span> *rootSuite = <span>new</span> CppUnit::<span>TestSuite</span><span>(</span> <span>"All tests"</span> <span>)</span>;<br>rootSuite-&gt;addTest<span>(</span> CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span> <span>"Graph"</span> <span>)</span>.<span>makeTest</span><span>(</span><span>)</span> <span>)</span>;<br>rootSuite-&gt;addTest<span>(</span> CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span> <span>"Math"</span> <span>)</span>.<span>makeTest</span><span>(</span><span>)</span> <span>)</span>;<br>CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span><span>)</span>.<span>addTestToSuite</span><span>(</span> rootSuite <span>)</span>;<br>&nbsp;<br><span>// 例4：例3的另一中实现方式</span><br>CppUnit::<span>TestFactoryRegistry</span> &amp;registry = CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span><span>)</span>;<br>registry.<span>registerFactory</span><span>(</span> CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span> <span>"Graph"</span> <span>)</span> <span>)</span>;<br>registry.<span>registerFactory</span><span>(</span> CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span> <span>"Math"</span> <span>)</span> <span>)</span>;<br>CppUnit::<span>TestSuite</span> *suite = registry.<span>makeTest</span><span>(</span><span>)</span>;</pre>      <h4><a rel="nofollow"     >TestSuiteFactory</a></h4>  <div>    <p>  相关文件：TestSuiteFactory.h  </p>    <p>  模板类，派生自TestFactory，是TestFixture的类工厂，并且该TestFixture必须实现一个静态的suite方法，以便在覆盖  TestFactory的makeTest时调用：   </p>  <pre><span>// 此处的TestCaseType就是一个TestFixture</span><br>template&lt;typename TestCaseType&gt;<br><span>class</span> TestSuiteFactory : <span>public</span> TestFactory<br><span>{</span><br><span>public</span>:<br>  <span>virtual</span> Test *makeTest<span>(</span><span>)</span><br>  <span>{</span><br>    <span>return</span> TestCaseType::<span>suite</span><span>(</span><span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  </div>    <h4><a rel="nofollow"     >TestSuiteBuilder</a></h4>  <div>    <p>  相关文件：TestSuiteBuilder.h  </p>    <p>  模板类，用以将一系列测试添加到一个测试包中。所有加入该测试包的测试，其固有名称之前都会被加上测试包的名称，形成类似如下的测试名  称：MyTestSuiteName.myTestName，前者为测试包的名称，后者为测试本身的名称。  </p>    <p>  TestSuiteBuilder内部维护了一个m_suite指针以指向对应的测试包实例，这是一个Smart   Pointer，因此其生命周期无需手工操控，而是由TestSuiteBuilder来维护：   </p>  <pre>std::<span>auto_ptr</span>&lt;TestSuite&gt; m_suite;</pre>  <p>   至于m_suite所指的对象，可以由TestSuiteBuilder自己创建，也可以从外面传入，全凭你选择调用ctor的哪个版本了：   </p>  <pre><span>// 使用type_info生成测试包的名称</span><br><span>#if CPPUNIT_USE_TYPEINFO_NAME</span><br>TestSuiteBuilder<span>(</span><span>)</span> : <br>    m_suite<span>(</span> <span>new</span> TestSuite<span>(</span> <br>        TypeInfoHelper::<span>getClassName</span><span>(</span> <span>typeid</span><span>(</span>Fixture<span>)</span> <span>)</span>  <span>)</span> <span>)</span><br><span>{</span><br><span>}</span><br><span>#endif</span><br>&nbsp;<br>TestSuiteBuilder<span>(</span> TestSuite *suite <span>)</span> : m_suite<span>(</span> suite <span>)</span> <br><span>{</span><br><span>}</span><br>&nbsp;<br>TestSuiteBuilder<span>(</span>std::<span>string</span> name<span>)</span> : m_suite<span>(</span> <span>new</span> TestSuite<span>(</span>name<span>)</span> <span>)</span> <br><span>{</span><br><span>}</span></pre>  <p>   添加测试的方法是简单地调用m_suite的addTest：   </p>  <pre><span>void</span> addTest<span>(</span> Test *test <span>)</span><br><span>{</span><br>  m_suite-&gt;addTest<span>(</span> test <span>)</span>;<br><span>}</span></pre>  <p>   此外，为了方便使用，TestSuiteBuilder还提供了几个用于添加TestCaller的方法，它们调用   makeTestName以生成测试名称，最终都将调用addTest。其中，Fixture是TestSuiteBuilder的模板类型参数，   TestMethod的定义如下：   </p>  <pre><span>typedef</span> <span>void</span> <span>(</span>Fixture::<span>*TestMethod</span><span>)</span><span>(</span><span>)</span>;</pre>  <p>   至于TestCaller，稍后会讲到：   </p>  <pre><span>void</span> addTestCaller<span>(</span>std::<span>string</span> methodName, <br>                   TestMethod testMethod <span>)</span><br><span>{</span><br>  Test *test = <br>      <span>new</span> TestCaller&lt;Fixture&gt;<span>(</span> makeTestName<span>(</span> methodName <span>)</span>, <br>                               testMethod <span>)</span>;<br>  addTest<span>(</span> test <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> addTestCaller<span>(</span>std::<span>string</span> methodName, <br>                   TestMethod testMethod, <br>                   Fixture *fixture <span>)</span><br><span>{</span><br>  Test *test = <br>      <span>new</span> TestCaller&lt;Fixture&gt;<span>(</span> makeTestName<span>(</span> methodName <span>)</span>, <br>                               testMethod,<br>                               fixture<span>)</span>;<br>  addTest<span>(</span> test <span>)</span>;<br><span>}</span><br>&nbsp;<br>template&lt;typename ExceptionType&gt;<br><span>void</span> addTestCallerForException<span>(</span>std::<span>string</span> methodName, <br>                               TestMethod testMethod, <br>                               Fixture *fixture,<br>                               ExceptionType *dummyPointer <span>)</span><br>                               <span>// dummyPointer本身没有实际作用，此处只为获取其所属类型</span><br><span>{</span><br>  Test *test = <span>new</span> TestCaller&lt;Fixture,ExceptionType&gt;<span>(</span> <br>                               makeTestName<span>(</span> methodName <span>)</span>, <br>                               testMethod,<br>                               fixture<span>)</span>;<br>  addTest<span>(</span> test <span>)</span>;<br><span>}</span></pre>  <p>   makeTestName的定义如下：   </p>  <pre>std::<span>string</span> makeTestName<span>(</span> <span>const</span> std::<span>string</span> &amp;methodName <span>)</span><br><span>{</span><br>  <span>return</span> m_suite-&gt;getName<span>(</span><span>)</span> + <span>"."</span> + methodName;<br><span>}</span></pre>  <p>   为了便于外界访问m_suite指针，TestSuiteBuilder还提供了如下辅助方法：   </p>  <pre>TestSuite *suite<span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_suite.<span>get</span><span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br>TestSuite *takeSuite<span>(</span><span>)</span><br><span>{</span><br>  <span>return</span> m_suite.<span>release</span><span>(</span><span>)</span>;<br><span>}</span></pre>  </div>    <h4><a rel="nofollow"     >TestCaller</a></h4>  <div>    <p>  相关文件：TestCaller.h  </p>    <p>  在前面以及core部分曾经多次提到TestCaller，此类的作用是根据一个fixture创建一个测试用例。当你需要单独运行某个测试，或者要将其  添加到某个测试包中时，你就可以使用TestCaller。一个TestCaller仅对应一个   Test类，该Test类和一个TestFixture相关联。下面是一个演示的例子：   </p>  <pre><span>// 一个TestFixture，并包含了test method(s)</span><br><span>class</span> MathTest : <span>public</span> CppUnit::<span>TestFixture</span> <span>{</span><br>    ...<br>  <span>public</span>:<br>    <span>void</span>         setUp<span>(</span><span>)</span>;<br>    <span>void</span>         tearDown<span>(</span><span>)</span>;<br>&nbsp;<br>    <span>void</span>         testAdd<span>(</span><span>)</span>;<br>    <span>void</span>         testSubtract<span>(</span><span>)</span>;<br><span>}</span>;<br>&nbsp;<br>CppUnit::<span>Test</span> *MathTest::<span>suite</span><span>(</span><span>)</span> <span>{</span><br>  CppUnit::<span>TestSuite</span> *suite = <span>new</span> CppUnit::<span>TestSuite</span>;<br>&nbsp;<br>  <span>// 将MathTest::testAdd加入TestCaller，并将该TestCaller加入测试包中</span><br>  suite-&gt;addTest<span>(</span> <span>new</span> CppUnit::<span>TestCaller</span>&lt;MathTest&gt;<span>(</span> <span>"testAdd"</span>, testAdd <span>)</span> <span>)</span>;<br>  <span>return</span> suite;<br><span>}</span></pre>  <p>   你可是使用TestCaller，将任意一个test方法和某个TestFixture绑定在一起，只要该test方法满足如下形式的定义：   </p>  <pre><span>void</span> testMethod<span>(</span><span>void</span><span>)</span>;</pre>  <p>   TestCaller其实是一个模板类，它派生自TestCase，有两个模板类型参数，前一个参数代表了   TestFixture类，后一个参数代表某个异常类，缺省类型为NoExceptionExpected，至于该参数的作用，稍后便知分晓。关于   TestCase，请见core部分：   </p>  <pre><span>template</span> &lt;typename Fixture, <br>   <span>typename</span> ExpectedException = NoExceptionExpected&gt;<br><span>class</span> TestCaller : <span>public</span> TestCase<br><span>{</span><br>  <span>//...</span><br><span>}</span>;</pre>  <p>   TestCaller有三个private属性的成员变量：   </p>  <pre>Fixture *m_fixture;     <span>// 指向TestFixture实例的指针</span><br><span>bool</span> m_ownFixture;      <span>// 若为true，则由TestCaller负责维护m_fixture的生命周期</span><br>TestMethod m_test;      <span>// 指向某个test方法的函数指针</span></pre>  <p>   TestMethod的定义如下：   </p>  <pre><span>typedef</span> <span>void</span> <span>(</span>Fixture::<span>*TestMethod</span><span>)</span><span>(</span><span>)</span>;</pre>  <p>   正是因为有如上定义，才限制了TestCaller只能支持形参和返回值均为为void类型的test方法。  </p>    <p>  来看一下TestCaller的ctor和dtor，你会发现，对于Fixture的安置工作，CppUnit的实现者可谓细心周到：   </p>  <pre><span>// 由TestCaller创建fixture，负责维护其生命周期</span><br>TestCaller<span>(</span> std::<span>string</span> name, TestMethod test <span>)</span> :<br>            TestCase<span>(</span> name <span>)</span>, <br>            m_ownFixture<span>(</span> <span>true</span> <span>)</span>,<br>            m_fixture<span>(</span> <span>new</span> Fixture<span>(</span><span>)</span> <span>)</span>,<br>            m_test<span>(</span> test <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br><span>// 由外界传入fixture，TestCaller不负责维护其生命周期</span><br>TestCaller<span>(</span> std::<span>string</span> name, TestMethod test, Fixture&amp; fixture<span>)</span> :<br>            TestCase<span>(</span> name <span>)</span>, <br>            m_ownFixture<span>(</span> <span>false</span> <span>)</span>,<br>            m_fixture<span>(</span> &amp;fixture <span>)</span>,<br>            m_test<span>(</span> test <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br><span>// 由外界传入fixture，由TestCaller负责维护其生命周期</span><br>TestCaller<span>(</span> std::<span>string</span> name, TestMethod test, Fixture* fixture<span>)</span> :<br>            TestCase<span>(</span> name <span>)</span>, <br>            m_ownFixture<span>(</span> <span>true</span> <span>)</span>,<br>            m_fixture<span>(</span> fixture <span>)</span>,<br>            m_test<span>(</span> test <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br><span>// 根据m_ownFixture，决定是否销毁m_fixture</span><br>~TestCaller<span>(</span><span>)</span> <br><span>{</span><br>  <span>if</span> <span>(</span>m_ownFixture<span>)</span><br>    <span>delete</span> m_fixture;<br><span>}</span></pre>  <p>   作为TestCaller的基类，TestCase派生自Test和TestFixture，因此TestCaller有义务实现如下三个虚函数。   </p>  <pre><span>void</span> setUp<span>(</span><span>)</span><br><span>{</span><br>  <span>// 简单地调用了m_fixture的setUp方法</span><br>  m_fixture-&gt;setUp <span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> tearDown<span>(</span><span>)</span><br><span>{</span><br>  <span>// 简单地调用了m_fixture的tearDown方法</span><br>  m_fixture-&gt;tearDown <span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> runTest<span>(</span><span>)</span><br><span>{</span><br>  <span>// 调用了m_fixture的一个test方法</span><br>  <span>// 由此可见：</span><br>  <span>// - test方法必须在Fixture类中定义</span><br>  <span>// - 若Fixture类中存在多个test方法，则需一一建立与之对应的TestCaller</span><br>  <span>try</span> <span>{</span><br>    <span>(</span>m_fixture-&gt;*m_test<span>)</span><span>(</span><span>)</span>;<br>  <span>}</span><br>  <span>catch</span> <span>(</span> ExpectedException &amp; <span>)</span> <span>{</span><br>    <span>return</span>;<br>  <span>}</span><br>&nbsp;<br>  ExpectedExceptionTraits&lt;ExpectedException&gt;::<span>expectedException</span><span>(</span><span>)</span>;<br><span>}</span></pre>  <p>     这里不得不提到辅助类ExpectedExceptionTraits，还有前面出现过的NoExceptionExpected，它们和  TestCaller一起被定以在同一个文件里。   </p>  <pre>template&lt;typename ExceptionType&gt;<br><span>struct</span> ExpectedExceptionTraits<br><span>{</span><br>  <span>static</span> <span>void</span> expectedException<span>(</span><span>)</span><br>  <span>{</span><br><span>#if CPPUNIT_USE_TYPEINFO_NAME</span><br>    std::<span>string</span> message<span>(</span> <span>"Expected exception of type "</span> <span>)</span>;<br>    message += TypeInfoHelper::<span>getClassName</span><span>(</span> <span>typeid</span><span>(</span> ExceptionType <span>)</span> <span>)</span>;<br>    message += <span>", but got none"</span>;<br><span>#else</span><br>    std::<span>string</span> message<span>(</span> <span>"Expected exception but got none"</span> <span>)</span>;<br><span>#endif</span><br>    throw Exception<span>(</span> message <span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  <p>   ExpectedExceptionTraits只有一个static方法，其唯一的作用是抛出一个   Exception类型的异常，并附带一个说明信息，指出某个预计产生的异常并未出现，该预计的异常由ExpectedExceptionTraits的  模板类型参数来指定。关于Exception，请见core部分。结合前面出现过的TestCaller::runTest的行为，我们可以得出如下结  论：  </p>    <p>  通常情况下，如果调用m_fixture的test方法时，没有抛出任何异常，或者抛出的不是   ExpectedException类型的异常，则ExpectedExceptionTraits的expectedException方法会产生一个  异常来指出这一错误。其中的ExpectedException，由TestCaller的第二个类型参数来指定。  </p>    <p>  再看一下NoExceptionExpected的定义，它被作为TestCaller的第二个类型参数的缺省类型：   </p>  <pre><span>class</span> CPPUNIT_API NoExceptionExpected<br><span>{</span><br><span>private</span>:<br>  <span>// 防止此类被实例化</span><br>  NoExceptionExpected<span>(</span><span>)</span>;<br><span>}</span>;</pre>  <p>   什么事都不做！是的，NoExceptionExpected只是一个Marker   class，它用来表明，TestCaller在任何时候都不会对运行test方法时所抛出的异常做预期性检查。当然，光有了   NoExceptionExpected还不够，还需要定义一个ExpectedExceptionTraits的特化版本：   </p>  <pre>template&lt;&gt;<br><span>struct</span> ExpectedExceptionTraits&lt;NoExceptionExpected&gt;<br><span>{</span><br>  <span>static</span> <span>void</span> expectedException<span>(</span><span>)</span><br>  <span>{</span><br>  <span>}</span><br><span>}</span>;</pre>  <p>   同样是什么事都没做，再次结合TestCaller::runTest的行为，我们就可以得出如下结论：  </p>    <p>  当TestCaller的第二个类型参数为NoExceptionExpected时，如果调用m_fixture的test方法时   </p>  <ul><li><div>   没有抛出任何异常，则ExpectedExceptionTraits的expectedException方法（特化版）将被调用，并且不抛出任何异  常；</div>  </li><li><div>   有异常被抛出，则一定不是NoExceptionExpected（因为那个private ctor），原样继续向外抛出此异常。 </div>  </li></ul>    </div>    <h4><a rel="nofollow"     >AutoRegisterSuite</a></h4>  <div>    <p>  相关文件：AutoRegisterSuite.h  </p>    <p>  AutoRegisterSuite是一个模板类，其作用是自动注册指定类型的测试包，不过你不需要直接使用该类，而代之以如下的两个宏：   </p>  <pre>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span><span>)</span><br>CPPUNIT_TEST_SUITE_NAMED_REGISTRATION<span>(</span><span>)</span></pre>  <p>   关于宏，在随后的HelperMacros部分将会有更为详细的说明。  </p>    <p>  AutoRegisterSuite的全部内容是两个不同版本的ctor：   </p>  <pre>AutoRegisterSuite<span>(</span><span>)</span><br><span>{</span><br>  <span>// 利用TestSuiteFactory创建一个类工厂实例factory</span><br>  TestFactory *factory = <span>new</span> TestSuiteFactory&lt;TestCaseType&gt;<span>(</span><span>)</span>;<br>  <span>// 调用getRegistry()，在NamedRegistries中注册一个TestFactoryRegistry实例，</span><br>  <span>// 注册项的名称为“All Tests”，并调用该实例的registerFactory，将factory注册为</span><br>  <span>// 其下所属的一个类工厂实例</span><br>  TestFactoryRegistry::<span>getRegistry</span><span>(</span><span>)</span>.<span>registerFactory</span><span>(</span> factory <span>)</span>;<br><span>}</span><br>&nbsp;<br>AutoRegisterSuite<span>(</span> <span>const</span> std::<span>string</span> &amp;name <span>)</span><br><span>{</span><br>  <span>// 除了注册项的名称由外部指定外，其余同前</span><br>  TestFactory *factory = <span>new</span> TestSuiteFactory&lt;TestCaseType&gt;<span>(</span><span>)</span>;<br>  TestFactoryRegistry::<span>getRegistry</span><span>(</span> name <span>)</span>.<span>registerFactory</span><span>(</span> factory <span>)</span>;<br><span>}</span></pre>  <p>   这里的TestCaseType是AutoRegisterSuite的模板类型参数。前面曾经提到过的   TestSuiteFactory，其makeTest方法会调用TestCaseType的suite方法以创建测试实例，至于makeTest的调用  时机，则和TestFactoryRegistry的makeTest方法有关。   </p>    </div>    <h3><a rel="nofollow"     >HelperMacros</a></h3>  <div>    </div>    <h4><a rel="nofollow"     >HelperMacros</a></h4>  <div>    <p>   相关文件：HelperMacros.h  </p>    <p>  这里定义了一系列宏，它们为简化CppUnit的使用提供了诸多便利。其中，宏CPPUNIT_TEST_SUITE(),   宏CPPUNIT_TEST()和宏CPPUNIT_TEST_SUITE_END()被设计用来简化创建测试包的过程。比如：   </p>  <pre><span>class</span> MyTest : <span>public</span> CppUnit::<span>TestFixture</span> <span>{</span><br>  CPPUNIT_TEST_SUITE<span>(</span> MyTest <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testEquality <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testSetName <span>)</span>;<br>  CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;<br><span>public</span>:<br>  <span>void</span> testEquality<span>(</span><span>)</span>;<br>  <span>void</span> testSetName<span>(</span><span>)</span>;<br><span>}</span>;</pre>  <p>   这些宏在MyTest内部定义了两个方法，第一个方法是一个名为registerTests的辅助函数，你无需直接调用。第二个方法的定义如下：   </p>  <pre><span>static</span> CppUnit::<span>TestSuite</span> *suite<span>(</span><span>)</span>;</pre>  <p>     该方法返回一个指向测试包实例的指针，该测试包对应的测试实例就是由CPPUNIT_TEST()指定的。比起手工调用suite()，使用  CPPUNIT_TEST_SUITE_REGISTRATION()更为方便，它会创建一个static属性的   AutoRegisterSuite类型变量，该变量将自动把测试包实例注册到NamedRegistries中。NamedRegistries中包含  了所有被注册的测试包实例：   </p>  <pre>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span> MyTest <span>)</span>;<br>CppUnit::<span>Test*</span> tp =<br>  CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span><span>)</span>.<span>makeTest</span><span>(</span><span>)</span>;</pre>  <p>   上述宏还支持带模板类型参数的测试类，比如：   </p>  <pre>template&lt;typename CharType&gt;<br><span>class</span> StringTest : <span>public</span> CppUnit::<span>TestFixture</span> <span>{</span><br>  CPPUNIT_TEST_SUITE<span>(</span> StringTest <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testAppend <span>)</span>;<br>  CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;<br><span>public</span>:  <br>  ...<br><span>}</span>;</pre>  <p>   然后，可以在StringTest类的实现代码（即.cpp文件）中加上如下代码：   </p>  <pre>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span> StringTest&lt;char&gt; <span>)</span>;<br>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span> StringTest&lt;wchar_t&gt; <span>)</span>;</pre>  <p>     下面为你逐一讲解各个宏的实现机理。同时为了便于理解，我以前面的MyTest为例，分别给出宏展开前后的代码，并在结尾处给出一个小结。首先是  CPPUNIT_TEST_SUITE()的定义：   </p>  <pre><span>#define CPPUNIT_TEST_SUITE( ATestFixtureType )                            \</span><br>  <span>private</span>:                                                                \<br>    <span>typedef</span> ATestFixtureType __ThisTestFixtureType;                       \<br>    <span>class</span> ThisTestFixtureFactory : <span>public</span> CppUnit::<span>TestFixtureFactory</span>     \<br>    <span>{</span>                                                                     \<br>      <span>virtual</span> CppUnit::<span>TestFixture</span> *makeFixture<span>(</span><span>)</span>                         \<br>      <span>{</span>                                                                   \<br>        <span>return</span> <span>new</span> ATestFixtureType<span>(</span><span>)</span>;                                    \<br>      <span>}</span>                                                                   \<br>    <span>}</span>;                                                                    \<br>  <span>public</span>:                                                                 \<br>    <span>static</span> <span>void</span>                                                           \<br>    registerTests<span>(</span> CppUnit::<span>TestSuite</span> *suite,                             \<br>                   CppUnit::<span>TestFixtureFactory</span> *factory <span>)</span>                 \<br>    <span>{</span>                                                                     \<br>      CppUnit::<span>TestSuiteBuilder</span>&lt;__ThisTestFixtureType&gt; builder<span>(</span> suite <span>)</span>;</pre>  <p>   该宏表明开始定义一个新的测试包，它必须出现在其他宏的前面。以MyTest为例，宏展开前的代码如下：   </p>  <pre>CPPUNIT_TEST_SUITE<span>(</span> MyTest <span>)</span>;</pre>  <p>   展开后的代码如下，此处略去或修改了部分与主体关系不大的代码：   </p>  <pre><span>private</span>:<br>  <span>class</span> ThisTestFixtureFactory : <span>public</span> CppUnit::<span>TestFixtureFactory</span><br>  <span>{</span><br>    <span>virtual</span> CppUnit::<span>TestFixture</span> *makeFixture<span>(</span><span>)</span><br>    <span>{</span><br>      <span>return</span> <span>new</span> MyTest<span>(</span><span>)</span>;<br>    <span>}</span><br>  <span>}</span>;<br><span>public</span>:<br>  <span>static</span> <span>void</span> <br>  registerTests<span>(</span> CppUnit::<span>TestSuite</span> *suite, <br>                 CppUnit::<span>TestFixtureFactory</span> *factory <span>)</span><br>  <span>{</span><br>    CppUnit::<span>TestSuiteBuilder</span>&lt;MyTest&gt; builder<span>(</span> suite <span>)</span>;</pre>  <p>   正如前面提到的，public部分定义了一个static属性的registerTests方法，稍后讲到   CPPUNIT_TEST_SUITE_END()时即会看到其作用。此外，这里还出现了一个inner   class：ThisTestFixtureFactory，它派生自TestFixtureFactory。至于   TestFixtureFactory，有如下定义：   </p>  <pre><span>class</span> TestFixtureFactory<br><span>{</span><br><span>public</span>:<br>  <span>// 创建一个新的TestFixture实例</span><br>  <span>virtual</span> CppUnit::<span>TestFixture</span> *makeFixture<span>(</span><span>)</span> =<span>0</span>;<br><span>}</span>;</pre>  <p>   可见ThisTestFixtureFactory只是覆盖了TestFixtureFactory的纯虚函数   makeFixture，创建了一个MyTest的实例。至于makeFixture的调用时机，则是在CPPUNIT_TEST()处。以下是   CPPUNIT_TEST()的定义：   </p>  <pre><span>#define CPPUNIT_TEST( testMethod )                                           \</span><br>      builder.<span>addTestCaller</span><span>(</span> <span>#testMethod,                                    \</span><br>                             &amp;__ThisTestFixtureType::<span>testMethod</span> ,            \<br>                             <span>(</span>__ThisTestFixtureType*<span>)</span>factory-&gt;makeFixture<span>(</span><span>)</span> <span>)</span></pre>  <p>     该宏用于每次向测试包添加一个测试方法，测试方法必须满足形参和返回值都为void类型。以MyTest的testEquality为例，宏展开前的代码  如下：   </p>  <pre>CPPUNIT_TEST<span>(</span> testEquality <span>)</span>;</pre>  <p>   展开后的代码如下，此处略去或修改了部分与主体关系不大的代码：   </p>  <pre>    builder.<span>addTestCaller</span><span>(</span> <span>"testEquality"</span>, <br>                           &amp;MyTest::<span>testEquality</span>, <br>                           <span>(</span>MyTest*<span>)</span>factory-&gt;makeFixture<span>(</span><span>)</span> <span>)</span></pre>  <p>     这里调用了TestSuiteBuilder的addTestCaller，在TestSuiteBuilder内部所维护的m_suite中添加了一个  测试实例，确切地说是一个TestCaller，该TestCaller是专门用来测试testEquality方法的，这也是为什么测试方法必须满足形  参和返回值都为void类型的原因。关于TestSuiteBuilder和TestCaller，前面已经有过叙述了。  </p>    <p>  再来看一下CPPUNIT_TEST_SUITE_END()的定义：   </p>  <pre><span>#define CPPUNIT_TEST_SUITE_END()                                          \</span><br>      builder.<span>takeSuite</span><span>(</span><span>)</span>;                                                \<br>    <span>}</span>                                                                     \<br>    <span>static</span> CppUnit::<span>TestSuite</span> *suite<span>(</span><span>)</span>                                    \<br>    <span>{</span>                                                                     \<br>      CppUnit::<span>TestSuiteBuilder</span>&lt;__ThisTestFixtureType&gt;                    \<br>          builder __CPPUNIT_SUITE_CTOR_ARGS<span>(</span> ATestFixtureType <span>)</span>;          \<br>      ThisTestFixtureFactory factory;                                     \<br>      __ThisTestFixtureType::<span>registerTests</span><span>(</span> builder.<span>suite</span><span>(</span><span>)</span>, &amp;factory <span>)</span>;  \<br>      <span>return</span> builder.<span>takeSuite</span><span>(</span><span>)</span>;                                         \<br>    <span>}</span>                                                                     \<br>  <span>private</span>: <span>/* 此处的typedef并无实际作用，只是为了使该宏可以以分号结束 */</span>            \<br>    <span>typedef</span> ThisTestFixtureFactory __ThisTestFixtureFactory</pre>  <p>     该宏表明一个测试包定义的结束，因为末尾那个无关痛痒的typdef，其后的成员变量隐式情况下都将具有private属性。  __CPPUNIT_SUITE_CTOR_ARGS()宏稍后会提到，此处并不影响理解，以MyTest为例，宏展开前的代码如下：   </p>  <pre>CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;</pre>  <p>  展开后的代码如下，此处略去或修改了部分与主体关系不大的代码：   </p>  <pre>    builder.<span>takeSuite</span><span>(</span><span>)</span>;<br>  <span>}</span><br>  <span>static</span> CppUnit::<span>TestSuite</span> *suite<span>(</span><span>)</span><br>  <span>{</span><br>    CppUnit::<span>TestSuiteBuilder</span>&lt;MyTest&gt; builder;<br>    ThisTestFixtureFactory factory;<br>    MyTest::<span>registerTests</span><span>(</span> builder.<span>suite</span><span>(</span><span>)</span>, &amp;factory <span>)</span>;<br>    <span>return</span> builder.<span>takeSuite</span><span>(</span><span>)</span>;<br>  <span>}</span></pre>  <p>   这里出现了前面曾经提到的static属性的suite方法，它在构建了TestSuiteBuilder和   ThisTestFixtureFactory之后，便开始调用前面提到的那个registerTests方法，其结果是向builder内含的   m_suite中加入若干TestCaller实例。最后，它将返回指向该m_suite实例的指针。  </p>    <p>  还有一个需要提到的关键的宏是CPPUNIT_TEST_SUITE_REGISTRATION()，其定义如下：   </p>  <pre><span>#define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \</span><br>  <span>static</span> CppUnit::<span>AutoRegisterSuite</span>&lt; ATestFixtureType &gt;          \<br>             __CPPUNIT_MAKE_UNIQUE_NAME<span>(</span>__autoRegisterSuite <span>)</span></pre>  <p>  该宏声明了一个static属性的全局变量，该变量将自动把测试包实例注册到NamedRegistries中。  __CPPUNIT_MAKE_UNIQUE_NAME()宏稍后会提到，此处并不影响理解，以MyTest为例，宏展开前的代码如下：   </p>  <pre>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span> MyTest <span>)</span>;</pre>  <p>  展开后的代码如下，此处略去或修改了部分与主体关系不大的代码：   </p>  <pre><span>// __autoRegisterSuite123是一个变量名，后面的123代表了当前代码行号，</span><br><span>// 至于该变量名是如何产生的，__CPPUNIT_MAKE_UNIQUE_NAME部分将会提到</span><br><span>static</span> CppUnit::<span>AutoRegisterSuite</span>&lt; MyTest &gt; __autoRegisterSuite123</pre>  <p>  以下就上面的内容给出一个小结。类MyTest在宏展开前的代码大致如下：   </p>  <pre><span>// MyTest.h</span><br><span>class</span> MyTest : <span>public</span> CppUnit::<span>TestFixture</span> <span>{</span><br>  CPPUNIT_TEST_SUITE<span>(</span> MyTest <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testEquality <span>)</span>;<br>  CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;<br><span>public</span>:<br>  <span>void</span> testEquality<span>(</span><span>)</span>;<br><span>}</span>;<br>&nbsp;<br><span>// MyTest.cpp</span><br>CPPUNIT_TEST_SUITE_REGISTRATION<span>(</span> MyTest <span>)</span>;</pre>  <p>   展开后的代码如下：   </p>  <pre>// MyTest.h<br>class MyTest : public CppUnit::TestFixture {<br>private:<br>  class ThisTestFixtureFactory : public CppUnit::TestFixtureFactory<br>  {<br>    virtual CppUnit::TestFixture *makeFixture()<br>    {<br>      return new MyTest();<br>    }<br>  };<br>public:<br>  static void <br>  registerTests( CppUnit::TestSuite *suite, <br>                 CppUnit::TestFixtureFactory *factory )<br>  {<br>    CppUnit::TestSuiteBuilder&lt;MyTest&gt; builder( suite );<br>    builder.addTestCaller( "testEquality", <br>                           &amp;MyTest::testEquality, <br>                           (MyTest*)factory-&gt;makeFixture() ) <br>    builder.takeSuite();<br>  }<br>  static CppUnit::TestSuite *suite()<br>  {<br>    CppUnit::TestSuiteBuilder&lt;MyTest&gt; builder;<br>    ThisTestFixtureFactory factory;<br>    MyTest::registerTests( builder.suite(), &amp;factory );<br>    return builder.takeSuite();<br>  }<br>public:<br>  void testEquality();<br>};<br><br>// MyTest.cpp<br>static CppUnit::AutoRegisterSuite&lt; MyTest &gt; __autoRegisterSuite123<br></pre>    <p>   并在适当的地方，添加如下代码：   </p>  <pre>CppUnit::<span>TestFactoryRegistry</span> &amp;registry = <br>    CppUnit::<span>TestFactoryRegistry</span>::<span>getRegistry</span><span>(</span><span>)</span>; <span>// 对应“All Tests”的注册项</span><br>registry.<span>makeTest</span><span>(</span><span>)</span>;</pre>  <p>   由此得到测试用例创建的完整流程如下：   </p>  <pre> 1. 定义AutoRegisterSuite&lt;MyTest&gt;类型的static全局变量，在其ctor中完成向NamedRegistries的注册，即在NamedRegistries中注册一个名为“All Tests”的注册项，并在其下注册一个TestSuiteFactory&lt;MyTest&gt;类型的实例（但该实例并未放在 NamedRegistries中）<br> 2. 取得NamedRegistries中的对应“All Tests”的注册项，并调用makeTest方法<br>        * 2.1 创建一个TestSuite的实例<br>        * 2.2 得到那个TestSuiteFactory&lt;MyTest&gt;类型的实例，并调用其makeTest方法，以得到一个真正的测试用例<br>        * 2.3 将测试用例添加到先前定义的那个TestSuite实例中（通过调用其addTest方法实现） </pre>    <p>   关于2.2，有进一步的说明：  </p>    <p>  TestSuiteFactory&lt;MyTest&gt;的makeTest方法事实上调用了MyTest的suite方法，而该suite方法正  是前面运用CPPUNIT_TEST_SUITE_END()所产生的，进入suite之后，流程如下：   </p>  <pre> 1. 创建TestSuiteBuilder&lt;MyTest&gt;类型和ThisTestFixtureFactory类型的变量builder、factory<br> 2. 将builder内含的测试包m_suite和factory作为实参，调用registerTests方法<br> 3. 调用TestSuiteBuilder&lt;MyTest&gt;的addTestCaller，创建一个TestCaller实例，该实例对应一个测试方法（比如：本例中的testEquality） </pre>    <p>     至此，整个测试用例的创建过程圆满结束。并且，如果使用多个CPPUINT_TEST宏即可注册多个测试方法，每个测试方法都有一个TestCaller  的实例与之对应。  </p>    <p>  再来看看HelperMacros中的其他几个宏。与CPPUNIT_TEST_SUITE()类似的另一个宏是  CPPUNIT_TEST_SUB_SUITE()，它同样是用于表明开始定义一个新的测试包，不过它仅在如下场合使用：基类中已经通过使用   CPPUNIT_TEST_SUITE()或CPPUNIT_TEST_SUB_SUITE()定义了测试包。其定义如下：   </p>  <pre><span>#define CPPUNIT_TEST_SUB_SUITE( ATestFixtureType, ASuperClass )  \</span><br>  <span>private</span>:                                                       \<br>    <span>typedef</span> ASuperClass __ThisSuperClassType;                    \<br>    CPPUNIT_TEST_SUITE<span>(</span> ATestFixtureType <span>)</span>;                      \<br>      __ThisSuperClassType::<span>registerTests</span><span>(</span> suite, factory <span>)</span></pre>  <p>     此处首先调用了CPPUNIT_TEST_SUITE()，随后是调用基类的registerTests方法，如此一来，基类中定义的所有  TestCaller都将被自动添加到当前派生类中所定义的这个测试包中，即最后的结果是：当前定义的测试包中包含了基类和派生类中出现的所有测试方法。  来看一个使用CPPUNIT_TEST_SUB_SUITE()的例子：   </p>  <pre><span>class</span> MySubTest : <span>public</span> MyTest <span>{</span><br>  CPPUNIT_TEST_SUB_SUITE<span>(</span> MySubTest, MyTest <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testAdd <span>)</span>;<br>  CPPUNIT_TEST<span>(</span> testSub <span>)</span>;<br>  CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;<br><span>public</span>:<br>  <span>void</span> testAdd<span>(</span><span>)</span>;<br>  <span>void</span> testSub<span>(</span><span>)</span>;<br><span>}</span>;</pre>  <p>   与CPPUNIT_TEST()类似的还有另两个宏，它们分别是CPPUNIT_TEST_EXCEPTION()和   CPPUNIT_TEST_FAIL()。CPPUNIT_TEST_EXCEPTION()也用于向测试包添加一个测试方法，与   CPPUNIT_TEST()不同的是，它指定了一个预期会抛出的异常，若该异常成功产生，则一切照旧，否则便会导致测试失败。其定义如下：   </p>  <pre><span>#define CPPUNIT_TEST_EXCEPTION( testMethod, ExceptionType )                   \</span><br>      builder.<span>addTestCallerForException</span><span>(</span> <span>#testMethod,                         \</span><br>                             &amp;__ThisTestFixtureType::<span>testMethod</span> ,             \<br>                             <span>(</span>__ThisTestFixtureType*<span>)</span>factory-&gt;makeFixture<span>(</span><span>)</span>,  \<br>                             <span>(</span>ExceptionType *<span>)</span><span>NULL</span> <span>)</span>;</pre>  <p>   来看一个使用CPPUNIT_TEST_EXCEPTION()的例子：   </p>  <pre><span>#include &lt;vector&gt;</span><br><span>class</span> MyTest : <span>public</span> CppUnit::<span>TestFixture</span> <span>{</span><br>  CPPUNIT_TEST_SUITE<span>(</span> MyTest <span>)</span>;<br>  CPPUNIT_TEST_EXCEPTION<span>(</span> testVectorAtThrow, std::<span>invalid_argument</span> <span>)</span>;<br>  CPPUNIT_TEST_SUITE_END<span>(</span><span>)</span>;<br><span>public</span>:<br>  <span>void</span> testVectorAtThrow<span>(</span><span>)</span><br>  <span>{</span><br>    std::<span>vector</span>&lt;int&gt; v;<br>    v.<span>at</span><span>(</span> <span>1</span> <span>)</span>;     <span>// 必将抛出std::invalid_argument异常</span><br>  <span>}</span><br><span>}</span>;</pre>  <p>   CPPUNIT_TEST_FAIL()与CPPUNIT_TEST_EXCEPTION()很相似，其定义如下：   </p>  <pre><span>#define CPPUNIT_TEST_FAIL( testMethod ) \</span><br>              CPPUNIT_TEST_EXCEPTION<span>(</span> testMethod, CppUnit::<span>Exception</span> <span>)</span></pre>  <p>   该宏用于向测试包添加一个测试方法，并预期其必定会失败，事实上就是预期其必定会抛出CppUnit::   Exception异常。通常，如果在测试用例中用到了与断言相关的宏时，就可以使用该宏了，关于“与断言相关的宏”请见core部分。来看一个使用   CPPUNIT_TEST_FAIL()的例子：   </p>  <pre>CPPUNIT_TEST_FAIL<span>(</span> testAssertFalseFail <span>)</span>;<br>&nbsp;<br><span>void</span> testAssertFalseFail<span>(</span><span>)</span><br><span>{</span><br>  CPPUNIT_ASSERT<span>(</span> <span>false</span> <span>)</span>;<br><span>}</span></pre>  <p>   与CPPUNIT_TEST_SUITE_REGISTRATION()类似的另一个宏是   CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()。它们都会创建一个AutoRegisterSuite类型的   static全局变量，并在其ctor中，将一个新创建的测试包的类工厂实例注册到NamedRegistries中。所不同的是，   CPPUNIT_TEST_SUITE_REGISTRATION()没有指定注册项的名字，代之以缺省的“All   Tests”，而CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()则通过第二个参数指定了注册项的名字。其定义如下：   </p>  <pre><span>#define CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ATestFixtureType, suiteName ) \</span><br>  <span>static</span> CppUnit::<span>AutoRegisterSuite</span>&lt; ATestFixtureType &gt;                      \<br>             __CPPUNIT_MAKE_UNIQUE_NAME<span>(</span>__autoRegisterSuite <span>)</span><span>(</span>suiteName<span>)</span></pre>  <p>   来看一个使用CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()的例子：   </p>  <pre><span>// MySuites.h</span><br><span>namespace</span> MySuites <span>{</span><br>  std::<span>string</span> math<span>(</span><span>)</span> <span>{</span> <br>    <span>return</span> <span>"Math"</span>;<br>  <span>}</span><br><span>}</span><br>&nbsp;<br><span>// ComplexNumberTest.cpp</span><br><span>#include "MySuites.h"</span><br>&nbsp;<br>CPPUNIT_TEST_SUITE_NAMED_REGISTRATION<span>(</span> ComplexNumberTest, MySuites::<span>math</span><span>(</span><span>)</span> <span>)</span>;</pre>  <p>   上面的例子中使用了一个static方法返回测试包的名称，比起直接在代码中引入代表测试包名称的字符串（也就是所谓的Hardcoded   String），这样的方式更为灵活。它能使你免于因为拼写错误而无法获得正确的注册项名称。  </p>    <p>  最后，稍带提一下几个次要的宏。在CPPUNIT_TEST_SUITE()中定义   TestSuiteBuilder实例时曾经用到过__CPPUNIT_SUITE_CTOR_ARGS()。该宏在   CPPUNIT_USE_TYPEINFO_NAME被定义的时候（即你所使用的编译器支持RTTI机制），不起任何作用；否则，将返回一个字符串。至于  该字符串的作用，请见TestSuiteBuilder部分的讲解。   </p>  <pre><span>#if CPPUNIT_USE_TYPEINFO_NAME</span><br><span>#  define __CPPUNIT_SUITE_CTOR_ARGS( ATestFixtureType )</span><br><span>#else</span><br><span>#  define __CPPUNIT_SUITE_CTOR_ARGS( ATestFixtureType ) (std::string(#ATestFixtureType))</span><br><span>#endif</span></pre>  <p>   在CPPUNIT_TEST_SUITE_REGISTRATION()和   CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()中曾经用到过__CPPUNIT_MAKE_UNIQUE_NAME   ()。该宏的作用是产生一个唯一的全局性名字，它有一个参数str，将str和__LINE__“粘合”在一起便是最终的结果。其中，__LINE__是  一个隐含的静态变量，代表了当前代码在文件中所处的行号。   </p>  <pre><span>#define __CPPUNIT_CONCATENATE_DIRECT( s1, s2 ) s1##s2</span><br><span>#define __CPPUNIT_CONCATENATE( s1, s2 ) __CPPUNIT_CONCATENATE_DIRECT( s1, s2 )</span><br>&nbsp;<br><span>#define __CPPUNIT_MAKE_UNIQUE_NAME( str ) __CPPUNIT_CONCATENATE( str, __LINE__ )</span></pre>  </div>    <h2><a rel="nofollow"     >扩展部分（Extension）</a></h2>  <div>    <p>  在CppUnit中，除了提供基本的单元测试之外，还增加了很多扩展测试，比如：重复测试（RepeatedTest），正规测试  （OrthodoxTest），这些内容都悉数收录在extension中。   </p>    </div>    <h4><a rel="nofollow"     >TestDecorator</a></h4>  <div>    <p>  相关文件：TestDecorator.h  </p>    <p>  它提供了一种方法，可以不用子类化Test类，同时又能扩展Test类的功能。我们可以派生TestDecorator，并用它来包装Test。其实这种  方法是Decorator   Pattern的一个应用，在GoF中对该pattern有如下描述：动态地给一个对象添加一些额外的职责。就增加功能来说，比生成子类更为灵活。  </p>    <p>  TestDecorator维护了一个指向Test实例的指针，并在ctor中设定。不过该实例的生命期，TestDecorator并不过问：   </p>  <pre><span>protected</span>:<br>    Test        *m_test;</pre>  <p>  随后是四个public函数，其接口与Test的接口完全一致：   </p>  <pre>void        run             (TestResult *result);<br>int         countTestCases  () const;<br>std::string getName         () const;<br>std::string toString        () const;<br></pre>    <p>   函数的实现就是简单的调用m_test的对应接口：   </p>  <pre><span>inline</span> <span>int</span> TestDecorator::<span>countTestCases</span> <span>(</span><span>)</span> <span>const</span><br><span>{</span> <span>return</span> m_test-&gt;countTestCases <span>(</span><span>)</span>; <span>}</span><br>&nbsp;<br><span>inline</span> <span>void</span> TestDecorator::<span>run</span> <span>(</span>TestResult *result<span>)</span><br><span>{</span> m_test-&gt;run <span>(</span>result<span>)</span>; <span>}</span><br>&nbsp;<br>&nbsp;<br><span>inline</span> std::<span>string</span> TestDecorator::<span>toString</span> <span>(</span><span>)</span> <span>const</span><br><span>{</span> <span>return</span> m_test-&gt;toString <span>(</span><span>)</span>; <span>}</span><br>&nbsp;<br>&nbsp;<br><span>inline</span> std::<span>string</span> TestDecorator::<span>getName</span> <span>(</span><span>)</span> <span>const</span><br><span>{</span> <span>return</span> m_test-&gt;getName<span>(</span><span>)</span>; <span>}</span></pre>  <p>   在TestDecorator的派生类中，这些功能将得到扩展。    </p>    </div>    <h4><a rel="nofollow"     >RepeatedTest</a></h4>  <div>    <p>  相关文件：RepeatedTest.h，RepeatedTest.cpp  </p>    <p>  派生自TestDecorator，其功能是对测试重复运行指定的次数（类似于某种强度测试）。private成员变量m_timesRepeat记录了  重复的次数：   </p>  <pre>private:<br>    const int m_timesRepeat;<br></pre>    <p>   该值在ctor中设定：   </p>  <pre>RepeatedTest<span>(</span> Test *test,<span>int</span> timesRepeat <span>)</span> : <br>    TestDecorator<span>(</span> test <span>)</span>, <br>    m_timesRepeat<span>(</span>timesRepeat<span>)</span> <span>{</span><span>}</span></pre>  <p>   这里的test参数，就是所要执行的测试，可能是某个测试用例，也可能是测试包。  </p>    <p>  随后是函数countTestCases、run和toString的子类化版本：   </p>  <pre><span>// 返回本次测试中测试用例的总数</span><br><span>// 总数 = 实际总数 * 重复次数</span><br><span>int</span> RepeatedTest::<span>countTestCases</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> TestDecorator::<span>countTestCases</span> <span>(</span><span>)</span> * m_timesRepeat;<br><span>}</span><br>&nbsp;<br>std::<span>string</span> RepeatedTest::<span>toString</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> TestDecorator::<span>toString</span> <span>(</span><span>)</span> + <span>" (repeated)"</span>;<br><span>}</span><br>&nbsp;<br><span>// 运行测试</span><br><span>// 重复调用基类的run，并在基类中调用m_test的run方法</span><br><span>void</span> RepeatedTest::<span>run</span><span>(</span> TestResult *result <span>)</span><br><span>{</span><br>  <span>for</span> <span>(</span> <span>int</span> n = <span>0</span>; n &lt; m_timesRepeat; n++ <span>)</span><br>  <span>{</span><br>    <span>if</span> <span>(</span> result-&gt;shouldStop<span>(</span><span>)</span> <span>)</span><br>      <span>break</span>;<br>    TestDecorator::<span>run</span><span>(</span> result <span>)</span>;<br>  <span>}</span><br><span>}</span></pre>  </div>    <h4><a rel="nofollow"     >Orthodox</a></h4>  <div>    <p>  相关文件：Orthodox.h  </p>    <p>  该类实现了正规测试的功能。它派生自TestCase，是一个模板类，有一个类型参数ClassUnderTest，代表将要运行的测试。所谓正规测试，  就是对待测类（即ClassUnderTest）执行一组简单的测试，确保其至少具有如下基本操作：   </p>  <ul><li><div> default ctor</div>  </li><li><div> operator==和operator!=</div>  </li><li><div> assignment（即operator=）</div>  </li><li><div> operator!</div>  </li><li><div> safe passage（即copy ctor） </div>  </li></ul>    <p>     若其中任何一项没有通过测试，则模板类就不会实例化。否则，实例化后将检查这些操作的语义是否正确。当你需要确认一组待测类具有相同表现时，采用被模板化  的测试用例非常有用，Orthodox就是一个很好的例子。可以想见，在实际工作中，我们也可以效仿Orthodox的做法，从而“扩展”CppUnit  以适应自己的特定环境。  </p>    <p>  以下代码演示了如何将一个复数类的正规测试添加到测试包中：   </p>  <pre>TestSuite *suiteOfTests = <span>new</span> TestSuite;<br>suiteOfTests-&gt;addTest <span>(</span><span>new</span> ComplexNumberTest <span>(</span><span>"testAdd"</span><span>)</span>;<br>suiteOfTests-&gt;addTest <span>(</span><span>new</span> TestCaller&lt;Orthodox&lt;Complex&gt; &gt; <span>(</span><span>)</span><span>)</span>;  <span>// 非常简单</span></pre>  <p>   来看一下Orthodox的定义：   </p>  <pre><span>template</span> &lt;typename ClassUnderTest&gt; <span>class</span> Orthodox : <span>public</span> TestCase<br><span>{</span><br><span>public</span>:<br>  Orthodox <span>(</span><span>)</span> : TestCase <span>(</span><span>"Orthodox"</span><span>)</span> <span>{</span><span>}</span><br>&nbsp;<br><span>protected</span>:<br>  ClassUnderTest  call <span>(</span>ClassUnderTest object<span>)</span>;<br>  <span>void</span>            runTest <span>(</span><span>)</span>;<br><span>}</span>;</pre>  <p>   唯一需要解释的就是runTest方法，Orthodox是如何检查ClassUnderTest是否符合要求的呢：   </p>  <pre><span>template</span> &lt;typename ClassUnderTest&gt;<br><span>void</span> Orthodox&lt;ClassUnderTest&gt;::<span>runTest</span> <span>(</span><span>)</span><br><span>{</span><br>  <span>// 确保default ctor被定义，否则无法通过编译</span><br>  ClassUnderTest   a, b, c;<br>&nbsp;<br>  <span>// 确保operator==被定义，否则无法通过编译</span><br>  <span>// 同时检查operator==的语义</span><br>  CPPUNIT_ASSERT <span>(</span>a == b<span>)</span>;<br>&nbsp;<br>  <span>// 确保operator!、operator=和operator!=被定义</span><br>  <span>// 否则无法通过编译</span><br>  <span>// 同时检查operator!=的语义</span><br>  b.<span>operator</span>= <span>(</span>a.<span>operator</span>! <span>(</span><span>)</span><span>)</span>;<br>  CPPUNIT_ASSERT <span>(</span>a != b<span>)</span>;<br>&nbsp;<br>  <span>// 检查operator!和operator==的语义</span><br>  b = !!a;<br>  CPPUNIT_ASSERT <span>(</span>a == b<span>)</span>;<br>&nbsp;<br>  b = !a;<br>&nbsp;<br>  <span>// 以下检查copy ctor是否被定义及其语义正确与否</span><br>  c = a;<br>  CPPUNIT_ASSERT <span>(</span>c == call <span>(</span>a<span>)</span><span>)</span>;<br>  c = b;<br>  CPPUNIT_ASSERT <span>(</span>c == call <span>(</span>b<span>)</span><span>)</span>;<br><span>}</span></pre>  <p>   这里的call是辅助函数，“迫使”编译器调用copy ctor，以检查safe passage：   </p>  <pre><span>template</span> &lt;typename ClassUnderTest&gt;<br>ClassUnderTest Orthodox&lt;ClassUnderTest&gt;::<span>call</span> <span>(</span>ClassUnderTest object<span>)</span><br><span>{</span><br>  <span>return</span> object;<br><span>}</span></pre>  <p>   所有的奥妙就在上面这几行代码中。    </p>    </div>    <h4><a rel="nofollow"     >TestSetUp</a></h4>  <div>    <p>  相关文件：TestSetUp.h，TestSetUp.cpp  </p>    <p>  同样派生自TestDecorator，它使测试类具有了SetUp和TearDown的特性。关于这两个特性请见core部分的  TestFixture。  </p>    <p>  该类定义了两个protected属性的虚函数，以供派生类覆盖：   </p>  <pre><span>protected</span>:<br>  <span>virtual</span> <span>void</span> setUp<span>(</span><span>)</span>;<br>  <span>virtual</span> <span>void</span> tearDown<span>(</span><span>)</span>;</pre>  <p>   此外，就是子类化了run方法：   </p>  <pre><span>void</span> TestSetUp::<span>run</span><span>(</span> TestResult *result <span>)</span><br><span>{</span><br>  setUp<span>(</span><span>)</span>;<br>  TestDecorator::<span>run</span><span>(</span>result<span>)</span>;<br>  tearDown<span>(</span><span>)</span>;<br><span>}</span></pre>  </div>    <h2><a rel="nofollow"     >兼听者部分（Listener）</a></h2>  <div>    <p>  这部分较为简单，主要根据具体需求，提供了两个TestListener的派生类，它们分别用在不同的场合。   </p>    </div>    <h4><a rel="nofollow"     >TestSucessListener</a></h4>  <div>    <p>  相关文件：TestSucessListener.h，TestSucessListener.cpp  </p>    <p>  派生自TestListener和SynchronizedObject（多重继承），兼具两者特性。作为一个实际的Observer，接收来自  TestResult的信息，用以“监听”测试是否成功。关于TestListener、   SynchronizedObject以及TestResult请见core部分的说明。  </p>    <p>  TestSucessListener内部所持有的成员变量m_sucess标示了测试成功与否，至于究竟如何“监听”，不妨来看一下  TestSucessListener的相关实现：   </p>  <pre>TestSucessListener::<span>TestSucessListener</span><span>(</span> SynchronizationObject *syncObject <span>)</span><br>    : SynchronizedObject<span>(</span> syncObject <span>)</span><br>    , m_sucess<span>(</span> <span>true</span> <span>)</span><br><span>{</span><br><span>}</span></pre>  <p>   在ctor中，m_sucess被初始化为true。至于syncObject，则提供了同步功能，为后续调用ExclusiveZone提供便利。   </p>  <pre><span>void</span> TestSucessListener::<span>addFailure</span><span>(</span> <span>const</span> TestFailure &amp;failure <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  m_sucess = <span>false</span>;<br><span>}</span></pre>  <p>     在测试发生错误时，TestResult将会调用TestSucessListener的addFailure，后者只是简单地将m_sucess设置为  false。TestSucessListener只关心测试成功与否，至于有关测试结果的详细情况则由   TestResultCollector负责“监听”，关于TestResultCollector请见output部分。因为要考虑多线程环境，所以用  到了ExclusiveZone，这也是为什么TestSucessListener需要继承SynchronizedObject的原因（别忘了   ExclusiveZone是protected属性的）。m_syncObject就是前面ctor中提到的syncObject。   </p>  <pre><span>void</span> TestSucessListener::<span>reset</span><span>(</span><span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  m_sucess = <span>true</span>;<br><span>}</span></pre>  <p>   顾名思义，在测试运行之前reset内部状态，将m_sucess置为true。  </p>    <p>  最后，为外部提供测试成功与否的查询接口也是必不可少的：   </p>  <pre><span>bool</span> TestSucessListener::<span>wasSuccessful</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;  <span>// [此处是read操作，似不必劳驾ExclusiveZone]</span><br>  <span>return</span> m_sucess;<br><span>}</span></pre>  </div>    <h4><a rel="nofollow"     >TextTestProgressListener</a></h4>  <div>    <p>  相关文件：TextTestProgressListener.h，TextTestProgressListener.cpp  </p>    <p>  派生自TestListener，用来“监听”测试用例的运行状态，并将结果定向到标准错误输出设备（即屏幕）。作为一个简易的文本流方式的结果输出工  具，TextTestProgressListener已是绰绰有余了。   </p>  <pre><span>// 继承自基类的虚函数，在测试运行前被调用</span><br><span>void</span> TextTestProgressListener::<span>startTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  std::<span>cerr</span> &lt;&lt; <span>"."</span>;<br>  std::<span>cerr</span>.<span>flush</span><span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>// 继承自基类的虚函数，运行测试失败时被调用</span><br><span>void</span> TextTestProgressListener::<span>addFailure</span><span>(</span> <span>const</span> TestFailure &amp;failure <span>)</span><br><span>{</span><br>  std::<span>cerr</span> &lt;&lt; <span>(</span> failure.<span>isError</span><span>(</span><span>)</span> ? <span>"E"</span> : <span>"F"</span> <span>)</span>;<br>  std::<span>cerr</span>.<span>flush</span><span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>// 在测试运行后被调用[疑为endTest，也许是作者的疏忽]</span><br><span>void</span> TextTestProgressListener::<span>done</span><span>(</span><span>)</span><br><span>{</span><br>  std::<span>cerr</span>  &lt;&lt;  std::<span>endl</span>;<br>  std::<span>cerr</span>.<span>flush</span><span>(</span><span>)</span>;<br><span>}</span></pre>  </div>    <h4><a rel="nofollow"     >TextTestResult</a></h4>  <div>    <p>  相关文件：TextTestResult.h，TextTestResult.cpp  </p>    <p>  以文本流方式输出测试运行的结果。不过该类在新版本中已被标上了“DEPRECATED”，并被   TextTestProgressListener和TextOutputter（在outputter部分讲解）所取代。因为是不推荐使用的，所以此处  不准备细述了，感兴趣的读者可以自己看。    </p>    </div>    <h2><a rel="nofollow"     >界面部分（TextUI）</a></h2>  <div>    <p>  这一部分主要提供了一个文本界面的测试运行环境（即以字符流方式输出到标准输出设备）。该测试环境在CppUnit中被称为test   runner，对应的类是TestRunner。TestRunner可以运行所有测试，或者是其中的一个。下面的代码演示了如何使用   TestRunner：   </p>  <pre>CppUnit::<span>TextUi</span>::<span>TestRunner</span> runner;<br>runner.<span>addTest</span><span>(</span> ExampleTestCase::<span>suite</span><span>(</span><span>)</span> <span>)</span>;<br>runner.<span>run</span><span>(</span> <span>""</span>, <span>true</span> <span>)</span>;    <span>// 空字串""代表运行所有的测试</span></pre>  <p>   在测试执行期间，TestRunner除了能输出最后的统计结果外，还可以打印输出跟踪信息。其中，跟踪信息的输出使用了   TextTestProgressListener（见listener部分），统计结果的输出则使用了TextOutputter（见   outputter部分）。当然，这些都是可选的。你可以在构造TestRunner期间或者随后通过调用setOutputter函数来指定其他类型的   outputter。你也可以通过在eventManager()中注册其他TestListener，来定制跟踪信息。且看下面的示例：   </p>  <pre>CppUnit::<span>TextUi</span>::<span>TestRunner</span> runner;<br>runner.<span>addTest</span><span>(</span> ExampleTestCase::<span>suite</span><span>(</span><span>)</span> <span>)</span>;<br>&nbsp;<br><span>// 用CompilerOutputter代替TextOutputter</span><br>runner.<span>setOutputter</span><span>(</span> CppUnit::<span>CompilerOutputter</span>::<span>defaultOutputter</span><span>(</span><br>    &amp;runner.<span>result</span><span>(</span><span>)</span>, std::<span>cerr</span> <span>)</span> <span>)</span>;<br><span>// 添加自定义的MyCustomProgressTestListener</span><br>MyCustomProgressTestListener progress;<br>runner.<span>eventManager</span><span>(</span><span>)</span>.<span>addListener</span><span>(</span> &amp;progress <span>)</span>;<br>&nbsp;<br>runner.<span>run</span><span>(</span> <span>""</span>, <span>true</span> <span>)</span>;    <span>// 空字串""代表运行所有的测试</span></pre>  <p>   最后，TestRunner管理着其下所有测试对象的生命周期。    </p>    </div>    <h4><a rel="nofollow"     >TestRunner</a></h4>  <div>    <p>  相关文件：TestRunner.h，TestRunner.cpp，TextTestRunner.h  </p>    <p>  TestRunner中定义了4个protected属性的成员变量：   </p>  <pre>TestSuite *m_suite;                     <span>// 对应待运行的测试</span><br>TestResultCollector *m_result;          <span>// 搜集测试结果（见output部分）</span><br>TestResult *m_eventManager;             <span>// 收集测试过程中的相关信息</span><br>Outputter *m_outputter;                 <span>// 输出测试统计结果</span></pre>  <p>     对于这几个成员变量的作用，注释中及前面部分已有提及。在这里，大家对TestResult和TestResultCollector的功能可能容易混  淆。对于它们的区别以及TestResultCollector的“身世”，请见output部分。  </p>    <p>  TestRunner的ctor对这几个成员变量进行了初始化，若外部传入的outputter为空，则缺省创建TextOutputter对象赋给  m_outputter，另外还调用了m_eventManager的addListener方法，将 m_result作为一个兼听者加入其中。   </p>  <pre>TestRunner::<span>TestRunner</span><span>(</span> Outputter *outputter <span>)</span> <br>    : m_outputter<span>(</span> outputter <span>)</span><br>    , m_suite<span>(</span> <span>new</span> TestSuite<span>(</span> <span>"All Tests"</span> <span>)</span> <span>)</span><br>    , m_result<span>(</span> <span>new</span> TestResultCollector<span>(</span><span>)</span> <span>)</span><br>    , m_eventManager<span>(</span> <span>new</span> TestResult<span>(</span><span>)</span> <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> !m_outputter <span>)</span><br>    m_outputter = <span>new</span> TextOutputter<span>(</span> m_result, std::<span>cout</span> <span>)</span>;<br>  m_eventManager-&gt;addListener<span>(</span> m_result <span>)</span>;<br><span>}</span></pre>  <p>   dtor则负责回收在ctor中所创建的资源：   </p>  <pre>TestRunner::~TestRunner<span>(</span><span>)</span><br><span>{</span><br>  <span>delete</span> m_eventManager;<br>  <span>delete</span> m_outputter;<br>  <span>delete</span> m_result;<br>  <span>delete</span> m_suite;<br><span>}</span></pre>  <p>   正如前面所说，你可以在构造TestRunner之后，通过调用setOutputter函数来指定其他类型的outputter：   </p>  <pre><span>void</span> TestRunner::<span>setOutputter</span><span>(</span> Outputter *outputter <span>)</span><br><span>{</span><br>  <span>delete</span> m_outputter;<br>  m_outputter = outputter;<br><span>}</span></pre>  <p>   TestRunner中的主要接口就是run方法，通过调用该函数才能运行测试：   </p>  <pre><span>bool</span> TestRunner::<span>run</span><span>(</span> std::<span>string</span> testName, <br>        <span>bool</span> doWait, <br>        <span>bool</span> doPrintResult, <br>        <span>bool</span> doPrintProgress <span>)</span><br><span>{</span><br>    runTestByName<span>(</span> testName, doPrintProgress <span>)</span>;<br>    printResult<span>(</span> doPrintResult <span>)</span>;<br>    wait<span>(</span> doWait <span>)</span>;<br>    <span>return</span> m_result-&gt;wasSuccessful<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>   其中，testName是测试用例的名称，若为空则运行所有测试，否则运行指定测试；doWait为true时，表示在   run函数返回之前，用户必须按一下RETURN键才能结束；doPrintResult为true时，测试结果将被输出到标准输出设备（前提是使用   TextOutputter），否则不产生任何输出；doPrintProgress为true时，测试过程将被输出到标准输出设备（前提是使用   TextTestProgressListener），否则不产生任何输出。  </p>    <p>  这里调用了runTestByName，请看源码及注释：   </p>  <pre><span>bool</span> TestRunner::<span>runTestByName</span><span>(</span> std::<span>string</span> testName,<br>    <span>bool</span> doPrintProgress <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> testName.<span>empty</span><span>(</span><span>)</span> <span>)</span>                       <span>// 若testName为空则运行所有测试</span><br>    <span>return</span> runTest<span>(</span> m_suite, doPrintProgress <span>)</span>;<br>&nbsp;<br>  Test *test = findTestByName<span>(</span> testName <span>)</span>;      <span>// 否则查找指定测试</span><br>  <span>if</span> <span>(</span> test != <span>NULL</span> <span>)</span><br>    <span>return</span> runTest<span>(</span> test, doPrintProgress <span>)</span>;    <span>// 若成功找到则运行之</span><br>&nbsp;<br>  std::<span>cout</span> &lt;&lt; <span>"Test "</span> &lt;&lt; testName &lt;&lt; <span>" not found."</span> &lt;&lt; std::<span>endl</span>;<br>  <span>return</span> <span>false</span>;<br><span>}</span></pre>  <p>   在runTestByName中，根据测试名称查找指定测试的任务落实到了findTestByName肩上：   </p>  <pre>Test *TestRunner::<span>findTestByName</span><span>(</span> std::<span>string</span> name <span>)</span> <span>const</span><br><span>{</span><br>  <span>for</span> <span>(</span> std::<span>vector</span>&lt;Test *&gt;::<span>const_iterator</span> it = m_suite-&gt;getTests<span>(</span><span>)</span>.<span>begin</span><span>(</span><span>)</span>;<br>    it != m_suite-&gt;getTests<span>(</span><span>)</span>.<span>end</span><span>(</span><span>)</span>;<br>    ++it <span>)</span><br>  <span>{</span><br>    Test *test = *it;<br>    <span>if</span> <span>(</span> test-&gt;getName<span>(</span><span>)</span> == name <span>)</span><br>      <span>return</span> test;<br>  <span>}</span><br>  <span>return</span> <span>NULL</span>;<br><span>}</span></pre>  <p>     该函数以const_iterator遍历m_suite中的所有测试，寻找名字相符的测试。不过，从代码中可以看出，这里无法支持多层嵌套结构的测试  集，这也算是一点遗憾吧。  </p>    <p>  找到指定测试之后，就可以将运行测试的任务转交给runTest方法了：   </p>  <pre><span>bool</span> TestRunner::<span>runTest</span><span>(</span> Test *test, <span>bool</span> doPrintProgress<span>)</span><br><span>{</span><br>  TextTestProgressListener progress;<br>  <span>if</span> <span>(</span> doPrintProgress <span>)</span>                <span>// 若doPrintProgress为true则显示测试过程</span><br>    m_eventManager-&gt;addListener<span>(</span> &amp;progress <span>)</span>;<br>&nbsp;<br>  test-&gt;run<span>(</span> m_eventManager <span>)</span>;          <span>// 此处才真正运行测试，m_eventManager就是TestResult</span><br>&nbsp;<br>  <span>if</span> <span>(</span> doPrintProgress <span>)</span>                <span>// 若doPrintProgress为true则移除先前加入的progress</span><br>    m_eventManager-&gt;removeListener<span>(</span> &amp;progress <span>)</span>;<br>  <span>return</span> m_result-&gt;wasSuccessful<span>(</span><span>)</span>;     <span>// 返回测试结果成功与否</span><br><span>}</span></pre>  <p>   测试结束后，就可以通过调用printResult输出测试结果了：   </p>  <pre><span>void</span> TestRunner::<span>printResult</span><span>(</span> <span>bool</span> doPrintResult <span>)</span><br><span>{</span><br>  std::<span>cout</span> &lt;&lt; std::<span>endl</span>;<br>  <span>if</span> <span>(</span> doPrintResult <span>)</span><br>    m_outputter-&gt;write<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>     另外，TestRunner还提供了一个addTest方法，用以添加测试，其内部只是简单的调用了一下m_suite的addTest方法，相当简单：     </p>  <pre><span>void</span> TestRunner::<span>addTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> test != <span>NULL</span> <span>)</span><br>    m_suite-&gt;addTest<span>(</span> test <span>)</span>;<br><span>}</span></pre>  <p>   当然还少不了几个成员变量的getter方法：   </p>  <pre>TestResultCollector &amp;TestRunner::<span>result</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> *m_result;<br><span>}</span><br>&nbsp;<br>TestResult &amp;TestRunner::<span>eventManager</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> *m_eventManager;<br><span>}</span></pre>  <p>   另一个相关的头文件TextTestRunner.h中，仅仅简单地做了一个typedef定义：   </p>  <pre><span>typedef</span> CppUnit::<span>TextUi</span>::<span>TestRunner</span> TextTestRunner;</pre>  <p>   这就是TestRunner的大致内容。    </p>    </div>    <h2><a rel="nofollow"     >移植部分（Portability）</a></h2>  <div>    <p>      这一部分，通过若干参数的设定，解决了向不同平台移植时遇到的问题。另外还有一个叫做OStringStream的辅助类，不过morning以为，该类  似乎置于helper部分更为合适。   </p>    </div>    <h4><a rel="nofollow"     >OStringStream</a></h4>  <div>    <p>  相关文件：Portablility.h  </p>    <p>  其实OStringStream在先前很多地方都曾经出现过，比如：   TestFactoryRegistry中、XmlOutputter中、TestAssert中。其作用是将整数转换为字符串并输出，功能上类似于C语  言的itoa函数。事实上，从随CppUnit所附的ChangeLog中可以看到，先前正是用的itoa，只不过后来的一次refactoring中，  才被OStringStream取代。其实现代码如下：   </p>  <pre><span>#if CPPUNIT_HAVE_SSTREAM</span><br><span>#   include &lt;sstream&gt;</span><br>    <span>namespace</span> CppUnit <span>{</span><br>      <span>class</span> OStringStream : <span>public</span> std::<span>ostringstream</span> <br>      <span>{</span><br>      <span>}</span>;<br>    <span>}</span><br><span>#else </span><br><span>#if CPPUNIT_HAVE_CLASS_STRSTREAM</span><br><span>#   include &lt;string&gt;</span><br><span>#   if CPPUNIT_HAVE_STRSTREAM</span><br><span>#       include &lt;strstream&gt;</span><br><span>#   else</span><br><span>#       include &lt;strstream.h&gt;</span><br><span>#   endif</span><br>&nbsp;<br>    <span>namespace</span> CppUnit <span>{</span><br>      <span>class</span> OStringStream : <span>public</span> std::<span>ostrstream</span> <br>      <span>{</span><br>      <span>public</span>:<br>          std::<span>string</span> str<span>(</span><span>)</span><br>          <span>{</span><br>            <span>(</span>*<span>this</span><span>)</span> &lt;&lt; <span>'<span>\0</span>'</span>;<br>            std::<span>string</span> msg<span>(</span>std::<span>ostrstream</span>::<span>str</span><span>(</span><span>)</span><span>)</span>;<br>            std::<span>ostrstream</span>::<span>freeze</span><span>(</span><span>false</span><span>)</span>;<br>            <span>return</span> msg;<br>          <span>}</span><br>      <span>}</span>;<br>    <span>}</span><br><span>#else</span><br><span>#   error Cannot define CppUnit::OStringStream.</span><br><span>#endif</span><br><span>#endif</span></pre>  </div>    <h4><a rel="nofollow"     >其他</a></h4>  <div>    <p>  相关文件：Portability.h，config-msvc6.h，config-bcb5.h  </p>    <p>  如前所述，CppUnit提供了一系列可供设置的参数（其实就是一系列宏定义），针对不同平台，你需要做出不同的选择。好在CppUnit的实现者为我们  做了很多工作，使我们不用太多考虑这方面的问题，至少在Visual C++ 6.0和Borland C++ Builder   5.0这两个平台上是如此。Portability.h的开头有如下这样一段代码，它依据实际的语言平台（由特定的宏来指定），载入相应的参数设置文件：     </p>  <pre><span>#if defined(__BORLANDC__)</span><br><span>#    include &lt;cppunit/config-bcb5.h&gt;</span><br><span>#elif defined (_MSC_VER)</span><br><span>#    include &lt;cppunit/config-msvc6.h&gt;</span><br><span>#else</span><br><span>#    include &lt;cppunit/config-auto.h&gt;</span><br><span>#endif</span></pre>  <p>     这里的config-auto.h文件，morning并未在CppUnit的源码中找到，也许是程序作者的一时疏忽。至于在config-xxx.h中  出现的那些参数，此处只列举一二，感兴趣的读者可自己去查看源码。   </p>  <pre><span>// helper部分的TypeInfoHelper中曾经出现过该宏</span><br><span>// 它表明在bcb和vc中函数std::string::compare的调用方式不一样</span><br>&nbsp;<br><span>// config-msvc6.h</span><br><span>#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST </span><br><span>#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST</span><br><span>#endif</span><br>&nbsp;<br><span>// config-bcb5.h</span><br><span>#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST </span><br><span>#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  1 </span><br><span>#endif</span><br>&nbsp;<br><span>// 指明编译器是否支持c++的namespace语言特性</span><br><span>// bcb和vc均支持namespace</span><br>&nbsp;<br><span>// config-msvc6.h</span><br><span>#ifndef CPPUNIT_HAVE_NAMESPACES </span><br><span>#define CPPUNIT_HAVE_NAMESPACES  1 </span><br><span>#endif</span><br>&nbsp;<br><span>// config-bcb5.h</span><br><span>#ifndef CPPUNIT_HAVE_NAMESPACES </span><br><span>#define CPPUNIT_HAVE_NAMESPACES  1 </span><br><span>#endif</span><br>&nbsp;<br><span>// OStringStream的定义中曾经出现过，指明是否存在&lt;sstream&gt;头文件，</span><br><span>// bcb和vc均包含有&lt;sstream&gt;头文件</span><br>&nbsp;<br><span>// config-msvc6.h</span><br><span>#define CPPUNIT_HAVE_SSTREAM 1</span><br>&nbsp;<br><span>// config-bcb5.h</span><br><span>#define CPPUNIT_HAVE_SSTREAM 1</span></pre>  <p>   此外还有一些，仅在某个平台下才会用到的参数，比如，以下内容均只在config-msvc6.h中出现：   </p>  <pre><span>// 忽略Debug符号大于255的警告</span><br><span>#if _MSC_VER &gt; 1000     // VC++</span><br><span>#pragma warning( disable : 4786 )</span><br><span>#endif // _MSC_VER &gt; 1000</span><br>&nbsp;<br><span>// 若当前创建的是CppUnit的DLL库，则需要定义CPPUNIT_DLL_BUILD</span><br><span>#ifdef CPPUNIT_BUILD_DLL</span><br><span>#define CPPUNIT_API __declspec(dllexport)</span><br><span>#endif</span><br>&nbsp;<br><span>// 若当前要链接到CppUnit的DLL库，则需要定义CPPUNIT_DLL</span><br><span>#ifdef CPPUNIT_DLL</span><br><span>#define CPPUNIT_API __declspec(dllimp<wbr>ort)</span><br><span>#endif</span></pre>  <p>   最后，Portability.h中还定义了一些平台无关的参数，它们设定同样也影响着CppUnit的某些特性，比如：   </p>  <pre><span>// 若你希望使用传统风格的断言宏，比如：</span><br><span>// assert(), assertEqual()等等，则需将其设定为1</span><br><span>#ifndef CPPUNIT_ENABLE_NAKED_ASSERT</span><br><span>#define CPPUNIT_ENABLE_NAKED_ASSERT          0</span><br><span>#endif</span><br>&nbsp;<br><span>// CPPUNIT_API是在&lt;config_msvc6.h&gt;中被定以的</span><br><span>// 若没有被定以，则表明程序不需要引用或生成CppUnit的DLL库</span><br><span>#ifndef CPPUNIT_API</span><br><span>#define CPPUNIT_API</span><br><span>#undef CPPUNIT_NEED_DLL_DECL</span><br><span>#define CPPUNIT_NEED_DLL_DECL 0</span><br><span>#endif</span></pre>  </div>    <h2><a rel="nofollow"     >附录（Appendix）</a></h2>  <div>    </div>    <h3><a rel="nofollow"     >WIN32平台安装说明</a></h3>  <div>    <p>  目前，CPPUnit在WIN32平台下仅支持Microsoft Visual C++，而且你的VC++编译器至少应该是6.0版本的。  </p>    <p>  使用GUI TestRunner编译运行示例程序的步骤如下：   </p>  <pre> 1. 在VC++中打开examples/examples.dsw（包含所有的示例）<br> 2. 将HostApp设为active project<br> 3. 编译之<br> 4. 在VC中选择Tools/Customize.../Add-ins and Macro Files，点击Browse...<br> 5. 选择lib/TestRunnerDSPlugIn.dll文件，并按ok以注册该附加件（add-ins）<br> 6. 运行project </pre>    </div>    <h4><a rel="nofollow"     >Project创建结果</a></h4>  <div>    <p>  框架 &amp; 工具：   </p>  <ul><li><div>   cppunit（cppunit.lib）：单元测试的框架库，你将用它来编写单元测试。</div>  </li><li><div>   cppunit_dll（cppunit_dll.dll/lib）：同上，只是以DLL方式呈现。</div>  </li><li><div>   TestRunner（testrunner.dll）：一个MFC的扩展DLL，用来以GUI方式运行单元测试和查看结果。</div>  </li><li><div> DSPlugIn   （lib/TestRunnerDSPlugIn.dll）：一个VC++的附加件，为testrunner.dll所使用。有了它之后，你若在MFC   TestRunner中双击某个failure，就会启动VC++，打开failure所在文件并定位到某行。</div>  </li><li><div>   TestPlugInRunner：（警告：实验性的）一个VC++应用程序，用以运行测试插件。测试插件就是一个公开特定接口的DLL。该应用程序目前  尚未完成（auto-reload特性丢失）。 </div>  </li></ul>    <p>   所有库文件都被置于lib/目录下。    </p>    </div>    <h4><a rel="nofollow"     >示例</a></h4>  <div>  <ul><li><div> CppUnitTestMain：一个实际的测试包（test   suite）用来测试CppUnit。使用了TextTestRunner（文本方式的单元测试环境），利用CompilterOutputter进行   post-build testing（即在编译结束之后紧跟着进行测试）。在配置中设定连接了cppunit的静态库和动态库。</div>  </li><li><div>   CppUnitTestApp：包含了与CppUnitTestMain相同的测试包，但使用了MFC   TestRunner（GUI方式的单元测试环境）</div>  </li><li><div> hierarchy :   一个演示如何子类化测试的例子（你也许更愿意使用HelperMacros.h以及宏CPPUNIT_TEST_SUB_SUITE，这种方式更为简洁清  晰。本示例已经很久没有更新了）。</div>  </li><li><div> HostApp : 一个用MFC   TestRunner演示各种失败测试的例子。也演示了MFC Unicode TestRunner。</div>  </li><li><div> TestPlugIn :   一个演示如何为TestPlugInRunner编写TestPlugIn的例子（实验性的）.</div>  </li></ul>    </div>    <h4><a rel="nofollow"     >配置（Configuration）</a></h4>  <div>    <p>  CppUnit和TestRunner带有3种配置。   </p>  <ul><li><div> Release（）：多线程DLL，release模式</div>  </li><li><div> Debug（d）：Debug多线程DLL，debug模式</div>  </li><li><div> Unicode   Release（u）：Unicode多线程DLL，release模式</div>  </li><li><div> Unicode Debug（ud）：Unicode Debug   多线程DLL，debug模式</div>  </li><li><div> Debug Crossplatform （cd）: Debug   多线程DLL，没有使用type_info从类名中提取测试用例的包名。 </div>  </li></ul>    <p>   对CppUnit而言，当创建dll时，字母“dll” 将被添加到后缀之后。  </p>    <p>  括号内的字母标明了添加到库名之后的后缀。例如，debug配置的cppunit静态库名为cppunitd.lib。debug配置的cppunit动  态库名为cppunitd_dll.lib.    </p>    </div>    <h4><a rel="nofollow"     >创建（Building）</a></h4>  <div>  <pre> 1.  在VC++中打开src/CppUnitLibraries.dsw工作区文件。<br> 2. 将TestPlugInRunner设为active project。<br> 3. 在'Build'菜单中选择'Batch Build...'<br> 4. 在Batch Build对话框中，选中所有的project 并按下build按钮。<br> 5. 所有的库文件可以在lib/目录下找到。 </pre>    </div>    <h4><a rel="nofollow"     >测试（Testing）</a></h4>  <div>  <pre> 1.  打开工作区文件examples/Examples.dsw。<br> 2. 将CppUnitTestApp设为active project.<br> 3. 为你要创建的库选择合适的配置。<br> 4. 编译运行project。TestRunner GUI将会出现。 </pre>    </div>    <h4><a rel="nofollow"     >库（Libraries）</a></h4>  <div>    <p>  所有编译后生成的库均可在'lib'目录中找到。多数库可以在src/CppUnitLibraries.dsw工作区中创建。  </p>    <p>  lib\:   </p>  <ul><li><div> cppunit.lib :   CppUnit静态库“Multithreaded DLL”</div>  </li><li><div> cppunitd.lib : CppUnit静态库“Debug   Multithreaded DLL”</div>  </li><li><div> cppunit_dll.dll :   CppUnit动态库（DLL）“Multithreaded DLL”</div>  </li><li><div> cppunit_dll.lib :   CppUnit动态导入库“Multithreaded DLL”</div>  </li><li><div> cppunitd_dll.dll :   CppUnit动态库（DLL）“Debug Multithreaded DLL”</div>  </li><li><div> cppunitd_dll.lib :   CppUnit动态导入库“Debug Multithreaded DLL”</div>  </li><li><div> qttestrunner.dll : QT   TestRunner动态库（DLL）“Multithreaded DLL”</div>  </li><li><div> qttestrunner.lib : QT   TestRunner导入库“Multithreaded DLL”</div>  </li><li><div> testrunner.dll : MFC   TestRunner动态库（DLL）“Multithreaded DLL”</div>  </li><li><div> testrunner.lib : MFC   TestRunner导入库“Multithreaded DLL”</div>  </li><li><div> testrunnerd.dll : MFC   TestRunner动态库（DLL）“Debug Multithreaded DLL”</div>  </li><li><div> testrunnerd.lib : MFC   TestRunner导入库“Debug Multithreaded DLL”</div>  </li><li><div> testrunneru.dll : MFC Unicode   TestRunner动态库（DLL）“Multithreaded DLL”</div>  </li><li><div> testrunneru.lib : MFC Unicode   TestRunner导入库“Multithreaded DLL”</div>  </li><li><div> testrunnerud.dll : MFC Unicode   TestRunner动态库（DLL）“Debug Multithreaded DLL”</div>  </li><li><div> testrunnerud.lib : MFC Unicode   TestRunner导入库“Debug Multithreaded DLL”</div>  </li><li><div> TestRunnerDSPlugIn.dll :   注册到你的VC++中的附加件。 </div>  </li></ul>    <p>   注意：当你使用CppUnit   DLL（cppunit*_dll.dll）时，你必须连接相关的导入库，并在project中定义预处理标识CPPUNIT_DLL。    </p>    </div>    <h4><a rel="nofollow"     >使用CppUnit</a></h4>  <div>    </div>    <h5><a rel="nofollow"     >编写单元测试 :</a></h5>  <div>    <p>     为了编写单元测试，你需要连接cppunitXX.lib，此处的XX即所选配置对应的后缀字母。你必须在你的project中打开RTTI开关  （Project Settings/C++/C++ Language）。   CppUnit的include目录必须包含在include查找路径中。你可以通过在Project   Settings/C++/Preprocessor/Additional include   directories或者Tools/Options/Directories/Include中添加include目录做到这一点。  </p>    <p>  简言之：   </p>  <ul><li><div> 打开RTTI开关</div>  </li><li><div> 连接lib/cppunitXX.lib</div>  </li><li><div> include/ 必须包含在include查找路径中 </div>  </li></ul>    </div>    <h5><a rel="nofollow"     >使用TestRunner GUI：</a></h5>  <div>    <p>   为了使用GUI的test   runner，你需要连接testrunnerXX.lib和cppunitXX.lib，此处的XX即所选配置对应的后缀字母。   你必须在你的project中打开RTTI开关。   文件testrunner.dll必须位于你的应用程序所在的路径（Debug或Release目录，project的dsp文件所在目录，或环境变量  PATH中所指定的目录）。   一个最简单的办法是，要么添加一个post-build命令，或者，将位于lib/目录下的testrunner.dll添加到你的project中来，  并定制创建步骤，将dll文件拷贝到你的“中间结果”目录（通常是Debug或Release目录）。  </p>    <p>  因为TestRunner GUI是一个MFC的扩展DLL，它能够访问当前应用程序的CWinApp。   参数设置将使用应用程序的注册键。这意味着，设置项“最近使用的测试”对每个应用程序而言都是不同的。  </p>    <p>  简言之：   </p>  <ul><li><div> 打开RTTI开关</div>  </li><li><div>   连接lib/cppunitXX.lib和lib/testrunnerXX.lib</div>  </li><li><div> include/必须包含在include查找路径中</div>  </li><li><div>   为了运行你的project，lib/testrunnerXX.dll必须可用 </div>  </li></ul>    </div>    <h5><a rel="nofollow"     >使用DSPlugIn：</a></h5>  <div>    <p>   你必须在VC++中注册该插件。在Tools/Customize/Add-ins and Macro   files中点击browse，并选择lib/TestRunnerDSPlugIn.dll（你可以注册release版或者debug版，都能运  行）。  </p>    <p>  若VC++正在运行，当你双击一个failure后，VC++将打开相关文件并定位到出错行。 # 使用Test Plug In Runner：  </p>    <p>  你的DLL必须导出（export）一个函数，该函数实现了在   include/msvc6/testrunner/TestPlugInInterface.h中所定义的接口。作为范例，参见   examples/msvc6/TestPlugIn/TestPlugInInterfaceImpl.*。注意：该runner仍处于实验阶段并未作  足够多的测试。  </p>    </div>
</body></html>