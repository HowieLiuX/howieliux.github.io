<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：【转载】函数调用约定</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>【转载】函数调用约定</h2>
<p align="right">发布时间：2014-3-26 11:27
<br>分类名称：C++</p><br>
<p>在C语言中，假设我们有这样的一个函数： </p>  <p>int function(int a,int b) </p>  <p>调用时只要用result = function(1,2)这样的方式就可以使用这个函数。但是，当高级 <br>语言被编译成计算机可以识别的机器码时，有一个问题就凸现出来：在CPU中，计算机没 <br>有办法知道一个函数调用需要多少个、什么样的参数，也没有硬件可以保存这些参数。 <br>也就是说，计算机不知道怎么给这个函数传递参数，传递参数的工作必须由函数调用者 <br>和函数本身来协调。为此，计算机提供了一种被称为栈的数据结构来支持参数传递。 </p>  <p>栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中 <br>第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作 <br>被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修 <br>改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变 <br>成栈顶，栈顶指针随之修改。 </p>  <p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得 <br>数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈 <br>恢复原装。 </p>  <p>在参数传递中，有两个很重要的问题必须得到明确说明： </p>  <p>当参数个数多于一个时，按照什么顺序把参数压入堆栈 <br>函数调用后，由谁来把堆栈恢复原装 <br>在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有： </p>  <p>stdcall <br>cdecl <br>fastcall <br>thiscall <br>naked call <br>stdcall调用约定 <br>stdcall很多时候被称为pascal调用约定，因为pascal是早期很常见的一种教学用计算机 <br>程序设计语言，其语法严谨，使用的函数调用约定就是stdcall。在Microsoft C++系列 <br>的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLB <br>ACK。 </p>  <p>stdcall调用约定声明的语法为(以前文的那个函数为例）： </p>  <p>int __stdcall function(int a,int b) </p>  <p>stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈 3)函数 <br>名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸 </p>  <p>以上述这个函数为例，参数b首先被压栈，然后是参数a，函数调用function(1,2)调用处 <br>翻译成汇编语言将变成： </p>  <p><br>push 2 第二个参数入栈 <br>push 1 第一个参数入栈 <br>call function 调用参数，注意此时自动把cs:eip入栈 </p>  <p><br>而对于函数自身，则可以翻译为： </p>  <p><br>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出 <br>时恢复 <br>mov ebp,esp 保存堆栈指针 <br>mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向 <br>a <br>add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b <br>mov esp,ebp 恢复esp <br>pop ebp <br>ret 8 </p>  <p>而在编译时，这个函数的名字被翻译成<a rel="nofollow" href="mailto:_function@8"   >_function@8</a> </p>  <p>注意不同编译器会插入自己的汇编代码以提供编译的通用性，但是大体代码如此。其中 <br>在函数开始处保留esp到ebp中，在函数结束恢复是编译器常用的方法。 </p>  <p>从函数调用看，2和1依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的 <br>堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己 <br>恢复了堆栈。 </p>  <p>cdecl调用约定 <br>cdecl调用约定又称为C调用约定，是C语言缺省的调用约定，它的定义语法是： </p>  <p><br>int function (int a ,int b) //不加修饰就是C调用约定 <br>int __cdecl function(int a,int b)//明确指出C调用约定 </p>  <p><br>在写本文时，出乎我的意料，发现cdecl调用约定的参数压栈顺序是和stdcall是一样的 <br>，参数首先由有向左压入堆栈。所不同的是，函数本身不清理堆栈，调用者负责清理堆 <br>栈。由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大 <br>特色。对于前面的function函数，使用cdecl后的汇编码变成： </p>  <p><br>调用处 <br>push 1 <br>push 2 <br>call function <br>add esp,8 注意：这里调用者在恢复堆栈 <br>被调用函数_function处 <br>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出 <br>时恢复 <br>mov ebp,esp 保存堆栈指针 <br>mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向 <br>a <br>add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b <br>mov esp,ebp 恢复esp <br>pop ebp <br>ret 注意，这里没有修改堆栈 </p>  <p><br>MSDN中说，该修饰自动在函数名前加前导的下划线，因此函数名在符号表中被记录为_f <br>unction，但是在编译时似乎没有看到这种变化。 </p>  <p>由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用 <br>不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据 <br>第一个后者后续的明确的参数确定下来，就可以使用不定参数，例如对于CRT中的sprin <br>tf函数，定义为： </p>  <p>int sprintf(char* buffer,const char* format,...) </p>  <p>由于所有的不定参数都可以通过format确定，因此使用不定个数的参数是没有问题的。 </p>  <p>fastcall <br>fastcall调用约定和stdcall类似，它意味着： </p>  <p>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过 <br>从右向左的顺序压栈 <br>被调用函数清理堆栈 <br>函数名修改规则同stdcall <br>其声明语法为：int fastcall function(int a,int b) </p>  <p>thiscall <br>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成 <br>员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，th <br>iscall意味着： </p>  <p>参数从右向左入栈 <br>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针 <br>在所有参数压栈后被压入堆栈。 <br>对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈 <br>为了说明这个调用约定，定义如下类和使用代码： </p>  <p>class A <br>{ <br>public: <br>int function1(int a,int b); <br>int function2(int a,...); <br>}; <br>int A::function1 (int a,int b) <br>{ <br>return a+b; <br>} <br>#include <br>int A::function2(int a,...) <br>{ <br>va_list ap; <br>va_start(ap,a); <br>int i; <br>int result = 0; <br>for(i = 0 i &lt; a i ++) <br>{ <br>result += va_arg(ap,int); <br>} <br>return result; <br>} <br>void callee() <br>{ <br>A a; <br>a.function1 (1,2); <br>a.function2(3,1,2,3); <br>} </p>  <p>callee函数被翻译成汇编后就变成： </p>  <p><br>//函数function1调用 <br>0401C1D push 2 <br>00401C1F push 1 <br>00401C21 lea ecx,[ebp-8] <br>00401C24 call function1 注意，这里this没有被入栈 <br>//函数function2调用 <br>00401C29 push 3 <br>00401C2B push 2 <br>00401C2D push 1 <br>00401C2F push 3 <br>00401C31 lea eax,[ebp-8] 这里引入this指针 <br>00401C34 push eax <br>00401C35 call function2 <br>00401C3A add esp,14h </p>  <p>可见，对于参数个数固定情况下，它类似于stdcall，不定时则类似cdecl </p>  <p>naked call <br>这是一个很少见的调用约定，一般程序设计者建议不要使用。编译器不会给这种函数增 <br>加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回 <br>结果。这一般用于实模式驱动程序设计，假设定义一个求和的加法程序，可以定义为： </p>  <p><br>__declspec(naked) int add(int a,int b) <br>{ <br>__asm mov eax,a <br>__asm add eax,b <br>__asm ret <br>} </p>  <p>注意，这个函数没有显式的return返回值，返回通过修改eax寄存器实现，而且连退出函 <br>数的ret指令都必须显式插入。上面代码被翻译成汇编以后变成： </p>  <p><br>mov eax,[ebp+8] <br>add eax,[ebp+12] <br>ret 8 </p>  <p><br>注意这个修饰是和__stdcall及cdecl结合使用的，前面是它和cdecl结合使用的代码，对 <br>于和stdcall结合的代码，则变成： </p>  <p>__declspec(naked) int __stdcall function(int a,int b) <br>{ <br>__asm mov eax,a <br>__asm add eax,b <br>__asm ret 8 //注意后面的8 <br>} </p>  <p>至于这种函数被调用，则和普通的cdecl及stdcall调用函数一致。 </p>  <p>函数调用约定导致的常见问题 <br>如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两 <br>种常见的问题： </p>  <p>函数原型声明和函数体定义不一致 <br>DLL导入函数时声明了不同的函数约定 <br>以后者为例，假设我们在dll种声明了一种函数为： </p>  <p>__declspec(dllexport) int func(int a,int b);//注意，这里没有stdcall，使用的是 <br>cdecl <br>使用时代码为： </p>  <p>typedef int (*WINAPI DLLFUNC)func(int a,int b); <br>hLib = LoadLibrary(...); <br>DLLFUNC func = (DLLFUNC)GetProcAddress(...)//这里修改了调用约定 <br>result = func(1,2);//导致错误 </p>  <p>由于调用者没有理解WINAPI的含义错误的增加了这个修饰，上述代码必然导致堆栈被破 <br>坏，MFC在编译时插入的checkesp函数将告诉你，堆栈被破坏了。</p>  <p>fastcall <br>1）参数压栈顺序从右到左。 <br>2）如果可能使用寄存器（register）来传递参数。使用寄存器做参数比将参数压入堆栈（堆栈就是内存）快得多，所以叫fastcall。</p>  <p>&nbsp;</p>  <p>　(1) _stdcall调用 <br>　　_stdcall是Pascal程序的缺省调用方式，参数采用从右到左的压栈方式，被调函数自身在返回前清空堆栈。 <br>　　WIN32 Api都采用_stdcall调用方式，这样的宏定义说明了问题： <br>　　#define WINAPI _stdcall <br>　　按C编译方式，_stdcall调用约定在输出函数名前面加下划线，后面加“@”符号和参数的字节数，形如<a rel="nofollow" href="mailto:_functionname@number"   >_functionname@number</a>。 <br>(2) _cdecl调用 <br>　　_cdecl是C/C++的缺省调用方式，参数采用从右到左的压栈方式，传送参数的内存栈由调用者维护。_cedcl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。 </p>  <p>　　由于_cdecl调用方式的参数内存栈由调用者维护，所以变长参数的函数能（也只能）使用这种调用约定。关于C/C++中变长参数(…)的问题，笔者将另文详述。 </p>  <p>　　由于Visual C++默认采用_cdecl 调用方式，所以VC中中调用DLL时，用户应使用_stdcall调用约定。 <br>　　按C编译方式，_cdecl调用约定仅在输出函数名前面加下划线，形如_functionname。 </p>  <p>　　(3) _fastcall调用 <br>　　_fastcall调用较快，它通过CPU内部寄存器传递参数。 </p>  <p>　　按C编译方式，_fastcall调用约定在输出函数名前面加“@”符号，后面加“@”符号和参数的字节数，形如@functionname@number。 </p>  <p>　　关键字_stdcall、_cdecl和_fastcall可以直接加在函数前，也可以在Visual C++中设置。</p>  <p><br>&nbsp; <br></p>
</body></html>