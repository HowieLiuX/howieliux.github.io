<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Interrupt Request Level</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Interrupt Request Level</h2>
<p align="right">发布时间：2013-8-20 15:51
<br>分类名称：Driver</p><br>
<p><span style="font-family:Segoe UI; font-size:12pt;"   >From:&lt;</span>
<span style="font-family:Segoe UI; font-size:12pt;"   >Programming the Microsoft Windows Driver Model, 2nd Ed&gt;
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Windows XP assigns an interrupt request level to each hardware interrupt and to a select few software events. Each CPU has its own IRQL. We label the different IRQL levels with names such as <em>PASSIVE_LEVEL</em>, <em>APC_LEVEL</em>, and so on. Figure 4-1 illustrates the range of IRQL values for the x86 platform. (In general, the numeric values of IRQL depend on which platform you're talking about.) Most of the time, the computer executes in user mode at <em>PASSIVE_LEVEL</em>. All of your knowledge about how multitasking operating systems work applies at <em>PASSIVE_LEVEL</em>. That is, the scheduler may preempt a thread at the end of a time slice or because a higher-priority thread has become eligible to run. Threads can also voluntarily block while they wait for events to occur.
</span></p><p><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img0.ph.126.net_19iB01nkz6sj8TAmVwhtsw==_1409063733513680694.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p><span style="font-family:宋体; font-size:12pt;"   ><strong>Figure 4-1.</strong>
<em>Interrupt request levels.</em>
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >When an interrupt occurs, the kernel raises the IRQL on the interrupting CPU to the level associated with that interrupt. The <em>activity</em> of processing an interrupt can be—uh, <em>interrupted—</em>to process an interrupt at a higher IRQL but never to process an interrupt at the same or a lower IRQL. I'm sorry to use the word <em>interrupt</em> in two slightly different ways here. I struggled to find a word to describe the temporary suspension of an activity that wouldn't cause confusion with thread preemption, and that was the best choice.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >What I just said is sufficiently important to be enshrined as a rule:
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   ><em>An activity on a given CPU can be interrupted only by an activity that executes at a higher IRQL.</em>
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >You have to read this rule the way the computer does. Expiration of a time slice eventually invokes the thread scheduler at <em>DISPATCH_LEVEL</em>. The scheduler can then make a different thread current. When the IRQL returns to <em>PASSIVE_LEVEL</em>, a different thread is running. But it's still true that the first <em>PASSIVE_LEVEL</em> activity wasn't interrupted by the second <em>PASSIVE_LEVEL</em> activity. I thought this interpretation was incredible hair-splitting until it was pointed out to me that this arrangement allows a thread running at <em>APC_LEVEL</em> to be preempted by a different thread running at <em>PASSIVE_LEVEL</em>. Perhaps a more useful statement of the rule is this one:
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   ><em>An activity on a given CPU can be interrupted only by an activity that executes at a higher IRQL. An activity at or above DISPATCH_LEVEL cannot be suspended to perform another activity at or below the then-current IRQL.</em>
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Since each CPU has its own IRQL, it's possible for any CPU in a multiprocessor computer to run at an IRQL that's less than or equal to the IRQL of any other CPU. In the next major section, I'll tell you about spin locks, which combine the within-a-CPU synchronizing behavior of an IRQL with a multiprocessor lockout mechanism. For the time being, though, I'm talking just about what happens on a single CPU.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >To repeat something I just said, user-mode programs execute at <em>PASSIVE_LEVEL</em>. When a user-mode program calls a function in the native API, the CPU switches to kernel mode but continues to run at <em>PASSIVE_LEVEL</em> in the same thread context. Many times, the native API function calls an entry point in a driver without raising the IRQL. Driver dispatch routines for most types of I/O request packet (IRP) execute at <em>PASSIVE_LEVEL</em>. In addition, certain driver subroutines, such as <em>DriverEntry</em> and <em>AddDevice</em>, execute at <em>PASSIVE_LEVEL</em> in the context of a system thread. In all of these cases, the driver code can be preempted just as a user-mode application can be.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Certain common driver routines execute at <em>DISPATCH_LEVEL</em>, which is higher than <em>PASSIVE_LEVEL</em>. These include the <em>StartIo</em> routine, deferred procedure call (DPC) routines, and many others. What they have in common is a need to access fields in the device object and the device extension without interference from driver dispatch routines and one another. When one of these routines is running, the rule stated earlier guarantees that no thread can preempt it on the same CPU to execute a driver dispatch routine because the dispatch routine runs at a lower IRQL. Furthermore, no thread can preempt it to run another of these special routines because that other routine will run at the same IRQL.
</span></p><p style="background: #99ccff;"   ><span style="font-family:Segoe UI; font-size:12pt;"   ><strong>NOTE</strong>
<br><em>Dispatch routine</em> and <em>DISPATCH_LEVEL</em> unfortunately have similar names. Dispatch routines are so called because the I/O Manager dispatches I/O requests to them. <em>DISPATCH_LEVEL</em> is so called because it's the IRQL at which the kernel's thread dispatcher originally ran when deciding which thread to run next. (The thread dispatcher runs at <em>SYNCH_LEVEL</em>, if you care. This is the same as <em>DISPATCH_LEVEL</em> on a uniprocessor machine, if you <em>really</em> care.)
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Between <em>DISPATCH_LEVEL</em> and <em>PROFILE_LEVEL</em> is room for various hardware interrupt levels. In general, each device that generates interrupts has an IRQL that defines its interrupt priority vis-à-vis other devices. A WDM driver discovers the IRQL for its interrupt when it receives an <em>IRP_MJ_PNP</em> request with the minor function code <em>IRP_MN_START_DEVICE</em>. The device's interrupt level is one of the many items of configuration information passed as a parameter to this request. We often refer to this level as the <em>device IRQL</em>, or DIRQL for short. DIRQL isn't a single request level. Rather, it's the IRQL for the interrupt associated with whichever device is under discussion at the time.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >The other IRQL levels have meanings that sometimes depend on the particular CPU architecture. Since those levels are used internally by the kernel, their meanings aren't especially germane to the job of writing a device driver. The purpose of <em>APC_LEVEL</em>, for example, is to allow the system to schedule an <em>asynchronous procedure call</em> (APC), which I'll describe in detail later in this chapter. Operations that occur at <em>HIGH_LEVEL</em> include taking a memory snapshot just prior to hibernating the computer, processing a bug check, handling a totally spurious interrupt, and others. I'm not going to attempt to provide an exhaustive list here because, as I said, you and I don't really need to know all the details.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >To summarize, drivers are normally concerned with three interrupt request levels:
</span></p><ul><li><span style="font-family:Segoe UI; font-size:12pt;"   ><em>PASSIVE_LEVEL</em>, at which many dispatch routines and a few special routines execute
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   ><em>DISPATCH_LEVEL</em>, at which <em>StartIo</em> and DPC routines execute
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   ><em>DIRQL</em>, at which an interrupt service routine executes
</span></li></ul><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >IRQL in Operation 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >To illustrate the importance of IRQL, refer to Figure 4-2, which illustrates a possible time sequence of events on a single CPU. At the beginning of the sequence, the CPU is executing at <em>PASSIVE_LEVEL</em>. At time <em>t1</em>, an interrupt arrives whose service routine executes at IRQL-1, one of the levels between <em>DISPATCH_LEVEL</em> and <em>PROFILE_LEVEL</em>. Then, at time <em>t2</em>, another interrupt arrives whose service routine executes at IRQL-2, which is less than IRQL-1. Because of the rule already discussed, the CPU continues servicing the first interrupt. When the first interrupt service routine completes at time <em>t3</em>, it might request a DPC. DPC routines execute at <em>DISPATCH_LEVEL</em>. Consequently, the highest priority pending activity is the service routine for the second interrupt, which therefore executes next. When it finishes at <em>t4</em>, assuming nothing else has occurred in the meantime, the DPC will run at <em>DISPATCH_LEVEL</em>. When the DPC routine finishes at <em>t5</em>, IRQL can drop back to <em>PASSIVE_LEVEL</em>.
</span></p><p><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img1.ph.126.net_O0okjBqXf-fPrm365SVgag==_6597803140913990518.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p><span style="font-family:宋体; font-size:12pt;"   ><strong>Figure 4-2.</strong>
<em>Interrupt priority in action.</em>
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >IRQL Compared with Thread Priorities 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Thread priority is a very different concept from IRQL. Thread priority controls the actions of the scheduler in deciding when to preempt running threads and what thread to start running next. The only "priority" that means anything at IRQLs above <em>APC_LEVEL</em> is IRQL itself, and it controls which programs can execute rather than the thread context within which they execute.
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >IRQL and Paging 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >One consequence of running at elevated IRQL is that the system becomes incapable of servicing page faults. The rule this fact implies is simply stated:
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   ><em>Code executing at or above DISPATCH_LEVEL must not cause page faults.</em>
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >One implication of this rule is that any of the subroutines in your driver that execute at or above <em>DISPATCH_LEVEL</em> must be in nonpaged memory. Furthermore, all the data you access in such a subroutine must also be in nonpaged memory. Finally, as IRQL rises, fewer and fewer kernel-mode support routines are available for your use.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >The DDK documentation explicitly states the IRQL restrictions on support routines. For example, the entry for <em>KeWaitForSingleObject</em> indicates two restrictions:
</span></p><ul><li><span style="font-family:Segoe UI; font-size:12pt;"   >The caller must be running at or below <em>DISPATCH_LEVEL</em>.
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >If a nonzero timeout period is specified in the call, the caller must be running strictly below <em>DISPATCH_LEVEL</em>.
</span></li></ul><p><span style="font-family:Segoe UI; font-size:12pt;"   >Reading between the lines, what is being said here is this: if the call to <em>KeWaitForSingleObject</em> might conceivably block for any period of time (that is, you've specified a nonzero timeout), you must be below <em>DISPATCH_LEVEL</em>, where thread blocking is permitted. If all you want to do is check to see whether an event has been signaled, however, you can be at <em>DISPATCH_LEVEL</em>. You can't call this routine at all from an interrupt service routine or other routine running above <em>DISPATCH_LEVEL</em>.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >For the sake of completeness, it's well to point out that the rule against page faults is really a rule prohibiting any sort of hardware exception, including page faults, divide checks, bounds exceptions, and so on. Software exceptions, like quota violations and probe failures on nonpaged memory, are permissible. Thus, it's acceptable to call <em>ExAllocatePoolWithQuota</em> to allocate nonpaged memory at <em>DISPATCH_LEVEL</em>.
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >Implicitly Controlling IRQL 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Most of the time, the system calls the routines in your driver at the correct IRQL for the activities you're supposed to carry out. Although I haven't discussed many of these routines in detail, I want to give you an example of what I mean. Your first encounter with a new I/O request occurs when the I/O Manager calls one of your dispatch routines to process an IRP. The call usually occurs at <em>PASSIVE_LEVEL</em> because you might need to block the calling thread and you might need to call any support routine at all. You can't block a thread at a higher IRQL, of course, and <em>PASSIVE_LEVEL</em> is the level at which there are the fewest restrictions on the support routines you can call.
</span></p><p style="background: #99ccff;"   ><span style="font-family:Segoe UI; font-size:12pt;"   ><strong>NOTE</strong>
<br>Driver dispatch routines <em>usually </em>execute at <em>PASSIVE_LEVEL</em> but not always. You can designate that you want to receive <em>IRP_MJ_POWER</em> requests at <em>DISPATCH_LEVEL</em> by setting the <em>DO_POWER_INRUSH</em> flag, or by clearing the <em>DO_POWER_PAGABLE</em> flag, in a device object. Sometimes a driver architecture requires that other drivers be able to send certain IRPs at <em>DISPATCH_LEVEL</em>. The USB bus driver, for example, accepts data transfer requests at <em>DISPATCH_LEVEL</em> or below. A standard serial-port driver accepts any read, write, or control operation at or below <em>DISPATCH_LEVEL</em>.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >If your dispatch routine queues the IRP by calling <em>IoStartPacket</em>, your next encounter with the request will be when the I/O Manager calls your <em>StartIo</em> routine. This call occurs at <em>DISPATCH_LEVEL</em> because the system needs to access the queue of I/O requests without interference from the other routines that are inserting and removing IRPs from the queue. As I'll discuss later in this chapter, queue access occurs under protection of a spin lock, and that carries with it execution at <em>DISPATCH_LEVEL</em>.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Later on, your device might generate an interrupt, whereupon your interrupt service routine will be called at DIRQL. It's likely that some registers in your device can't safely be shared. If you access those registers only at DIRQL, you can be sure that no one can interfere with your interrupt service routine (ISR) on a single-CPU computer. If other parts of your driver need to access these crucial hardware registers, you would guarantee that those other parts execute only at DIRQL. The <em>KeSynchronizeExecution</em> service function helps you enforce that rule, and I'll discuss it in Chapter 7 in connection with interrupt handling.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Still later, you might arrange to have a DPC routine called. DPC routines execute at <em>DISPATCH_LEVEL</em> because, among other things, they need to access your IRP queue to remove the next request from a queue and pass it to your <em>StartIo</em> routine. You call the <em>IoStartNextPacket</em> service routine to extract the next request from the queue, and it must be called at <em>DISPATCH_LEVEL</em>. It might call your <em>StartIo</em> routine before returning. Notice how neatly the IRQL requirements dovetail here: queue access, the call to <em>IoStartNextPacket</em>, and the possible call to <em>StartIo</em> are all required to occur at <em>DISPATCH_LEVEL</em>, and that's the level at which the system calls the DPC routine.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Although it's possible for you to explicitly control IRQL (and I'll explain how in the next section), there's seldom any reason to do so because of the correspondence between your needs and the level at which the system calls you. Consequently, you don't need to get hung up on which IRQL you're executing at from moment to moment: it's almost surely the correct level for the work you're supposed to do right then.
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >Explicitly Controlling IRQL 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >When necessary, you can raise and subsequently lower the IRQL on the current processor by calling <em>KeRaiseIrql</em> and <em>KeLowerIrql</em>. For example, from within a routine running at <em>PASSIVE_LEVEL</em>:
</span></p><p style="background: #eeeeee;"   >            
&nbsp;</p><p style="background: #eeeeee;"   ><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img0.ph.126.net_o4xZqAEMBOlx3ioSmM3vXg==_6597594233704706412.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KIRQL&nbsp;oldirql;
</span></p><p style="background: #eeeeee;"   ><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img2.ph.126.net__EBI9_cMmbgnY324V8ey_Q==_3370099896256938302.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >ASSERT(KeGetCurrentIrql()&nbsp;&lt;=&nbsp;DISPATCH_LEVEL);
</span></p><p style="background: #eeeeee;"   ><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img2.ph.126.net_H7N_pPzdlfvxITOzl3BlKg==_2155816846727030966.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeRaiseIrql(DISPATCH_LEVEL,&nbsp;&amp;oldirql);
</span></p><p style="background: #eeeeee;"   ><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><img title="Interrupt Request Level - Howie - Dspace"   src="pic/img1.ph.126.net_5udh8OZH1XsjZvlt6VWofw==_3276931678965731062.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeLowerIrql(oldirql);
</span></p><ol><li><span style="font-family:Segoe UI; font-size:12pt;"   >KIRQL is the typedef name for an integer that holds an IRQL value. We'll need a variable to hold the current IRQL, so we declare it this way.
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >This <em>ASSERT</em> expresses a necessary condition for calling <em>KeRaiseIrql</em>: the new IRQL must be greater than or equal to the current level. If this relation isn't true, <em>KeRaiseIrql</em> will bugcheck (that is, report a fatal error via a blue screen of death).
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   ><em>KeRaiseIrql</em> raises the current IRQL to the level specified by the first argument. It also saves the current IRQL at the location pointed to by the second argument. In this example, we're raising IRQL to <em>DISPATCH_LEVEL</em> and saving the current level in <em>oldirql</em>.
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >After executing whatever code we desired to execute at elevated IRQL, we lower the request level back to its previous value by calling <em>KeLowerIrql</em> and specifying the <em>oldirql</em> value previously returned by <em>KeRaiseIrql</em>.
</span></li></ol><p><span style="font-family:Segoe UI; font-size:12pt;"   >After raising the IRQL, you should eventually restore it to the original value. Otherwise, various assumptions made by code you call later or by the code that called you can later turn out to be incorrect. The DDK documentation says that you must always call <em>KeLowerIrql</em> with the same value as that returned by the immediately preceding call to <em>KeRaiseIrql</em>, but this information isn't exactly right. The only rule that <em>KeLowerIrql</em> actually applies is that the new IRQL must be less than or equal to the current one. You can lower the IRQL in steps if you want to.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >It's a mistake (and a big one!) to lower IRQL below whatever it was when a system routine called your driver, even if you raise it back before returning. Such a break in synchronization might allow some activity to preempt you and interfere with a data object that your caller assumed would remain inviolate.</span></p>
</body></html>