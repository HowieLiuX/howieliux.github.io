<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] 深度解析VC中的消息</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] 深度解析VC中的消息</h2>
<p align="right">发布时间：2010-6-18 18:48
<br>分类名称：windows</p><br>
<div>今日见到BN_CLICK，突然联想，这消息和WM_CHAR,WM_COMMAND是啥关系？</div>在Windows上开发很久，对消息的概念总是一知半解，如同森林里面只了解几颗树木。对事物得有整体把握与认识，才能变通，才能了解其更本。所以，重新学会基础的知识。下面是转载了一则很详细的教程。（虽然此文在说到了消息队列，不过还是没有说清楚，建议看核心编程第4版最后章节关于消息的讲解，说的很透彻）<div>原文地址：http://blog.csdn.net/hustli/category/12732.aspx</div><div><span style="font-family: verdana, sans-serif; line-height: 21px;"><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;<font color="#1111ee">&nbsp; 摘要：Windows编程和Dos编程，一个很大的区别就是，windows编程是事件驱动，消息传递的。所以，要做好windows编程，必须对消息机制有一个清楚的认识，本文希望能够对消息的传递做一个全面的论述，由于小生初学VC，里面可能有一些错误的地方，还往各位大虾批评、指正。</font></p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#f70909" size="5">消息是指什么？</font><br>&nbsp;&nbsp;&nbsp;&nbsp; 消息系统对于一个win32程序来说十分重要，它是一个程序运行的动力源泉。一个消息，是系统定义的一个32位的值，他唯一的定义了一个事件，向Windows发出一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序。<br>&nbsp;&nbsp;&nbsp; 消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做MSG，MSG含有来自windows应用程序消息队列的消息信息，它在Windows中声明如下：<br>&nbsp;&nbsp;&nbsp; typedef struct tagMsg<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND&nbsp;&nbsp;&nbsp; hwnd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接受该消息的窗口句柄<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT&nbsp;&nbsp;&nbsp; message;&nbsp;&nbsp;&nbsp; 消息常量标识符，也就是我们通常所说的消息号<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WPARAM&nbsp; wParam;&nbsp;&nbsp;&nbsp;&nbsp; 32位消息的特定附加信息，确切含义依赖于消息值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPARAM&nbsp; lParam;&nbsp;&nbsp;&nbsp;&nbsp; 32位消息的特定附加信息，确切含义依赖于消息值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息创建时的时间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POINT&nbsp;&nbsp; pt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息创建时的鼠标/光标在屏幕坐标系中的位置<br>&nbsp;&nbsp;&nbsp; }MSG;<br>&nbsp;&nbsp;&nbsp; 消息可以由系统或者应用程序产生。系统在发生输入事件时产生消息。举个例子, 当用户敲键, 移动鼠标或者单击控件。系统也产生消息以响应由应用程序带来的变化, 比如应用程序改变系统字体改变窗体大小。应用程序可以产生消息使窗体执行任务，或者与其他应用程序中的窗口通讯。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;"><font color="#e61a1a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#e61a1a" size="5">消息中有什么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font>我们给出了上面的注释，是不是会对消息结构有了一个比较清楚的认识？如果还没有，那么我们再试着给出下面的解释：<br>&nbsp;&nbsp;&nbsp;&nbsp; hwnd 32位的窗口句柄。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。<br>&nbsp;&nbsp;&nbsp;&nbsp; message用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。消息标识符以常量命名的方式指出消息的含义。当窗口过程接收到消息之后，他就会使用消息标识符来决定如何处理消息。例如、WM_PAINT告诉窗口过程窗体客户区被改变了需要重绘。符号常量指定系统消息属于的类别，其前缀指明了处理解释消息的窗体的类型。<br>&nbsp;&nbsp;&nbsp;&nbsp; wParam 通常是一个与消息有关的常量值，也可能是窗口或控件的句柄。<br>&nbsp;&nbsp;&nbsp;&nbsp; lParam 通常是一个指向内存中数据的指针。由于WParam、lParam和Pointer都是32位的，因此，它们之间可以相互转换。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ee1111" size="5">消息标识符的值</font><br>&nbsp;&nbsp;&nbsp;&nbsp; 系统保留消息标识符的值在0x0000在0x03ff(WM_USER-1)范围。这些值被系统定义消息使用。 应用程序不能使用这些值给自己的消息。应用程序消息从WM_USER（0X0400）到0X7FFF，或0XC000到0XFFFF；WM_USER到0X7FFF范围的消息由应用程序自己使用；0XC000到0XFFFF范围的消息用来和其他应用程序通信，我们顺便说一下具有标志性的消息值：<br>&nbsp;&nbsp;&nbsp;&nbsp; WM_NULL---0x0000&nbsp;&nbsp;&nbsp; 空消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0001----0x0087&nbsp;&nbsp;&nbsp; 主要是窗口消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x00A0----0x00A9&nbsp;&nbsp;&nbsp; 非客户区消息&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0100----0x0108&nbsp;&nbsp;&nbsp; 键盘消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0111----0x0126&nbsp;&nbsp;&nbsp; 菜单消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0132----0x0138&nbsp;&nbsp;&nbsp; 颜色控制消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0200----0x020A&nbsp;&nbsp;&nbsp; 鼠标消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0211----0x0213&nbsp;&nbsp;&nbsp; 菜单循环消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0220----0x0230&nbsp;&nbsp;&nbsp; 多文档消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x03E0----0x03E8&nbsp;&nbsp;&nbsp; DDE消息<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_USER<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x8000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WM_APP<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x0400----0x7FFF&nbsp;&nbsp;&nbsp; 应用程序自定义私有消息</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ee1111" size="5">消息有哪几种？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>其实，windows中的消息虽然很多，但是种类并不繁杂，大体上有3种：窗口消息、命令消息和控件通知消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; 窗口消息大概是系统中最为常见的消息，它是指由操作系统和控制其他窗口的窗口所使用的消息。例如CreateWindow、DestroyWindow和MoveWindow等都会激发窗口消息，还有我们在上面谈到的单击鼠标所产生的消息也是一种窗口消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; 命令消息，这是一种特殊的窗口消息，他用来处理从一个窗口发送到另一个窗口的用户请求，例如按下一个按钮，他就会向主窗口发送一个命令消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; 控件通知消息，是指这样一种消息，一个窗口内的子控件发生了一些事情，需要通知父窗口。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑框，以及Windows公共控件如树状视图、列表视图等。例如，单击或双击一个控件、在控件中选择部分文本、操作控件的滚动条都会产生通知消息。 她类似于命令消息，当用户与控件窗口交互时，那么控件通知消息就会从控件窗口发送到它的主窗口。但是这种消息的存在并不是为了处理用户命令，而是为了让主窗口能够改变控件，例如加载、显示数据。例如按下一个按钮，他向父窗口发送的消息也可以看作是一个控件通知消息；单击鼠标所产生的消息可以由主窗口直接处理，然后交给控件窗口处理。<br>&nbsp;&nbsp;&nbsp; 其中窗口消息及控件通知消息主要由窗口类即直接或间接由CWND类派生类处理。相对窗口消息及控件通知消息而言，命令消息的处理对象范围就广得多，它不仅可以由窗口类处理，还可以由文档类，文档模板类及应用类所处理。<br>&nbsp;&nbsp;&nbsp; 由于控件通知消息很重要的，人们用的也比较多，但是具体的含义往往令初学者晕头转向，所以我决定把常见的几个列出来供大家参考：<br>&nbsp;&nbsp;&nbsp; 按扭控件<br>&nbsp;&nbsp;&nbsp; &nbsp;BN_CLICKED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用户单击了按钮<br>&nbsp;BN_DISABLE&nbsp;按钮被禁止<br>&nbsp;BN_DOUBLECLICKED&nbsp; 用户双击了按钮<br>&nbsp;BN_HILITE &nbsp;用/户加亮了按钮<br>&nbsp;BN_PAINT&nbsp;&nbsp;按钮应当重画<br>&nbsp;BN_UNHILITE&nbsp;加亮应当去掉<br>&nbsp;&nbsp;&nbsp; 组合框控件<br>&nbsp;CBN_CLOSEUP&nbsp;组合框的列表框被关闭<br>&nbsp;CBN_DBLCLK&nbsp;用户双击了一个字符串<br>&nbsp;CBN_DROPDOWN&nbsp;组合框的列表框被拉出<br>&nbsp;CBN_EDITCHANGE&nbsp;用户修改了编辑框中的文本<br>&nbsp;CBN_EDITUPDATE&nbsp;编辑框内的文本即将更新<br>&nbsp;CBN_ERRSPACE&nbsp;组合框内存不足<br>&nbsp;CBN_KILLFOCUS&nbsp;组合框失去输入焦点<br>&nbsp;CBN_SELCHANGE&nbsp;在组合框中选择了一项<br>&nbsp;CBN_SELENDCANCEL&nbsp;用户的选择应当被取消<br>&nbsp;CBN_SELENDOK&nbsp;用户的选择是合法的<br>&nbsp;CBN_SETFOCUS&nbsp;组合框获得输入焦点<br>&nbsp;&nbsp;&nbsp; 编辑框控件<br>&nbsp;EN_CHANGE&nbsp;编辑框中的文本己更新<br>&nbsp;EN_ERRSPACE&nbsp;编辑框内存不足<br>&nbsp;EN_HSCROLL&nbsp;用户点击了水平滚动条<br>&nbsp;EN_KILLFOCUS&nbsp;编辑框正在失去输入焦点<br>&nbsp;EN_MAXTEXT&nbsp;插入的内容被截断<br>&nbsp;EN_SETFOCUS&nbsp;编辑框获得输入焦点<br>&nbsp;EN_UPDATE&nbsp;编辑框中的文本将要更新<br>&nbsp;EN_VSCROLL&nbsp;用户点击了垂直滚动条消息含义<br>&nbsp;列表框控件<br>&nbsp;LBN_DBLCLK&nbsp;用户双击了一项<br>&nbsp;LBN_ERRSPACE&nbsp;列表框内存不够<br>&nbsp;LBN_KILLFOCUS&nbsp;列表框正在失去输入焦点<br>&nbsp;LBN_SELCANCEL&nbsp;选择被取消<br>&nbsp;LBN_SELCHANGE&nbsp;选择了另一项<br>&nbsp;LBN_SETFOCUS&nbsp;列表框获得输入焦点<br></p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;"><span style="line-height: 21px;"><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp; &nbsp;&nbsp;<font size="5"><font color="#e61a1a">队列消息和非队列消息</font><br>&nbsp;&nbsp;&nbsp;</font>从消息的发送途径来看，消息可以分成2种：队列消息和非队列消息。消息队列由可以分成系统消息队列和线程消息队列。系统消息队列由Windows维护，线程消息队列则由每个GUI线程自己进行维护，为避免给non-GUI现成创建消息队列，所有线程产生时并没有消息队列，仅当线程第一次调用GDI函数数系统给线程创建一个消息队列。队列消息送到系统消息队列，然后到线程消息队列；非队列消息直接送给目的窗口过程。<br>&nbsp;&nbsp;&nbsp;&nbsp; 对于队列消息，最常见的是鼠标和键盘触发的消息，例如WM_MOUSERMOVE,WM_CHAR等消息，还有一些其它的消息，例如：WM_PAINT、WM_TIMER和WM_QUIT。当鼠标、键盘事件被触发后，相应的鼠标或键盘驱动程序就会把这些事件转换成相应的消息，然后输送到系统消息队列，由Windows系统去进行处理。Windows系统则在适当的时机，从系统消息队列中取出一个消息，根据前面我们所说的MSG消息结构确定消息是要被送往那个窗口，然后把取出的消息送往创建窗口的线程的相应队列，下面的事情就该由线程消息队列操心了，Windows开始忙自己的事情去了。线程看到自己的消息队列中有消息，就从队列中取出来，通过操作系统发送到合适的窗口过程去处理。<br>&nbsp;&nbsp;&nbsp;&nbsp; 一般来讲，系统总是将消息Post在消息队列的末尾。这样保证窗口以先进先出的顺序接受消息。然而,WM_PAINT是一个例外，同一个窗口的多个 WM_PAINT被合并成一个 WM_PAINT 消息, 合并所有的无效区域到一个无效区域。合并WM_PAIN的目的是为了减少刷新窗口的次数。<br>&nbsp;&nbsp;&nbsp; 非队列消息将会绕过系统队列和消息队列，直接将消息发送到窗口过程，。系统发送非队列消息通知窗口，系统发送消息通知窗口。 例如,当用户激活一个窗口系统发送WM_ACTIVATE, WM_SETFOCUS, and WM_SETCURSOR。这些消息通知窗口它被激活了。非队列消息也可以由当应用程序调用系统函数产生。例如,当程序调用SetWindowPos系统发送WM_WINDOWPOSCHANGED消息。一些函数也发送非队列消息，例如下面我们要谈到的函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ee1111" size="5">消息的发送</font><br>&nbsp;&nbsp;&nbsp;&nbsp; 了解了上面的这些基础理论之后，我们就可以进行一下简单的消息发送与接收。<br>&nbsp;&nbsp;&nbsp;&nbsp; 把一个消息发送到窗口有3种方式：发送、寄送和广播。<br>&nbsp;&nbsp;&nbsp;&nbsp; 发送消息的函数有SendMessage、SendMessageCallback、SendNotifyMessage、SendMessageTimeout；寄送消息的函数主要有PostMessage、PostThreadMessage、PostQuitMessage；广播消息的函数我知道的只有BroadcastSystemMessage、BroadcastSystemMessageEx。<br>&nbsp;&nbsp;&nbsp;&nbsp; SendMessage的原型如下：LRESULT SendMessage(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)，这个函数主要是向一个或多个窗口发送一条消息，一直等到消息被处理之后才会返回。不过需要注意的是，如果接收消息的窗口是同一个应用程序的一部分，那么这个窗口的窗口函数就被作为一个子程序马上被调用；如果接收消息的窗口是被另外的线程所创建的，那么窗口系统就切换到相应的线程并且调用相应的窗口函数，这条消息不会被放进目标应用程序队列中。函数的返回值是由接收消息的窗口的窗口函数返回，返回的值取决于被发送的消息。<br>&nbsp;&nbsp;&nbsp;&nbsp; PostMessage的原型如下：BOOL PostMessage(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)，该函数把一条消息放置到创建hWnd窗口的线程的消息队列中，该函数不等消息被处理就马上将控制返回。需要注意的是，如果hWnd参数为HWND_BROADCAST，那么，消息将被寄送给系统中的所有的重叠窗口和弹出窗口，但是子窗口不会收到该消息；如果hWnd参数为NULL，则该函数类似于将dwThreadID参数设置成当前线程的标志来调用PostThreadMEssage函数。<br>　　　从上面的这２个具有代表性的函数，我们可以看出消息的发送方式和寄送方式的区别所在：被发送的消息是否会被立即处理，函数是否立即返回。被发送的消息会被立即处理，处理完毕后函数才会返回；被寄送的消息不会被立即处理，他被放到一个先进先出的队列中，一直等到应用程序空线的时候才会被处理，不过函数放置消息后立即返回。<br>　　　实际上，发送消息到一个窗口处理过程和直接调用窗口处理过程之间并没有太大的区别，他们直接的唯一区别就在于你可以要求操作系统截获所有被发送的消息，但是不能够截获对窗口处理过程的直接调用。<br>　　　以寄送方式发送的消息通常是与用户输入事件相对应的，因为这些事件不是十分紧迫，可以进行缓慢的缓冲处理，例如鼠标、键盘消息会被寄送，而按钮等消息则会被发送。<br>　　　广播消息用得比较少，BroadcastSystemMessage函数原型如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long BroadcastSystemMessage(DWORD dwFlags,LPDWORD lpdwRecipients,UINT uiMessage,WPARAM wParam,LPARAM lParam);该函数可以向指定的接收者发送一条消息，这些接收者可以是应用程序、可安装的驱动程序、网络驱动程序、系统级别的设备驱动消息和他们的任意组合。需要注意的是，如果dwFlags参数是BSF_QUERY并且至少一个接收者返回了BROADCAST_QUERY_DENY，则返回值为０，如果没有指定BSF_QUERY，则函数将消息发送给所有接收者，并且忽略其返回值。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">　　　<font color="#e61a1a" size="5"><font color="#f70909">消息的接收</font><br>　　</font>消息的接收主要有３个函数：GetMessage、PeekMessage、WaitMessage。<br>　　　GetMessage原型如下：BOOL GetMessage(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax);该函数用来获取与hWnd参数所指定的窗口相关的且wMsgFilterMin和wMsgFilterMax参数所给出的消息值范围内的消息。需要注意的是，如果hWnd为NULL，则GetMessage获取属于调用该函数应用程序的任一窗口的消息，如果wMsgFilterMin和wMsgFilterMax都是０，则GetMessage就返回所有可得到的消息。函数获取之后将删除消息队列中的除WM_PAINT消息之外的其他消息，至于WM_PAINT则只有在其处理之后才被删除。<br>　　　PeekMessage原型如下：BOOL PeekMessage(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax,UINT wRemoveMsg）；该函数用于查看应用程序的消息队列，如果其中有消息就将其放入lpMsg所指的结构中，不过，与GetMessage不同的是，PeekMessage函数不会等到有消息放入队列时才返回。同样，如果hWnd为NULL，则PeekMessage获取属于调用该函数应用程序的任一窗口的消息，如果hWnd=-1，那么函数只返回把hWnd参数为NULL的PostAppMessage函数送去的消息。如果wMsgFilterMin和wMsgFilterMax都是０，则PeekMessage就返回所有可得到的消息。函数获取之后将删除消息队列中的除WM_PAINT消息之外的其他消息，至于WM_PAINT则只有在其处理之后才被删除。<br>　　　WaitMessage原型如下：BOOL VaitMessage();当一个应用程序无事可做时，该函数就将控制权交给另外的应用程序，同时将该应用程序挂起，直到一个新的消息被放入应用程序的队列之中才返回。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ee3d11" size="5">消息的处理</font><br>　　　接下来我们谈一下消息的处理，首先我们来看一下VC中的消息泵：<br>　　　while(GetMessage(&amp;msg, NULL, 0, 0))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br>&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先，GetMessage从进程的主线程的消息队列中获取一个消息并将它复制到MSG结构，如果队列中没有消息，则GetMessage函数将等待一个消息的到来以后才返回。 如果你将一个窗口句柄作为第二个参数传入GetMessage，那么只有指定窗口的的消息可以从队列中获得。GetMessage也可以从消息队列中过滤消息只接受消息队列中落在范围内的消息。这时候就要利用GetMessage／PeekMessage指定一个消息过滤器。这个过滤器是一个消息标识符的范围或者是一个窗体句柄，或者两者同时指定。当应用程序要查找一个后入消息队列的消息是很有用。WM_KEYFIRST 和 WM_KEYLAST 常量用于接受所有的键盘消息。 WM_MOUSEFIRST 和 WM_MOUSELAST 常量用于接受所有的鼠标消息。&nbsp;<br>　　　然后TranslateAccelerator判断该消息是不是一个按键消息并且是一个加速键消息，如果是，则该函数将把几个按键消息转换成一个加速键消息传递给窗口的回调函数。处理了加速键之后，函数TranslateMessage将把两个按键消息WM_KEYDOWN和WM_KEYUP转换成一个WM_CHAR，不过需要注意的是，消息WM_KEYDOWN,WM_KEYUP仍然将传递给窗口的回调函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>　　　处理完之后，DispatchMessage函数将把此消息发送给该消息指定的窗口中已设定的回调函数。如果消息是WM_QUIT，则GetMessage返回０，从而退出循环体。应用程序可以使用PostQuitMessage来结束自己的消息循环。通常在主窗口的WM_DESTROY消息中调用。<br>　　　下面我们举一个常见的小例子来说明这个消息泵的运用：<br>　　　if (::PeekMessage(&amp;msg, m_hWnd, WM_KEYFIRST,WM_KEYLAST, PM_REMOVE))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg.message == WM_KEYDOWN &amp;&amp; msg.wParam == VK_ESCAPE)．．．<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp; 　　这里我们接受所有的键盘消息，所以就用WM_KEYFIRST 和 WM_KEYLAST作为参数。最后一个参数可以是PM_NOREMOVE 或者 PM_REMOVE，表示消息信息是否应该从消息队列中删除。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; 　所以这段小代码就是判断是否按下了Esc键，如果是就进行处理。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">　　　<font color="#f73809" size="5">窗口过程</font><br>　　　窗口过程是一个用于处理所有发送到这个窗口的消息的函数。任何一个窗口类都有一个窗口过程。同一个类的窗口使用同样的窗口过程来响应消息。 系统发送消息给窗口过程将消息数据作为参数传递给他，消息到来之后，按照消息类型排序进行处理，其中的参数则用来区分不同的消息，窗口过程使用参数产生合适行为。<br>　　　一个窗口过程不经常忽略消息，如果他不处理，它会将消息传回到执行默认的处理。窗口过程通过调用DefWindowProc来做这个处理。窗口过程必须return一个值作为它的消息处理结果。大多数窗口只处理小部分消息和将其他的通过DefWindowProc传递给系统做默认的处理。窗口过程被所有属于同一个类的窗口共享，能为不同的窗口处理消息。下面我们来看一下具体的实例：<br>　　　LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br>　　　{<br>&nbsp;int wmId, wmEvent;<br>&nbsp;PAINTSTRUCT ps;<br>&nbsp;HDC hdc;<br>&nbsp;TCHAR szHello[MAX_LOADSTRING];<br>&nbsp;LoadString(hInst, IDS_HELLO, szHello, MAX_LOADSTRING);</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;switch (message)&nbsp;<br>&nbsp;{<br>&nbsp;&nbsp;case WM_COMMAND:<br>&nbsp;&nbsp;&nbsp;wmId&nbsp;&nbsp;&nbsp; = LOWORD(wParam);&nbsp;<br>&nbsp;&nbsp;&nbsp;wmEvent = HIWORD(wParam);&nbsp;<br>&nbsp;&nbsp;&nbsp;// Parse the menu selections:<br>&nbsp;&nbsp;&nbsp;switch (wmId)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;case IDM_ABOUT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;case IDM_EXIT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestroyWindow(hWnd);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DefWindowProc(hWnd, message, wParam, lParam);<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;case WM_PAINT:<br>&nbsp;&nbsp;&nbsp;hdc = BeginPaint(hWnd, &amp;ps);<br>&nbsp;&nbsp;&nbsp;// TODO: Add any drawing code here...<br>&nbsp;&nbsp;&nbsp;RECT rt;<br>&nbsp;&nbsp;&nbsp;GetClientRect(hWnd, &amp;rt);<br>&nbsp;&nbsp;&nbsp;DrawText(hdc, szHello, strlen(szHello), &amp;rt, DT_CENTER);<br>&nbsp;&nbsp;&nbsp;EndPaint(hWnd, &amp;ps);<br>&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;case WM_DESTROY:<br>&nbsp;&nbsp;&nbsp;PostQuitMessage(0);<br>&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;return DefWindowProc(hWnd, message, wParam, lParam);<br>&nbsp; 　　　 }<br>&nbsp; 　　 return 0;<br>　　　}</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">　　　<font color="#ee1111" size="5">消息分流器</font><br>　　　通常的窗口过程是通过一个switch语句来实现的，这个事情很烦，有没有更简便的方法呢？有，那就是消息分流器，利用消息分流器，我们可以把switch语句分成更小的函数，每一个消息都对应一个小函数，这样做的好处就是对消息更容易管理。<br>　　　之所以被称为消息分流器，就是因为它可以对任何消息进行分流。下面我们做一个函数就很清楚了：<br>　　　void MsgCracker(HWND hWnd,int id,HWND hWndCtl,UINT codeNotify)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(id)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; case ID_A:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ID_B:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后我们修改一下窗口过程：<br>　　　LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;switch(message)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE_MSG(hWnd,WM_COMMAND,MsgCracker);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HANDLE_MSG(hWnd,WM_DESTROY,MsgCracker);<br>&nbsp;&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;return DefWindowProc(hWnd, message, wParam, lParam);<br>&nbsp; 　　　 }<br>&nbsp; 　　&nbsp;&nbsp; return 0;<br>　　　}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在WindowsX.h中定义了如下的HANDLE_MSG宏：<br>　　　#define HANDLE_MSG(hwnd,msg,fn) \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(msg): return HANDLE_##msg((hwnd),(wParam),(lParam),(fn));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际上，HANDLE_WM_XXXX都是宏，例如：HANDLE_MSG(hWnd,WM_COMMAND,MsgCracker);将被转换成如下定义：<br>　　　#define HANDLE_WM_COMMAND(hwnd,wParam,lParam,fn)\&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((fn)((hwnd),(int)(LOWORD(wParam)),(HWND)(lParam),(UINT)HIWORD(wParam)),0L);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 好了，事情到了这一步，应该一切都明朗了。<br>　　　不过，我们发现在windowsx.h里面还有一个宏：FORWARD_WM_XXXX，我们还是那WM_COMMAND为例，进行分析：<br>　　　#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \<br>&nbsp;&nbsp;&nbsp;&nbsp; (void)(fn)((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))<br>　　　所以实际上，FORWARD_WM_XXXX将消息参数进行了重新构造，生成了wParam &amp;&amp; lParam，然后调用了我们定义的函数。<br>　　　好了，事情到这里也算是也段落了，明天我们在分析消息在MFC中的处理。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;"><span style="line-height: 21px;"><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">　　前面，我们分析了消息的基本理论和基本的函数及用法，接下来，我们将进一步讨论消息传递在MFC中的实现。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;"><br>　　<font color="#ee1111" size="5">MFC消息的处理实现方式</font><br>　　初看MFC中的各种消息，以及在头脑中根深蒂固的C++的影响，我们可能很自然的就会想到利用C++的三大特性之一：虚拟机制来实现消息的传递，但是经过分析，我们看到事情并不是想我们想象的那样，在MFC中消息是通过一种所谓的消息映射机制来处理的。<br>　　为什么呢？在潘爱民老师翻译的《Visual C++技术内幕》（第４版）中给出了详细的原因说明，我再简要的说一遍。在CWnd类中大约有110个消息，还有其它的MFC的类呢，算起来消息太多了，在C++中对程序中用到的每一个派生类都要有一个vtable，每一个虚函数在vtable中都要占用一个４字节大小的入口地址，这样一来，对于每个特定类型的窗口或控件，应用程序都需要一个440KB大小的表来支持虚拟消息控件函数。<br>　　如果说上面的窗口或控件可以勉强实现的话，那么对于菜单命令消息及按钮命令消息呢？因为不同的应用程序有不同的菜单和按钮，我们怎么处理呢？在MFC库的这种消息映射系统就避免了使用大的vtable，并且能够在处理常规Windows消息的同时处理各种各样的应用程序的命令消息。<br>　　说白了，MFC中的消息机制其实质是一张巨大的消息及其处理函数的一一对应表，然后加上分析处理这张表的应用框架内部的一些程序代码.这样就可以避免在SDK编程中用到的繁琐的CASE语句。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;<font color="#f70909" size="5">MFC的消息映射的基类CCmdTarget</font><br>　　如果你想让你的控件能够进行消息映射，就必须从CCmdTarget类中派生。CCmdTarget类是MFC处理命令消息的基础、核心。MFC为该类设计了许多成员函数和一些成员数据，基本上是为了解决消息映射问题的，所有响应消息或事件的类都从它派生，例如：应用程序类、框架类、文档类、视图类和各种各样的控件类等等，还有很多。<br>　　不过这个类里面有２个函数对消息映射非常重要，一个是静态成员函数DispatchCmdMsg，另一个是虚函数OnCmdMsg。<br>　　DispatchCmdMsg专门供MFC内部使用，用来分发Windows消息。OnCmdMsg用来传递和发送消息、更新用户界面对象的状态。<br>　　CCmdTarget对OnCmdMsg的默认实现：在当前命令目标(this所指)的类和基类的消息映射数组里搜索指定命令消息的消息处理函数。<br>　　这里使用虚拟函数GetMessageMap得到命令目标类的消息映射入口数组_messageEntries，然后在数组里匹配命令消息ID相同、控制通知代码也相同的消息映射条目。其中GetMessageMap是虚拟函数，所以可以确认当前命令目标的确切类。<br>如果找到了一个匹配的消息映射条目，则使用DispachCmdMsg调用这个处理函数；<br>如果没有找到，则使用_GetBaseMessageMap得到基类的消息映射数组，查找，直到找到或搜寻了所有的基类（到CCmdTarget）为止；<br>如果最后没有找到，则返回FASLE。<br>　　每个从CCmdTarget派生的命令目标类都可以覆盖OnCmdMsg，利用它来确定是否可以处理某条命令，如果不能，就通过调用下一命令目标的OnCmdMsg，把该命令送给下一个命令目标处理。通常，派生类覆盖OnCmdMsg时，要调用基类的被覆盖的OnCmdMsg。<br>　　在MFC框架中，一些MFC命令目标类覆盖了OnCmdMsg，如框架窗口类覆盖了该函数，实现了MFC的标准命令消息发送路径。必要的话，应用程序也可以覆盖OnCmdMsg，改变一个或多个类中的发送规定，实现与标准框架发送规定不同的发送路径。例如，在以下情况可以作这样的处理：在要打断发送顺序的类中把命令传给一个非MFC默认对象；在新的非默认对象中或在可能要传出命令的命令目标中。</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ee1111" size="5">消息映射的内容</font><br>&nbsp;&nbsp;&nbsp; 通过ClassWizard为我们生成的代码，我们可以看到，消息映射基本上分为2大部分：<br>&nbsp;&nbsp;&nbsp; 在头文件(.h)中有一个宏DECLARE_MESSAGE_MAP()，他被放在了类的末尾，是一个public属性的；与之对应的是在实现部分（.cpp)增加了一章消息映射表，内容如下：<br>&nbsp;&nbsp;&nbsp; BEGIN_MESSAGE_MAP(当前类, 当前类的基类)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file://{{AFX_MSG_MAP(CMainFrame)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 消息的入口项<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file://}}AFX_MSG_MAP<br>&nbsp;&nbsp; END_MESSAGE_MAP()<br>&nbsp;&nbsp; 但是仅是这两项还远不足以完成一条消息，要是一个消息工作，必须有以下3个部分去协作：<br>&nbsp;&nbsp; 1.在类的定义中加入相应的函数声明；<br>　 2.在类的消息映射表中加入相应的消息映射入口项；<br>　 3.在类的实现中加入相应的函数体；</p><p style="padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; margin-top: 1em; margin-right: 0px; margin-bottom: 0.5em; margin-left: 0px;">&nbsp;&nbsp;&nbsp;<font color="#ee3d11" size="5">消息的添加</font><br>&nbsp;&nbsp; 有了上面的这些只是作为基础，我们接下来就做我们最熟悉、最常用的工作：添加消息。MFC消息的添加主要有2种方法：自动/手动，我们就以这2种方法为例，说一下如何添加消息。<br>&nbsp;&nbsp; 1、利用Class Wizard实现自动添加<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在菜单中选择View--&gt;Class Wizard，也可以用单击鼠标右键，选择Class Wizard，同样可以激活Class Wizard。选择Message Map标签，从Class name组合框中选取我们想要添加消息的类。在Object IDs列表框中，选取类的名称。此时， Messages列表框显示该类的大多数(若不是全部的话)可重载成员函数和窗口消息。类重载显示在列表的上部，以实际虚构成员函数的大小写字母来表示。其他为窗口消息，以大写字母出现，描述了实际窗口所能响应的消息ID。选中我们向添加的消息，单击Add Function按钮，Class Wizard自动将该消息添加进来。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有时候，我们想要添加的消息本应该出现在Message列表中，可是就是找不到，怎么办？不要着急，我们可以利用Class Wizard上Class Info标签以扩展消息列表。在该页中，找到Message Filter组合框，通过它可以改变首页中Messages列表框中的选项。这里，我们选择Window，从而显示所有的窗口消息，一把情况下，你想要添加的消息就可以在Message列表框中出现了，如果还没有，那就接着往下看：）<br>&nbsp;&nbsp; 2、手动地添加消息处理函数<br>&nbsp;&nbsp;&nbsp; 如果在Messages列表框中仍然看不到我们想要的消息，那么该消息可能是被系统忽略掉或者是你自己创建的，在这种情况下，就必须自己手工添加。根据我们前面所说的消息工作的3个部件，我们一一进行处理：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) 在类的. h文件中添加处理函数的声明，紧接在//}}AFX_MSG行之后加入声明，注意：一定要以afx_msg开头。<br>&nbsp;&nbsp;&nbsp;&nbsp; 通常，添加处理函数声明的最好的地方是源代码中Class Wizard维护的表下面，但是在它标记其领域的｛｛｝｝括弧外面。这些括弧中的任何东西都将会被Class Wizard销毁。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) 接着，在用户类的.cpp文件中找到//}}AFX_MSG_MAP行，紧接在它之后加入消息入口项。同样，也是放在{ {} }的外面<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) 最后，在该文件中添加消息处理函数的实体。</p></span></p></span></p></span></div>
</body></html>