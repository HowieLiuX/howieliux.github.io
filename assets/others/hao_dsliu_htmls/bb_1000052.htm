<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：DRIVER_OBJECT, DEVICE_OBJECT, IRP, IO_STACK_LOCATION, IoCompleteRequest 总结</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>DRIVER_OBJECT, DEVICE_OBJECT, IRP, IO_STACK_LOCATION, IoCompleteRequest 总结</h2>
<p align="right">发布时间：2014-5-13 19:27
<br>分类名称：Driver</p><br>
<p><span style="font-family:宋体;"   >typedef struct _DRIVER_OBJECT {<br>&nbsp;&nbsp;&nbsp;&nbsp;CSHORT Type;<br>&nbsp;&nbsp;&nbsp;&nbsp;CSHORT Size;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following links all of the devices created by a single driver<br>&nbsp;&nbsp;&nbsp;&nbsp;// together on a list, and the Flags word provides an extensible flag<br>&nbsp;&nbsp;&nbsp;&nbsp;// location for driver objects.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// 指向第一个DeviceObject，通过DeviceObject-&gt;NextDevice指向下一个，NextDevice会在IoCreateDevice中进行连接更新<br>&nbsp;&nbsp;&nbsp;&nbsp;// DeviceObject-&gt;DriverObject可以回指对应的DriverObject。<br>&nbsp;&nbsp;&nbsp;&nbsp;PDEVICE_OBJECT DeviceObject;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG Flags;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following section describes where the driver is loaded.  The count<br>&nbsp;&nbsp;&nbsp;&nbsp;// field is used to count the number of times the driver has had its<br>&nbsp;&nbsp;&nbsp;&nbsp;// registered reinitialization routine invoked.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID DriverStart;&nbsp;&nbsp;&nbsp;&nbsp;// Driver被加载到内存后的起始的虚拟地址<br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG DriverSize;&nbsp;&nbsp;&nbsp;&nbsp;// Driver的大小，PE文件中的信息：ntHeaders-&gt;OptionalHeader.SizeOfImage<br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID DriverSection;<br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_EXTENSION DriverExtension;&nbsp;&nbsp;&nbsp;&nbsp;// 见下文：最重要的一项为DriverExtension-&gt;AddDevice。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The driver name field is used by the error log thread<br>&nbsp;&nbsp;&nbsp;&nbsp;// determine the name of the driver that an I/O request is/was bound.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING DriverName;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following section is for registry support.  Thise is a pointer<br>&nbsp;&nbsp;&nbsp;&nbsp;// to the path to the hardware information in the registry<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PUNICODE_STRING HardwareDatabase;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following section contains the optional pointer to an array of<br>&nbsp;&nbsp;&nbsp;&nbsp;// alternate entry points to a driver for "fast I/O" support.  Fast I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;// is performed by invoking the driver routine directly with separate<br>&nbsp;&nbsp;&nbsp;&nbsp;// parameters, rather than using the standard IRP call mechanism.  Note<br>&nbsp;&nbsp;&nbsp;&nbsp;// that these functions may only be used for synchronous I/O, and when<br>&nbsp;&nbsp;&nbsp;&nbsp;// the file is cached.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PFAST_IO_DISPATCH FastIoDispatch;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following section describes the entry points to this particular<br>&nbsp;&nbsp;&nbsp;&nbsp;// driver.  Note that the major function dispatch table must be the last<br>&nbsp;&nbsp;&nbsp;&nbsp;// field in the object so that it remains extensible.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_INITIALIZE DriverInit;&nbsp;&nbsp;&nbsp;&nbsp;// 运行起始地址（不是DriverEntry的地址）。ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint<br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_STARTIO DriverStartIo;<br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_UNLOAD DriverUnload;<br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];<br><br>} DRIVER_OBJECT;<br>typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis<br><br><br>typedef struct _DRIVER_EXTENSION {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Back pointer to Driver Object<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;struct _DRIVER_OBJECT *DriverObject;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The AddDevice entry point is called by the Plug &amp; Play manager<br>&nbsp;&nbsp;&nbsp;&nbsp;// to inform the driver when a new device instance arrives that this<br>&nbsp;&nbsp;&nbsp;&nbsp;// driver must control.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PDRIVER_ADD_DEVICE AddDevice;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The count field is used to count the number of times the driver has<br>&nbsp;&nbsp;&nbsp;&nbsp;// had its registered reinitialization routine invoked.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG Count;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The service name field is used by the pnp manager to determine<br>&nbsp;&nbsp;&nbsp;&nbsp;// where the driver related info is stored in the registry.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;UNICODE_STRING ServiceKeyName;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Note: any new shared fields get added here.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>// end_ntddk end_wdm end_nthal end_ntifs end_ntosp<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The client driver object extension field is used by class driver<br>&nbsp;&nbsp;&nbsp;&nbsp;// to store per driver information.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PIO_CLIENT_EXTENSION ClientDriverExtension;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//  The file system filter callback extension field is used<br>&nbsp;&nbsp;&nbsp;&nbsp;//  to safely notify filters of system operations that were<br>&nbsp;&nbsp;&nbsp;&nbsp;//  previously not shown to file system filters.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PFS_FILTER_CALLBACKS FsFilterCallbacks;<br><br>// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp<br><br>} DRIVER_EXTENSION, *PDRIVER_EXTENSION;<br><br><br>typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {<br>&nbsp;&nbsp;&nbsp;&nbsp;CSHORT Type;&nbsp;&nbsp;&nbsp;&nbsp;// IO_TYPE_DEVICE<br>&nbsp;&nbsp;&nbsp;&nbsp;USHORT Size;&nbsp;&nbsp;&nbsp;&nbsp;// (USHORT) (sizeof( DEVICE_OBJECT ) + 用户创建的DeviceExtensionSize);<br>&nbsp;&nbsp;&nbsp;&nbsp;LONG ReferenceCount;&nbsp;&nbsp;&nbsp;&nbsp;// <br>&nbsp;&nbsp;&nbsp;&nbsp;struct _DRIVER_OBJECT *DriverObject;&nbsp;&nbsp;&nbsp;&nbsp;// 回指对应DriverObject<br>&nbsp;&nbsp;&nbsp;&nbsp;struct _DEVICE_OBJECT *NextDevice;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 下一个DeviceObject<br>&nbsp;&nbsp;&nbsp;&nbsp;struct _DEVICE_OBJECT *AttachedDevice;&nbsp;&nbsp;&nbsp;&nbsp;// 上一层有Device挂着，指向上面的Device。<br>&nbsp;&nbsp;&nbsp;&nbsp;struct _IRP *CurrentIrp;&nbsp;&nbsp;&nbsp;&nbsp;// 一般在StartIo中使用，当前处理的IRP。<br>&nbsp;&nbsp;&nbsp;&nbsp;PIO_TIMER Timer;<br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG Flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See above:  DO_DIRECT_IO, DO_BUFFERED_IO, DO_DEVICE_INITIALIZING ...<br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG Characteristics;&nbsp;&nbsp;&nbsp;&nbsp;// See ntioapi:  FILE_...<br>&nbsp;&nbsp;&nbsp;&nbsp;PVPB Vpb;<br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID DeviceExtension;&nbsp;&nbsp;&nbsp;&nbsp;// 用户自己使用的Buffer区域。<br>&nbsp;&nbsp;&nbsp;&nbsp;DEVICE_TYPE DeviceType;&nbsp;&nbsp;&nbsp;&nbsp;// 用户传入的DeviceType，如FILE_DEVICE_UNKNOWN，FILE_DEVICE_SMARTCARD<br>&nbsp;&nbsp;&nbsp;&nbsp;CCHAR StackSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 一般调用IoAttachDeviceToDeviceStack，会设置此项目，值为下层的StackSize+1。初始值为：1，在IoCreateDevice时初始化<br>&nbsp;&nbsp;&nbsp;&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST_ENTRY ListEntry;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WAIT_CONTEXT_BLOCK Wcb;<br>&nbsp;&nbsp;&nbsp;&nbsp;} Queue;<br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG AlignmentRequirement;<br>&nbsp;&nbsp;&nbsp;&nbsp;KDEVICE_QUEUE DeviceQueue;&nbsp;&nbsp;&nbsp;&nbsp;// 在StartIo中使用，串起等待处理的IRP们。<br>&nbsp;&nbsp;&nbsp;&nbsp;KDPC Dpc;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//  The following field is for exclusive use by the filesystem to keep<br>&nbsp;&nbsp;&nbsp;&nbsp;//  track of the number of Fsp threads currently using the device<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG ActiveThreadCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;PSECURITY_DESCRIPTOR SecurityDescriptor;<br>&nbsp;&nbsp;&nbsp;&nbsp;KEVENT DeviceLock;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;USHORT SectorSize;<br>&nbsp;&nbsp;&nbsp;&nbsp;USHORT Spare1;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;<br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID  Reserved;<br>} DEVICE_OBJECT;<br><br><br>typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP {<br>&nbsp;&nbsp;&nbsp;&nbsp;CSHORT Type;&nbsp;&nbsp;&nbsp;&nbsp;// 一般为IO_TYPE_IRP（0x00000006）<br>&nbsp;&nbsp;&nbsp;&nbsp;USHORT Size;&nbsp;&nbsp;&nbsp;&nbsp;// IRP + 和其对应的I/0堆栈的总大小，分配IRP的时候，它们就是一起在堆上分配的空间，所以IRP下面就是I/O堆栈<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Define the common fields used to control the IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Define a pointer to the Memory Descriptor List (MDL) for this I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;// request.  This field is only used if the I/O is "direct I/O".<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PMDL MdlAddress;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Flags word - used to remember various flags.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ULONG Flags;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following union is used for one of three purposes:<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;1. This IRP is an associated IRP.  The field is a pointer to a master<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;   IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;2. This is the master IRP.  The field is the count of the number of<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;   IRPs which must complete (associated IRPs) before the master can<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;   complete.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;3. This operation is being buffered and the field is the address of<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;   the system space buffer.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct _IRP *MasterIrp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__volatile LONG IrpCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID SystemBuffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;} AssociatedIrp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Thread list entry - allows queueing the IRP to the thread pending I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;// request packet list.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;LIST_ENTRY ThreadListEntry;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// I/O status - final status of operation.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;IO_STATUS_BLOCK IoStatus;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Requestor mode - mode of the original requestor of this operation.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;KPROCESSOR_MODE RequestorMode;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Pending returned - TRUE if pending was initially returned as the<br>&nbsp;&nbsp;&nbsp;&nbsp;// status for this packet.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// 在IoComplateRequest函数中，有一句：Irp-&gt;PendingReturned = stackPointer-&gt;Control &amp; SL_PENDING_RETURNED;<br>&nbsp;&nbsp;&nbsp;&nbsp;// 在回弹完成函数时，如果stackPointer-&gt;Control（IoMarkIrpPending可设置)有SL_PENDING_RETURNED，会将其保存到Irp-&gt;PendingReturned<br>&nbsp;&nbsp;&nbsp;&nbsp;// 在完成函数中判断Irp-&gt;PendingReturned，继续调用IoMarkIrpPending，向上传递。<br>&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN PendingReturned;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Stack state information.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;CHAR StackCount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 和 Device-&gt;StackSize 大小一样<br>&nbsp;&nbsp;&nbsp;&nbsp;CHAR CurrentLocation;&nbsp;&nbsp;&nbsp;&nbsp;// 当前Location，初始值为StackCount大小加1，用来和StackCount+1对比，是否到达最上层<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Cancel - packet has been canceled.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// 当IRP被取消时，会被设置为FALSE。如在，IoCancelIrp中被设置为TRUE。<br>&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN Cancel;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Cancel Irql - Irql at which the cancel spinlock was acquired.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// IoAcquireCancelSpinLock得到锁后的IRQL<br>&nbsp;&nbsp;&nbsp;&nbsp;KIRQL CancelIrql;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// ApcEnvironment - Used to save the APC environment at the time that the<br>&nbsp;&nbsp;&nbsp;&nbsp;// packet was initialized.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;CCHAR ApcEnvironment;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Allocation control flags.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;UCHAR AllocationFlags;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// User parameters.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PIO_STATUS_BLOCK UserIosb;<br>&nbsp;&nbsp;&nbsp;&nbsp;PKEVENT UserEvent;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 保存用户层传递的Evnet（如ReadFile异步调用时）<br>&nbsp;&nbsp;&nbsp;&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIO_APC_ROUTINE UserApcRoutine;&nbsp;&nbsp;&nbsp;&nbsp;// 用户层传递的，APC 异步调用函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID IssuingProcess;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID UserApcContext;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// APC 参数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} AsynchronousParameters;&nbsp;&nbsp;&nbsp;&nbsp;// APC异步调用参数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LARGE_INTEGER AllocationSize;<br>&nbsp;&nbsp;&nbsp;&nbsp;} Overlay;&nbsp;&nbsp;&nbsp;&nbsp;//通过名字可以和用户层对应起来，都是Overlay。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// CancelRoutine - Used to contain the address of a cancel routine supplied<br>&nbsp;&nbsp;&nbsp;&nbsp;// by a device driver when the IRP is in a cancelable state.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// IRP取消的时候会被调用<br>&nbsp;&nbsp;&nbsp;&nbsp;__volatile PDRIVER_CANCEL CancelRoutine;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Note that the UserBuffer parameter is outside of the stack so that I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;// completion can copy data back into the user's address space without<br>&nbsp;&nbsp;&nbsp;&nbsp;// having to know exactly which service was being invoked.  The length<br>&nbsp;&nbsp;&nbsp;&nbsp;// of the copy is stored in the second half of the I/O status block. If<br>&nbsp;&nbsp;&nbsp;&nbsp;// the UserBuffer field is NULL, then no copy is performed.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID UserBuffer;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Kernel structures<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The following section contains kernel structures which the IRP needs<br>&nbsp;&nbsp;&nbsp;&nbsp;// in order to place various work information in kernel controller system<br>&nbsp;&nbsp;&nbsp;&nbsp;// queues.  Because the size and alignment cannot be controlled, they are<br>&nbsp;&nbsp;&nbsp;&nbsp;// placed here at the end so they just hang off and do not affect the<br>&nbsp;&nbsp;&nbsp;&nbsp;// alignment of other fields in the IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;union {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DeviceQueueEntry - The device queue entry field is used to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// queue the IRP to the device driver device queue.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// KeInsertDeviceQueue( &amp;DeviceObject-&gt;DeviceQueue, &amp;Irp-&gt;Tail.Overlay.DeviceQueueEntry );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 将IRP和DeviceObject连接起来，使用在StartIO串行方式中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KDEVICE_QUEUE_ENTRY DeviceQueueEntry;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The following are available to the driver to use in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// whatever manner is desired, while the driver owns the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// packet.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID DriverContext[4];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Thread - pointer to caller's Thread Control Block.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// PsGetCurrentThread<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PETHREAD Thread;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Auxiliary buffer - pointer to any auxiliary buffer that is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// required to pass information to a driver that is not contained<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in a normal buffer.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCHAR AuxiliaryBuffer;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The following unnamed structure must be exactly identical<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to the unnamed structure used in the minipacket header used<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for completion queue entries.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// List entry - used to queue the packet to completion queue, among<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// others.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST_ENTRY ListEntry;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Current stack location - contains a pointer to the current<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IO_STACK_LOCATION structure in the IRP stack.  This field<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// should never be directly accessed by drivers.  They should<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// use the standard functions.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct _IO_STACK_LOCATION *CurrentStackLocation;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Minipacket type.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG PacketType;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Original file object - pointer to the original file object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that was used to open the file.  This field is owned by the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// I/O system and should not be used by any other drivers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PFILE_OBJECT OriginalFileObject;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} Overlay;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// APC - This APC control block is used for the special kernel APC as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// well as for the caller's APC, if one was specified in the original<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// argument list.  If so, then the APC is reused for the normal APC for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// whatever mode the caller was in and the "special" routine that is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// invoked before the APC gets control simply deallocates the IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KAPC Apc;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CompletionKey - This is the key that is used to distinguish<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// individual I/O operations initiated on a single file handle.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID CompletionKey;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;} Tail;<br><br>} IRP;<br><br>typedef struct _IO_STACK_LOCATION {<br>    UCHAR MajorFunction;<br>    UCHAR MinorFunction;<br>    UCHAR Flags;<br>    UCHAR Control;<br><br>    //<br>    // The following user parameters are based on the service that is being<br>    // invoked.  Drivers and file systems can determine which set to use based<br>    // on the above major and minor function codes.<br>    //<br><br>    union {<br><br>        //<br>        // System service parameters for:  NtCreateFile<br>        //<br><br>        struct {<br>            PIO_SECURITY_CONTEXT SecurityContext;<br>            ULONG Options;<br>            USHORT POINTER_ALIGNMENT FileAttributes;<br>            USHORT ShareAccess;<br>            ULONG POINTER_ALIGNMENT EaLength;<br>        } Create;<br><br>// end_ntddk end_wdm end_nthal end_ntifs end_ntosp<br><br>        //<br>        // System service parameters for:  NtCreateNamedPipeFile<br>        //<br>        // Notice that the fields in the following parameter structure must<br>        // match those for the create structure other than the last longword.<br>        // This is so that no distinctions need be made by the I/O system's<br>        // parse routine other than for the last longword.<br>        //<br><br>        struct {<br>            PIO_SECURITY_CONTEXT SecurityContext;<br>            ULONG Options;<br>            USHORT POINTER_ALIGNMENT Reserved;<br>            USHORT ShareAccess;<br>            PNAMED_PIPE_CREATE_PARAMETERS Parameters;<br>        } CreatePipe;<br><br>        //<br>        // System service parameters for:  NtCreateMailslotFile<br>        //<br>        // Notice that the fields in the following parameter structure must<br>        // match those for the create structure other than the last longword.<br>        // This is so that no distinctions need be made by the I/O system's<br>        // parse routine other than for the last longword.<br>        //<br><br>        struct {<br>            PIO_SECURITY_CONTEXT SecurityContext;<br>            ULONG Options;<br>            USHORT POINTER_ALIGNMENT Reserved;<br>            USHORT ShareAccess;<br>            PMAILSLOT_CREATE_PARAMETERS Parameters;<br>        } CreateMailslot;<br><br>// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp<br><br>        //<br>        // System service parameters for:  NtReadFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            ULONG POINTER_ALIGNMENT Key;<br>            LARGE_INTEGER ByteOffset;<br>        } Read;<br><br>        //<br>        // System service parameters for:  NtWriteFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            ULONG POINTER_ALIGNMENT Key;<br>            LARGE_INTEGER ByteOffset;<br>        } Write;<br><br>// end_ntddk end_wdm end_nthal<br><br>        //<br>        // System service parameters for:  NtQueryDirectoryFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            PUNICODE_STRING FileName;<br>            FILE_INFORMATION_CLASS FileInformationClass;<br>            ULONG POINTER_ALIGNMENT FileIndex;<br>        } QueryDirectory;<br><br>        //<br>        // System service parameters for:  NtNotifyChangeDirectoryFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            ULONG POINTER_ALIGNMENT CompletionFilter;<br>        } NotifyDirectory;<br><br>// begin_ntddk begin_wdm begin_nthal<br><br>        //<br>        // System service parameters for:  NtQueryInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;<br>        } QueryFile;<br><br>        //<br>        // System service parameters for:  NtSetInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;<br>            PFILE_OBJECT FileObject;<br>            union {<br>                struct {<br>                    BOOLEAN ReplaceIfExists;<br>                    BOOLEAN AdvanceOnly;<br>                };<br>                ULONG ClusterCount;<br>                HANDLE DeleteHandle;<br>            };<br>        } SetFile;<br><br>// end_ntddk end_wdm end_nthal end_ntosp<br><br>        //<br>        // System service parameters for:  NtQueryEaFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            PVOID EaList;<br>            ULONG EaListLength;<br>            ULONG POINTER_ALIGNMENT EaIndex;<br>        } QueryEa;<br><br>        //<br>        // System service parameters for:  NtSetEaFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>        } SetEa;<br><br>// begin_ntddk begin_wdm begin_nthal begin_ntosp<br><br>        //<br>        // System service parameters for:  NtQueryVolumeInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;<br>        } QueryVolume;<br><br>// end_ntddk end_wdm end_nthal end_ntosp<br><br>        //<br>        // System service parameters for:  NtSetVolumeInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;<br>        } SetVolume;<br>// begin_ntosp<br>        //<br>        // System service parameters for:  NtFsControlFile<br>        //<br>        // Note that the user's output buffer is stored in the UserBuffer field<br>        // and the user's input buffer is stored in the SystemBuffer field.<br>        //<br><br>        struct {<br>            ULONG OutputBufferLength;<br>            ULONG POINTER_ALIGNMENT InputBufferLength;<br>            ULONG POINTER_ALIGNMENT FsControlCode;<br>            PVOID Type3InputBuffer;<br>        } FileSystemControl;<br>        //<br>        // System service parameters for:  NtLockFile/NtUnlockFile<br>        //<br><br>        struct {<br>            PLARGE_INTEGER Length;<br>            ULONG POINTER_ALIGNMENT Key;<br>            LARGE_INTEGER ByteOffset;<br>        } LockControl;<br><br>// begin_ntddk begin_wdm begin_nthal<br><br>        //<br>        // System service parameters for:  NtFlushBuffersFile<br>        //<br>        // No extra user-supplied parameters.<br>        //<br><br>// end_ntddk end_wdm end_nthal<br>// end_ntosp<br><br>        //<br>        // System service parameters for:  NtCancelIoFile<br>        //<br>        // No extra user-supplied parameters.<br>        //<br><br>// begin_ntddk begin_wdm begin_nthal begin_ntosp<br><br>        //<br>        // System service parameters for:  NtDeviceIoControlFile<br>        //<br>        // Note that the user's output buffer is stored in the UserBuffer field<br>        // and the user's input buffer is stored in the SystemBuffer field.<br>        //<br><br>        struct {<br>            ULONG OutputBufferLength;<br>            ULONG POINTER_ALIGNMENT InputBufferLength;<br>            ULONG POINTER_ALIGNMENT IoControlCode;<br>            PVOID Type3InputBuffer;<br>        } DeviceIoControl;<br><br>// end_wdm<br>        //<br>        // System service parameters for:  NtQuerySecurityObject<br>        //<br><br>        struct {<br>            SECURITY_INFORMATION SecurityInformation;<br>            ULONG POINTER_ALIGNMENT Length;<br>        } QuerySecurity;<br><br>        //<br>        // System service parameters for:  NtSetSecurityObject<br>        //<br><br>        struct {<br>            SECURITY_INFORMATION SecurityInformation;<br>            PSECURITY_DESCRIPTOR SecurityDescriptor;<br>        } SetSecurity;<br><br>// begin_wdm<br>        //<br>        // Non-system service parameters.<br>        //<br>        // Parameters for MountVolume<br>        //<br><br>        struct {<br>            PVPB Vpb;<br>            PDEVICE_OBJECT DeviceObject;<br>        } MountVolume;<br><br>        //<br>        // Parameters for VerifyVolume<br>        //<br><br>        struct {<br>            PVPB Vpb;<br>            PDEVICE_OBJECT DeviceObject;<br>        } VerifyVolume;<br><br>        //<br>        // Parameters for Scsi with internal device contorl.<br>        //<br><br>        struct {<br>            struct _SCSI_REQUEST_BLOCK *Srb;<br>        } Scsi;<br><br>// end_ntddk end_wdm end_nthal end_ntosp<br><br>        //<br>        // System service parameters for:  NtQueryQuotaInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>            PSID StartSid;<br>            PFILE_GET_QUOTA_INFORMATION SidList;<br>            ULONG SidListLength;<br>        } QueryQuota;<br><br>        //<br>        // System service parameters for:  NtSetQuotaInformationFile<br>        //<br><br>        struct {<br>            ULONG Length;<br>        } SetQuota;<br><br>// begin_ntddk begin_wdm begin_nthal begin_ntosp<br><br>        //<br>        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS<br>        //<br><br>        struct {<br>            DEVICE_RELATION_TYPE Type;<br>        } QueryDeviceRelations;<br><br>        //<br>        // Parameters for IRP_MN_QUERY_INTERFACE<br>        //<br><br>        struct {<br>            CONST GUID *InterfaceType;<br>            USHORT Size;<br>            USHORT Version;<br>            PINTERFACE Interface;<br>            PVOID InterfaceSpecificData;<br>        } QueryInterface;<br><br>// end_ntifs<br><br>        //<br>        // Parameters for IRP_MN_QUERY_CAPABILITIES<br>        //<br><br>        struct {<br>            PDEVICE_CAPABILITIES Capabilities;<br>        } DeviceCapabilities;<br><br>        //<br>        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS<br>        //<br><br>        struct {<br>            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;<br>        } FilterResourceRequirements;<br><br>        //<br>        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG<br>        //<br><br>        struct {<br>            ULONG WhichSpace;<br>            PVOID Buffer;<br>            ULONG Offset;<br>            ULONG POINTER_ALIGNMENT Length;<br>        } ReadWriteConfig;<br><br>        //<br>        // Parameters for IRP_MN_SET_LOCK<br>        //<br><br>        struct {<br>            BOOLEAN Lock;<br>        } SetLock;<br><br>        //<br>        // Parameters for IRP_MN_QUERY_ID<br>        //<br><br>        struct {<br>            BUS_QUERY_ID_TYPE IdType;<br>        } QueryId;<br><br>        //<br>        // Parameters for IRP_MN_QUERY_DEVICE_TEXT<br>        //<br><br>        struct {<br>            DEVICE_TEXT_TYPE DeviceTextType;<br>            LCID POINTER_ALIGNMENT LocaleId;<br>        } QueryDeviceText;<br><br>        //<br>        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION<br>        //<br><br>        struct {<br>            BOOLEAN InPath;<br>            BOOLEAN Reserved[3];<br>            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;<br>        } UsageNotification;<br><br>        //<br>        // Parameters for IRP_MN_WAIT_WAKE<br>        //<br><br>        struct {<br>            SYSTEM_POWER_STATE PowerState;<br>        } WaitWake;<br><br>        //<br>        // Parameter for IRP_MN_POWER_SEQUENCE<br>        //<br><br>        struct {<br>            PPOWER_SEQUENCE PowerSequence;<br>        } PowerSequence;<br><br>        //<br>        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER<br>        //<br><br>        struct {<br>            ULONG SystemContext;<br>            POWER_STATE_TYPE POINTER_ALIGNMENT Type;<br>            POWER_STATE POINTER_ALIGNMENT State;<br>            POWER_ACTION POINTER_ALIGNMENT ShutdownType;<br>        } Power;<br><br>        //<br>        // Parameters for StartDevice<br>        //<br><br>        struct {<br>            PCM_RESOURCE_LIST AllocatedResources;<br>            PCM_RESOURCE_LIST AllocatedResourcesTranslated;<br>        } StartDevice;<br><br>// begin_ntifs<br>        //<br>        // Parameters for Cleanup<br>        //<br>        // No extra parameters supplied<br>        //<br><br>        //<br>        // WMI Irps<br>        //<br><br>        struct {<br>            ULONG_PTR ProviderId;<br>            PVOID DataPath;<br>            ULONG BufferSize;<br>            PVOID Buffer;<br>        } WMI;<br><br>        //<br>        // Others - driver-specific<br>        //<br><br>        struct {<br>            PVOID Argument1;<br>            PVOID Argument2;<br>            PVOID Argument3;<br>            PVOID Argument4;<br>        } Others;<br><br>    } Parameters;<br><br>    //<br>    // Save a pointer to this device driver's device object for this request<br>    // so it can be passed to the completion routine if needed.<br>    //<br>&nbsp;&nbsp;&nbsp;&nbsp;// 此项一般在IoCallDriver中被设置。<br>    PDEVICE_OBJECT DeviceObject;<br><br>    //<br>    // The following location contains a pointer to the file object for this<br>    //<br><br>    PFILE_OBJECT FileObject;<br><br>    //<br>    // The following routine is invoked depending on the flags in the above<br>    // flags field.<br>    //<br>&nbsp;&nbsp;&nbsp;&nbsp;// 完成函数，每层都有。<br>    PIO_COMPLETION_ROUTINE CompletionRoutine;<br><br>    //<br>    // The following is used to store the address of the context parameter<br>    // that should be passed to the CompletionRoutine.<br>    //<br><br>    PVOID Context;<br><br>} IO_STACK_LOCATION, *PIO_STACK_LOCATION;<br><br>VOID<br>FASTCALL<br>IopfCompleteRequest(<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PIRP Irp,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN CCHAR PriorityBoost<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br><br>/*++<br><br>Routine Description:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;This routine is invoked to complete an I/O request.  It is invoked by the<br>&nbsp;&nbsp;&nbsp;&nbsp;driver in its DPC routine to perform the final completion of the IRP.  The<br>&nbsp;&nbsp;&nbsp;&nbsp;functions performed by this routine are as follows.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.  A check is made to determine whether the packet's stack locations<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have been exhausted.  If not, then the stack location pointer is set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to the next location and if there is a routine to be invoked, then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it will be invoked.  This continues until there are either no more<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routines which are interested or the packet runs out of stack.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If a routine is invoked to complete the packet for a specific driver<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which needs to perform work a lot of work or the work needs to be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performed in the context of another process, then the routine will<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This indicates that this completion routine should simply return to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;its caller because the operation will be "completed" by this routine<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again sometime in the future.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.  A check is made to determine whether this IRP is an associated IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If it is, then the count on the master IRP is decremented.  If the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count for the master becomes zero, then the master IRP will be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completed according to the steps below taken for a normal IRP being<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completed.  If the count is still non-zero, then this IRP (the one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;being completed) will simply be deallocated.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.  If this is paging I/O or a close operation, then simply write the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I/O status block and set the event to the signaled state, and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dereference the event.  If this is paging I/O, deallocate the IRP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as well.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.  Unlock the pages, if any, specified by the MDL by calling<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MmUnlockPages.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.  A check is made to determine whether or not completion of the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request can be deferred until later.  If it can be, then this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routine simply exits and leaves it up to the originator of the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request to fully complete the IRP.  By not initializing and queueing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the special kernel APC to the calling thread (which is the current<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread by definition), a lot of interrupt and queueing processing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can be avoided.<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.  The final rundown routine is invoked to queue the request packet to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the target (requesting) thread as a special kernel mode APC.<br><br>Arguments:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Irp - Pointer to the I/O Request Packet to complete.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PriorityBoost - Supplies the amount of priority boost that is to be given<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to the target thread when the special kernel APC is queued.<br><br>Return Value:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;None.<br><br>--*/<br>#define ZeroIrpStackLocation( IrpSp ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;MinorFunction = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;Flags = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;Control &amp;= SL_ERROR_RETURNED ;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;Parameters.Others.Argument1 = 0;   \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;Parameters.Others.Argument2 = 0;   \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;Parameters.Others.Argument3 = 0;   \<br>&nbsp;&nbsp;&nbsp;&nbsp;(IrpSp)-&gt;FileObject = (PFILE_OBJECT) NULL; }<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;PIRP masterIrp;<br>&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS status;<br>&nbsp;&nbsp;&nbsp;&nbsp;PIO_STACK_LOCATION stackPointer;<br>&nbsp;&nbsp;&nbsp;&nbsp;PIO_STACK_LOCATION bottomSp;<br>&nbsp;&nbsp;&nbsp;&nbsp;PDEVICE_OBJECT deviceObject;<br>&nbsp;&nbsp;&nbsp;&nbsp;PMDL mdl;<br>&nbsp;&nbsp;&nbsp;&nbsp;PETHREAD thread;<br>&nbsp;&nbsp;&nbsp;&nbsp;PFILE_OBJECT fileObject;<br>&nbsp;&nbsp;&nbsp;&nbsp;KIRQL irql;<br>&nbsp;&nbsp;&nbsp;&nbsp;PVOID saveAuxiliaryPointer = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;&nbsp;&nbsp;&nbsp;errorStatus;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Begin by ensuring that this packet has not already been completed<br>&nbsp;&nbsp;&nbsp;&nbsp;// by someone.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// 判断此IRP的堆栈和类型是否合法<br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;CurrentLocation &gt; (CCHAR) (Irp-&gt;StackCount + 1) ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;Type != IO_TYPE_IRP) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Ensure that the packet being completed really is still an IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( Irp-&gt;Type == IO_TYPE_IRP );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Ensure that no one believes that this request is still in a cancelable<br>&nbsp;&nbsp;&nbsp;&nbsp;// state.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( !Irp-&gt;CancelRoutine );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Ensure that the packet is not being completed with a thoroughly<br>&nbsp;&nbsp;&nbsp;&nbsp;// confusing status code.  Actually completing a packet with a pending<br>&nbsp;&nbsp;&nbsp;&nbsp;// status probably means that someone forgot to set the real status in<br>&nbsp;&nbsp;&nbsp;&nbsp;// the packet.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( Irp-&gt;IoStatus.Status != STATUS_PENDING );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Ensure that the packet is not being completed with a minus one.  This<br>&nbsp;&nbsp;&nbsp;&nbsp;// is apparently a common problem in some drivers, and has no meaning<br>&nbsp;&nbsp;&nbsp;&nbsp;// as a status code.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( Irp-&gt;IoStatus.Status != 0xffffffff );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Diagnosability support.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;bottomSp = ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) + sizeof( IRP )));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (bottomSp-&gt;Control &amp; SL_ERROR_RETURNED) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorStatus = (NTSTATUS)(ULONG_PTR)(bottomSp-&gt;Parameters.Others.Argument4);<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorStatus = STATUS_SUCCESS;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Now check to see whether this is the last driver that needs to be<br>&nbsp;&nbsp;&nbsp;&nbsp;// invoked for this packet.  If not, then bump the stack and check to<br>&nbsp;&nbsp;&nbsp;&nbsp;// see whether the driver wishes to see the completion.  As each stack<br>&nbsp;&nbsp;&nbsp;&nbsp;// location is examined, invoke any routine which needs to be invoked.<br>&nbsp;&nbsp;&nbsp;&nbsp;// If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the<br>&nbsp;&nbsp;&nbsp;&nbsp;// processing of this packet.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (stackPointer = IoGetCurrentIrpStackLocation( Irp ),&nbsp;&nbsp;&nbsp;&nbsp;// 获取当前IO堆栈，当前的堆栈中，可能会在上层驱动中调用IoSetCompletionRoutine（将完成函数设置到下一层）来对本层设置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;CurrentLocation++,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 移到上层IO堆栈，现在的IRP对应的堆栈是上一层。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;Tail.Overlay.CurrentStackLocation++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 移到上层IO堆栈，现在的IRP对应的堆栈是上一层。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;CurrentLocation &lt;= (CCHAR) (Irp-&gt;StackCount + 1); // 到最上层停止时停止。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPointer++,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 向上迭代<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;CurrentLocation++,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;Tail.Overlay.CurrentStackLocation++) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A stack location was located.  Check to see whether or not it<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// has a completion routine and if so, whether or not it should be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// invoked.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Begin by saving the pending returned flag in the current stack<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// location in the fixed part of the IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 判断stackPointer-&gt;Control是否具有SL_PENDING_RETURNED(使用IoMarkIrpPending来设置)，如果有，将SL_PENDING_RETURNED保存到Irp-&gt;PendingReturned。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 在完成函数中判断该值，来判断是否需要调用IoMarkIrpPending，如果不调用，会将此标记清除，无法继续向上传递，可以会出现死锁发送。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;PendingReturned = stackPointer-&gt;Control &amp; SL_PENDING_RETURNED;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If a completion routine changed the status then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mark the upper level stack pointer as the one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that flagged the error.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!NT_SUCCESS(Irp-&gt;IoStatus.Status)) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;IoStatus.Status != errorStatus) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorStatus = Irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackPointer-&gt;Control |= SL_ERROR_RETURNED;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottomSp-&gt;Parameters.Others.Argument4 = (PVOID)(ULONG_PTR)errorStatus;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bottomSp-&gt;Control |= SL_ERROR_RETURNED; // Mark that there is status in this location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (NT_SUCCESS( Irp-&gt;IoStatus.Status ) &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPointer-&gt;Control &amp; SL_INVOKE_ON_SUCCESS) ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (!NT_SUCCESS( Irp-&gt;IoStatus.Status ) &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPointer-&gt;Control &amp; SL_INVOKE_ON_ERROR) ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Irp-&gt;Cancel &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackPointer-&gt;Control &amp; SL_INVOKE_ON_CANCEL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This driver has specified a completion routine.  Invoke the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// routine passing it a pointer to its device object and the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IRP that is being completed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 清除当前栈，防止上一层的栈就无法使用此栈信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroIrpStackLocation( stackPointer );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 如果是最上层了，deviceObject为NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;CurrentLocation == (CCHAR) (Irp-&gt;StackCount + 1)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deviceObject = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 由于上面的IRP的IO堆栈已经++，所以获取到的是上层的DeviceObject.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 可以看出，通过IRP的IO堆栈中的deviceObject，可以回指对应的DeviceObject。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deviceObject = IoGetCurrentIrpStackLocation( Irp )-&gt;DeviceObject;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 调用完成函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status = stackPointer-&gt;CompletionRoutine( deviceObject,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Irp,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  stackPointer-&gt;Context );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status == STATUS_MORE_PROCESSING_REQUIRED) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note:  Notice that if the driver has returned the above<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status value, it may have already DEALLOCATED the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet!  Therefore, do NOT touch any part of the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRP in the following code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 正如书中说的，STATUS_MORE_PROCESSING_REQUIRED，则返回。此时IRP还是有效的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 如果没有完成函数，直接IoMarkIrpPending，继续循环。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;PendingReturned &amp;&amp; Irp-&gt;CurrentLocation &lt;= Irp-&gt;StackCount) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoMarkIrpPending( Irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZeroIrpStackLocation( stackPointer );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see whether this is an associated IRP.  If so, then decrement<br>&nbsp;&nbsp;&nbsp;&nbsp;// the count in the master IRP.  If the count is decremented to zero,<br>&nbsp;&nbsp;&nbsp;&nbsp;// then complete the master packet as well.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;Flags &amp; IRP_ASSOCIATED_IRP) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG count;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;masterIrp = Irp-&gt;AssociatedIrp.MasterIrp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// After this decrement master IRP cannot be touched except if count == 1.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &amp;masterIrp-&gt;AssociatedIrp.IrpCount );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Deallocate this packet and any MDLs that are associated with it<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by either doing direct deallocations if they were allocated from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a zone or by queueing the packet to a thread to perform the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// deallocation.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Also, check the count of the master IRP to determine whether or not<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the count has gone to zero.  If not, then simply get out of here.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise, complete the master packet.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopFreeIrpAndMdls( Irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (count == 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoCompleteRequest( masterIrp, PriorityBoost );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see if we have a name junction. If so set the stage to<br>&nbsp;&nbsp;&nbsp;&nbsp;// transmogrify the reparse point data in IopCompleteRequest.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if ((Irp-&gt;IoStatus.Status == STATUS_REPARSE )  &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Irp-&gt;IoStatus.Information &gt; IO_REPARSE_TAG_RESERVED_RANGE)) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For name junctions, we save the pointer to the auxiliary<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// buffer and use it below.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( Irp-&gt;Tail.Overlay.AuxiliaryBuffer != NULL );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveAuxiliaryPointer = (PVOID) Irp-&gt;Tail.Overlay.AuxiliaryBuffer;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We NULL the entry to avoid its de-allocation at this time.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This buffer get deallocated in IopDoNameTransmogrify<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;Tail.Overlay.AuxiliaryBuffer = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fail the request. A driver needed to act on this IRP prior<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to getting to this point.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;IoStatus.Status = STATUS_IO_REPARSE_TAG_NOT_HANDLED;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check the auxiliary buffer pointer in the packet and if a buffer was<br>&nbsp;&nbsp;&nbsp;&nbsp;// allocated, deallocate it now.  Note that this buffer must be freed<br>&nbsp;&nbsp;&nbsp;&nbsp;// here since the pointer is overlayed with the APC that will be used<br>&nbsp;&nbsp;&nbsp;&nbsp;// to get to the requesting thread's context.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;Tail.Overlay.AuxiliaryBuffer) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool( Irp-&gt;Tail.Overlay.AuxiliaryBuffer );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;Tail.Overlay.AuxiliaryBuffer = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see if this is paging I/O or a close operation.  If either,<br>&nbsp;&nbsp;&nbsp;&nbsp;// then special processing must be performed.  The reasons that special<br>&nbsp;&nbsp;&nbsp;&nbsp;// processing must be performed is different based on the type of<br>&nbsp;&nbsp;&nbsp;&nbsp;// operation being performed.  The biggest reasons for special processing<br>&nbsp;&nbsp;&nbsp;&nbsp;// on paging operations are that using a special kernel APC for an in-<br>&nbsp;&nbsp;&nbsp;&nbsp;// page operation cannot work since the special kernel APC can incur<br>&nbsp;&nbsp;&nbsp;&nbsp;// another pagefault.  Likewise, all paging I/O uses MDLs that belong<br>&nbsp;&nbsp;&nbsp;&nbsp;// to the memory manager, not the I/O system.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Close operations are special because the close may have been invoked<br>&nbsp;&nbsp;&nbsp;&nbsp;// because of a special kernel APC (some IRP was completed which caused<br>&nbsp;&nbsp;&nbsp;&nbsp;// the reference count on the object to become zero while in the I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;// system's special kernel APC routine).  Therefore, a special kernel APC<br>&nbsp;&nbsp;&nbsp;&nbsp;// cannot be used since it cannot execute until the close APC finishes.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The special steps are as follows for a synchronous paging operation<br>&nbsp;&nbsp;&nbsp;&nbsp;// and close are:<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; 1.  Copy the I/O status block (it is in SVAS, nonpaged).<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; 2.  Signal the event<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; 3.  If paging I/O, deallocate the IRP<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// The special steps taken for asynchronous paging operations (out-pages)<br>&nbsp;&nbsp;&nbsp;&nbsp;// are as follows:<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; 1.  Initialize a special kernel APC just for page writes.<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; 1.  Queue the special kernel APC.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// It should also be noted that the logic for completing a Mount request<br>&nbsp;&nbsp;&nbsp;&nbsp;// operation is exactly the same as a Page Read.  No assumptions should be<br>&nbsp;&nbsp;&nbsp;&nbsp;// made here about this being a Page Read operation w/o carefully checking<br>&nbsp;&nbsp;&nbsp;&nbsp;// to ensure that they are also true for a Mount.  That is:<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// are the same flag in the IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Also note that the last time the IRP is touched for a close operation<br>&nbsp;&nbsp;&nbsp;&nbsp;// must be just before the event is set to the signaled state.  Once this<br>&nbsp;&nbsp;&nbsp;&nbsp;// occurs, the IRP can be deallocated by the thread waiting for the event.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// IRP_CLOSE_OPERATION and IRP_SET_USER_EVENT are the same flags. They both indicate<br>&nbsp;&nbsp;&nbsp;&nbsp;// that only the user event field should be set and no APC should be queued. Unfortunately<br>&nbsp;&nbsp;&nbsp;&nbsp;// IRP_CLOSE_OPERATION is used by some drivers to do exactly this so it cannot be renamed.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;Flags &amp; (IRP_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;Flags &amp; (IRP_SYNCHRONOUS_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG flags;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags = Irp-&gt;Flags &amp; (IRP_SYNCHRONOUS_PAGING_IO|IRP_PAGING_IO);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Irp-&gt;UserIosb = Irp-&gt;IoStatus;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( Irp-&gt;UserEvent, PriorityBoost, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (flags) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IopIsReserveIrp(Irp)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopFreeReserveIrp(PriorityBoost);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoFreeIrp( Irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread = Irp-&gt;Tail.Overlay.Thread;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInitializeApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;thread-&gt;Tcb,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;ApcEnvironment,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopCompletePageWrite,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKRUNDOWN_ROUTINE) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKNORMAL_ROUTINE) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KernelMode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) NULL );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeInsertQueueApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PriorityBoost );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see whether any pages need to be unlocked.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;MdlAddress != NULL) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unlock any pages that may be described by MDLs.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdl = Irp-&gt;MdlAddress;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (mdl != NULL) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MmUnlockPages( mdl );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdl = mdl-&gt;Next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Make a final check here to determine whether or not this is a<br>&nbsp;&nbsp;&nbsp;&nbsp;// synchronous I/O operation that is being completed in the context<br>&nbsp;&nbsp;&nbsp;&nbsp;// of the original requestor.  If so, then an optimal path through<br>&nbsp;&nbsp;&nbsp;&nbsp;// I/O completion can be taken.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// !Irp-&gt;PendingReturned 没有SL_PENDING_RETURNED，则是同步完成的，直接返回，无需等待。算是个优化。<br>&nbsp;&nbsp;&nbsp;&nbsp;if (Irp-&gt;Flags &amp; IRP_DEFER_IO_COMPLETION &amp;&amp; !Irp-&gt;PendingReturned) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((Irp-&gt;IoStatus.Status == STATUS_REPARSE )  &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Irp-&gt;IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For name junctions we reinstate the address of the appropriate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// buffer. It is freed in parse.c<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Irp-&gt;Tail.Overlay.AuxiliaryBuffer = saveAuxiliaryPointer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Finally, initialize the IRP as an APC structure and queue the special<br>&nbsp;&nbsp;&nbsp;&nbsp;// kernel APC to the target thread.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;thread = Irp-&gt;Tail.Overlay.Thread;//当前进程<br>&nbsp;&nbsp;&nbsp;&nbsp;fileObject = Irp-&gt;Tail.Overlay.OriginalFileObject;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (!Irp-&gt;Cancel) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInitializeApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;thread-&gt;Tcb,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;ApcEnvironment,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopCompleteRequest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopAbortRequest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKNORMAL_ROUTINE) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KernelMode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) NULL );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeInsertQueueApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileObject,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) saveAuxiliaryPointer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PriorityBoost );<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This request has been cancelled.  Ensure that access to the thread<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is synchronized, otherwise it may go away while attempting to get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// through the remainder of completion for this request.  This happens<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// when the thread times out waiting for the request to be completed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// once it has been cancelled.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note that it is safe to capture the thread pointer above, w/o having<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the lock because the cancel flag was not set at that point, and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the code that disassociates IRPs must set the flag before looking to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see whether or not the packet has been completed, and this packet<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will appear to be completed because it no longer belongs to a driver.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irql = KeAcquireQueuedSpinLock( LockQueueIoCompletionLock );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread = Irp-&gt;Tail.Overlay.Thread;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (thread) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 将IopCompleteRequest排队到线程的APC队列中。在其里面进行SetEvent等一些完成处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInitializeApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;thread-&gt;Tcb,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Irp-&gt;ApcEnvironment,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopCompleteRequest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopAbortRequest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKNORMAL_ROUTINE) NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KernelMode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) NULL );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeInsertQueueApc( &amp;Irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileObject,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID) saveAuxiliaryPointer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PriorityBoost );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This request has been aborted from completing in the caller's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// thread.  This can only occur if the packet was cancelled, and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the driver did not complete the request, so it was timed out.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attempt to drop things on the floor, since the originating thread<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// has probably exited at this point.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( Irp-&gt;Cancel );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Drop the IRP on the floor.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopDropIrp( Irp, fileObject );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>VOID<br>IopCompleteRequest(<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PKAPC Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PKNORMAL_ROUTINE *NormalRoutine,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PVOID *NormalContext,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PVOID *SystemArgument1,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN PVOID *SystemArgument2<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br><br>/*++<br><br>Routine Description:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;This routine executes as a special kernel APC routine in the context of<br>&nbsp;&nbsp;&nbsp;&nbsp;the thread which originally requested the I/O operation which is now<br>&nbsp;&nbsp;&nbsp;&nbsp;being completed.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;This routine performs the following tasks:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   A check is made to determine whether the specified request ended<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with an error status.  If so, and the error code qualifies as one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which should be reported to an error port, then an error port is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;looked for in the thread/process.   If one exists, then this routine<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will attempt to set up an LPC to it.  Otherwise, it will attempt to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set up an LPC to the system error port.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Copy buffers.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Free MDLs.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Copy I/O status.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Set event, if any and dereference if appropriate.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Dequeue the IRP from the thread queue as pending I/O request.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   Queue APC to thread, if any.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o   If no APC is to be queued, then free the packet now.<br><br><br>Arguments:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Apc - Supplies a pointer to kernel APC structure.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;NormalRoutine - Supplies a pointer to a pointer to the normal function<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that was specified when the APC was initialized.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;NormalContext - Supplies a pointer to a pointer to an arbitrary data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;structure that was specified when the APC was initialized.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;SystemArgument1 - Supplies a pointer to an argument that contains the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address of the original file object for this I/O operation.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;SystemArgument2 - Supplies a pointer to an argument that contains an<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argument that is used by this routine only in the case of STATUS_REPARSE.<br><br>Return Value:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;None.<br><br>--*/<br>{<br>#define SynchronousIo( Irp, FileObject ) (  \<br>&nbsp;&nbsp;&nbsp;&nbsp;(Irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API) ||   \<br>&nbsp;&nbsp;&nbsp;&nbsp;(FileObject == NULL ? 0 : FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) )<br><br>&nbsp;&nbsp;&nbsp;&nbsp;PIRP irp;<br>&nbsp;&nbsp;&nbsp;&nbsp;PMDL mdl, nextMdl;<br>&nbsp;&nbsp;&nbsp;&nbsp;PETHREAD thread;<br>&nbsp;&nbsp;&nbsp;&nbsp;PFILE_OBJECT fileObject;<br>&nbsp;&nbsp;&nbsp;&nbsp;NTSTATUS&nbsp;&nbsp;&nbsp;&nbsp;status;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER( NormalRoutine );<br>&nbsp;&nbsp;&nbsp;&nbsp;UNREFERENCED_PARAMETER( NormalContext );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Begin by getting the address of the I/O Request Packet.  Also, get<br>&nbsp;&nbsp;&nbsp;&nbsp;// the address of the current thread and the address of the original file<br>&nbsp;&nbsp;&nbsp;&nbsp;// object for this I/O operation.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc ); // 得到IRP，设置的时候设置的是&amp;Irp-&gt;Tail.Apc，即Irp-&gt;Tail.Apc中的地址。所以反推了回来。<br>&nbsp;&nbsp;&nbsp;&nbsp;thread = PsGetCurrentThread();<br>&nbsp;&nbsp;&nbsp;&nbsp;fileObject = (PFILE_OBJECT) *SystemArgument1;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;IOVP_COMPLETE_REQUEST(Apc, SystemArgument1, SystemArgument2);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Ensure that the packet is not being completed with a minus one.  This<br>&nbsp;&nbsp;&nbsp;&nbsp;// is apparently a common problem in some drivers, and has no meaning<br>&nbsp;&nbsp;&nbsp;&nbsp;// as a status code.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( irp-&gt;IoStatus.Status != 0xffffffff );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// See if we need to do the name transmogrify work.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if ( *SystemArgument2 != NULL ) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREPARSE_DATA_BUFFER reparseBuffer = NULL;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The IO_REPARSE_TAG_MOUNT_POINT tag needs attention.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( irp-&gt;IoStatus.Status == STATUS_REPARSE &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irp-&gt;IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT ) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reparseBuffer = (PREPARSE_DATA_BUFFER) *SystemArgument2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( reparseBuffer-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( reparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT( reparseBuffer-&gt;Reserved &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopDoNameTransmogrify( irp,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   fileObject,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   reparseBuffer );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see whether there is any data in a system buffer which needs<br>&nbsp;&nbsp;&nbsp;&nbsp;// to be copied to the caller's buffer.  If so, copy the data and then<br>&nbsp;&nbsp;&nbsp;&nbsp;// free the system buffer if necessary.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_BUFFERED_IO) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the data if this was an input operation.  Note that no copy<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is performed if the status indicates that a verify operation is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// required, or if the final status was an error-level severity.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_INPUT_OPERATION  &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;IoStatus.Status != STATUS_VERIFY_REQUIRED &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!NT_ERROR( irp-&gt;IoStatus.Status )) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the information from the system buffer to the caller's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// buffer.  This is done with an exception handler in case<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the operation fails because the caller's address space<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// has gone away, or it's protection has been changed while<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the service was executing.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status = STATUS_SUCCESS;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlCopyMemory( irp-&gt;UserBuffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   irp-&gt;AssociatedIrp.SystemBuffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   irp-&gt;IoStatus.Information );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} except(IopExceptionFilter(GetExceptionInformation(), &amp;status)) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An exception occurred while attempting to copy the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// system buffer contents to the caller's buffer.  Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a new I/O completion status.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the status is a special one set by Mm then we need to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return here and the operation will be retried in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IoRetryIrpCompletions.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status == STATUS_MULTIPLE_FAULT_VIOLATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Tail.Overlay.OriginalFileObject = fileObject;  /* Wiped out by APC  overlay */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Flags |= IRP_RETRY_IO_COMPLETION;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;IoStatus.Status = GetExceptionCode();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Free the buffer if needed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_DEALLOCATE_BUFFER) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExFreePool( irp-&gt;AssociatedIrp.SystemBuffer );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Flags &amp;= ~(IRP_DEALLOCATE_BUFFER|IRP_BUFFERED_IO);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// If there is an MDL (or MDLs) associated with this I/O request,<br>&nbsp;&nbsp;&nbsp;&nbsp;// Free it (them) here.  This is accomplished by walking the MDL list<br>&nbsp;&nbsp;&nbsp;&nbsp;// hanging off of the IRP and deallocating each MDL encountered.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;MdlAddress) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (mdl = irp-&gt;MdlAddress; mdl != NULL; mdl = nextMdl) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextMdl = mdl-&gt;Next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoFreeMdl( mdl );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;MdlAddress = NULL;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;// Check to see whether or not the I/O operation actually completed.  If<br>&nbsp;&nbsp;&nbsp;&nbsp;// it did, then proceed normally.  Otherwise, cleanup everything and get<br>&nbsp;&nbsp;&nbsp;&nbsp;// out of here.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (!NT_ERROR( irp-&gt;IoStatus.Status ) ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NT_ERROR( irp-&gt;IoStatus.Status ) &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;PendingReturned &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!SynchronousIo( irp, fileObject ))) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID port = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PVOID key = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOOLEAN createOperation = FALSE;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If there is an I/O completion port object associated w/this request,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// save it here so that the file object can be dereferenced.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fileObject &amp;&amp; fileObject-&gt;CompletionContext) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = fileObject-&gt;CompletionContext-&gt;Port;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = fileObject-&gt;CompletionContext-&gt;Key;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the I/O status from the IRP into the caller's I/O status<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// block. This is done using an exception handler in case the caller's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// virtual address space for the I/O status block was deleted or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// its protection was changed to readonly.  Note that if the I/O<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// status block cannot be written, the error is simply ignored since<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// there is no way to tell the caller that something went wrong.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is, of course, by definition, since the I/O status block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is where the caller will attempt to look for errors in the first<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// place!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status = STATUS_SUCCESS;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Since HasOverlappedIoCompleted and GetOverlappedResult only<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// look at the Status field of the UserIosb to determine if the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IRP has completed, the Information field must be written<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// before the Status field.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>#if defined(_WIN64)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIO_STATUS_BLOCK32&nbsp;&nbsp;&nbsp;&nbsp;UserIosb32;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the caller passes a 32 bit IOSB the ApcRoutine has the LSB set to 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IopIsIosb32(irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserIosb32 = (PIO_STATUS_BLOCK32)irp-&gt;UserIosb;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserIosb32-&gt;Information = (ULONG)irp-&gt;IoStatus.Information;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeMemoryBarrierWithoutFence ();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*((volatile NTSTATUS *) &amp;UserIosb32-&gt;Status) = irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;UserIosb-&gt;Information = irp-&gt;IoStatus.Information;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeMemoryBarrierWithoutFence ();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*((volatile NTSTATUS *) &amp;irp-&gt;UserIosb-&gt;Status) = irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>#else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;UserIosb-&gt;Information = irp-&gt;IoStatus.Information;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeMemoryBarrierWithoutFence ();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*((volatile NTSTATUS *) &amp;irp-&gt;UserIosb-&gt;Status) = irp-&gt;IoStatus.Status;<br>#endif  /*_WIN64 */<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} except(IopExceptionFilter(GetExceptionInformation(), &amp;status)) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// An exception was incurred attempting to write the caller's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// I/O status block.  Simply continue executing as if nothing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ever happened since nothing can be done about it anyway.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the status is a multiple fault status, this is a special<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// status sent by the Memory manager. Mark the IRP and return from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this routine. Mm will call us back later and we will retry this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operation (IoRetryIrpCompletions)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status == STATUS_MULTIPLE_FAULT_VIOLATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Tail.Overlay.OriginalFileObject = fileObject;  /* Wiped out by APC  overlay */<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Flags |= IRP_RETRY_IO_COMPLETION;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Determine whether the caller supplied an event that needs to be set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to the Signaled state.  If so, then set it; otherwise, set the event<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in the file object to the Signaled state.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It is possible for the event to have been specified as a PKEVENT if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this was an I/O operation hand-built for an FSP or an FSD, or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// some other types of operations such as synchronous I/O APIs.  In<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// any of these cases, the event was not referenced since it is not an<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// object manager event, so it should not be dereferenced.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Also, it is possible for there not to be a file object for this IRP.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This occurs when an FSP is doing I/O operations to a device driver on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// behalf of a process doing I/O to a file.  The file object cannot be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// dereferenced if this is the case.  If this operation was a create<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operation then the object should not be dereferenced either.  This<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is because the reference count must be one or it will go away for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the caller (not much point in making an object that just got created<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// go away).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 这是SetEvent：irp-&gt;UserEvent || fileObject。irp-&gt;UserEvent由用户传入，fileObject为deviceobject对应的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 同步的时候使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;UserEvent) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( irp-&gt;UserEvent, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fileObject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObject( irp-&gt;UserEvent );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO &amp;&amp; !(irp-&gt;Flags &amp; IRP_OB_QUERY_NAME)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( &amp;fileObject-&gt;Event, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileObject-&gt;FinalStatus = irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_CREATE_OPERATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createOperation = TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (fileObject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( &amp;fileObject-&gt;Event, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileObject-&gt;FinalStatus = irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_CREATE_OPERATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createOperation = TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If this is normal I/O, update the transfer count for this process.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(irp-&gt;Flags &amp; IRP_CREATE_OPERATION)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_READ_OPERATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopUpdateReadTransferCount( (ULONG) irp-&gt;IoStatus.Information );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (irp-&gt;Flags &amp; IRP_WRITE_OPERATION) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopUpdateWriteTransferCount( (ULONG) irp-&gt;IoStatus.Information );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the information field contains a pointer then skip the update.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Some PNP IRPs contain this.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!((ULONG_PTR) irp-&gt;IoStatus.Information &amp; IopKernelPointerBit)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopUpdateOtherTransferCount( (ULONG) irp-&gt;IoStatus.Information );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Dequeue the packet from the thread's pending I/O request list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopDequeueThreadIrp( irp );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the caller requested an APC, queue it to the thread.  If not, then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// simply free the packet now.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>#ifdef  _WIN64<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For 64 bit systems clear the LSB field of the ApcRoutine that indicates whether<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the IOSB is a 32 bit IOSB or a 64 bit IOSB.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (PIO_APC_ROUTINE)((LONG_PTR)(irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine) &amp; ~1);<br>#endif<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInitializeApc( &amp;irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;thread-&gt;Tcb,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentApcEnvironment,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IopUserCompletion,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKRUNDOWN_ROUTINE) IopUserRundown,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PKNORMAL_ROUTINE) irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irp-&gt;RequestorMode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irp-&gt;Overlay.AsynchronousParameters.UserApcContext );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInsertQueueApc( &amp;irp-&gt;Tail.Apc,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  irp-&gt;UserIosb,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  NULL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2 );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (port &amp;&amp; irp-&gt;Overlay.AsynchronousParameters.UserApcContext) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If there is a completion context associated w/this I/O operation,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send the message to the port. Tag completion packet as an Irp.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Tail.CompletionKey = key;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irp-&gt;Tail.Overlay.PacketType = IopCompletionPacketIrp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeInsertQueue( (PKQUEUE) port,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &amp;irp-&gt;Tail.Overlay.ListEntry );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Free the IRP now since it is no longer needed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoFreeIrp( irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fileObject &amp;&amp; !createOperation) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Dereference the file object now.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObjectDeferDelete( fileObject );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;PendingReturned &amp;&amp; fileObject) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is an I/O operation that completed as an error for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// which a pending status was returned and the I/O operation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is synchronous.  For this case, the I/O system is waiting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// on behalf of the caller.  If the reason that the I/O was<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// synchronous is that the file object was opened for synchronous<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// I/O, then the event associated with the file object is set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to the signaled state.  If the I/O operation was synchronous<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// because this is a synchronous API, then the event is set to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the signaled state.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note also that the status must be returned for both types<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// of synchronous I/O.  If this is a synchronous API, then the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// I/O system supplies its own status block so it can simply<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// be written;  otherwise, the I/O system will obtain the final<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// status from the file object itself.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*irp-&gt;UserIosb = irp-&gt;IoStatus;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;UserEvent) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( irp-&gt;UserEvent, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( &amp;fileObject-&gt;Event, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileObject-&gt;FinalStatus = irp-&gt;IoStatus.Status;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VOID) KeSetEvent( &amp;fileObject-&gt;Event, 0, FALSE );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The operation was incomplete.  Perform the general cleanup.  Note<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that everything is basically dropped on the floor without doing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// anything.  That is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; IoStatusBlock - Do nothing.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; Event - Dereference without setting to Signaled state.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; FileObject - Dereference without setting to Signaled state.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp; ApcRoutine - Do nothing.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (fileObject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(irp-&gt;Flags &amp; IRP_CREATE_OPERATION)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObjectDeferDelete( fileObject );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (irp-&gt;UserEvent &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileObject &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObDereferenceObject( irp-&gt;UserEvent );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IopDequeueThreadIrp( irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoFreeIrp( irp );<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>IRP对应一个IO堆栈，堆栈的层数是要传递的设备的栈的数目。每层栈对应一个IO栈，但这种对应并不需要层层对应，如本层可以使用上层对应的，也没有关系，所以有宏：<br>#define IoSkipCurrentIrpStackLocation( Irp ) { \<br>&nbsp;&nbsp;&nbsp;&nbsp;(Irp)-&gt;CurrentLocation++; \<br>&nbsp;&nbsp;&nbsp;&nbsp;(Irp)-&gt;Tail.Overlay.CurrentStackLocation++; }<br>&nbsp;&nbsp;&nbsp;&nbsp;++后，在IoCallDriver再--，等于没变，等于让下层驱动使用本层的IO堆栈。<br><br>说实话，微软的内核里很多函数真长啊。翻几页。。。<br>
</span></p>
</body></html>