<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]明明白白自旋锁</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]明明白白自旋锁</h2>
<p align="right">发布时间：2013-8-20 16:51
<br>分类名称：Driver</p><br>
<p><span style="color:#666666; font-size:9pt;"   ><br><span style="color:#333333;"   >作 者:<span style="color:#666666;"   >
<span style="color:black;"   >achillis<span style="color:#666666;"   ><br><span style="color:#333333;"   >时 间:<span style="color:#666666;"   > 2008-10-12,13:39:46<br><span style="color:#333333;"   >链 接:<span style="color:#666666;"   > http://bbs.pediy.com/showthread.php?t=74502<br><span style="color:#13253c;"   ><br>自某日看了iceboy和MJ0011关于多处理器同步的一些讨论，才发现原来我对自旋锁的理解也有一定错误，还好现在明白了~~为了加深理解，就深入分析了一下自旋锁的实现，一篇小小的自旋锁分析文章，献给大家。写得比较碎，欢迎各位大牛小牛指出错误~<br>一、自旋锁是什么？<br>先进行下简单科普，自旋锁是一种轻量级的多处理器间的同步机制。因此，自旋锁对于单处理器是没有实际意义的。它要求持有锁的处理器所占用的时间尽可能短，因为此时别的处理器正在高速运转并等待锁的释放，所以不能长时间占有。<br>曾经有个经典的例子来比喻自旋锁：A，B两个人合租一套房子，共用一个厕所，那么这个厕所就是共享资源，且在任一时刻最多只能有一个人在使用。当厕所闲置时，谁来了都可以使用，当A使用时，就会关上厕所门，而B也要使用，但是急啊，就得在门外焦急地等待，急得团团转，是为"自旋"，呵呵。这个比喻还算恰当吧，大家也明白为什么要求锁的持有时间尽量短了吧！尤其b4占着茅坑不拉屎的行为~~<img title="[转]明明白白自旋锁 - Howie - Dspace"   src="pic/img2.ph.126.net__KHgWWnp7PCWL1o6twkgXQ==_1921348191127074953.jpg"   alt=""   />&nbsp;<br>二、操作系统如何实现自旋锁？<br>在Linux和Windows中都实现了自旋锁，下面我们就来看一看Windows下是如何实现的吧。<br>自旋锁的结构：<br>KSPIN_LOCK&nbsp;SpinLock；<br>KSPIN_LOCK实际是一个操作系统相关的无符号整数，32位系统上是32位的unsigned&nbsp;long，64位系统则定义为unsigned&nbsp;__int64。<br>在初始化时，其值被设置为0，为空闲状态。<br>参见WRK：<br><br>FORCEINLINE<br>VOID<br>NTAPI<br>KeInitializeSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__out&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;*SpinLock&nbsp;=&nbsp;0;<br>}<br><br>关于自旋锁的两个基本操作：获取和释放<br>VOID&nbsp;<br>KeAcquireSpinLock(<br>&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PKSPIN_LOCK&nbsp;&nbsp;SpinLock,<br>&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;PKIRQL&nbsp;&nbsp;OldIrql<br>&nbsp;&nbsp;&nbsp;&nbsp;);<br>VOID&nbsp;<br>&nbsp;&nbsp;KeReleaseSpinLock(<br>&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PKSPIN_LOCK&nbsp;&nbsp;SpinLock,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;KIRQL&nbsp;&nbsp;NewIrql<br>&nbsp;&nbsp;&nbsp;&nbsp;);<br>获取时做了哪些工作呢？<br>Ntddk.h中是这样定义的：<br>#define&nbsp;KeAcquireSpinLock(SpinLock,&nbsp;OldIrql)&nbsp;\<br>*(OldIrql)&nbsp;=&nbsp;KeAcquireSpinLockRaiseToDpc(SpinLock)<br>很明显，核心的操作对象是SpinLock，同时也与IRQL有关。<br>再翻翻WRK，找到KeAcquireSpinLockRaiseToDpc的定义：<br><br>__forceinline<br>KIRQL<br>KeAcquireSpinLockRaiseToDpc&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;KIRQL&nbsp;OldIrql;<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Raise&nbsp;IRQL&nbsp;to&nbsp;DISPATCH_LEVEL&nbsp;and&nbsp;acquire&nbsp;the&nbsp;specified&nbsp;spin&nbsp;lock.<br>&nbsp;&nbsp;&nbsp;&nbsp;//<br>&nbsp;&nbsp;&nbsp;&nbsp;OldIrql&nbsp;=&nbsp;KfRaiseIrql(DISPATCH_LEVEL);<br>&nbsp;&nbsp;&nbsp;&nbsp;KxAcquireSpinLock(SpinLock);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;OldIrql;<br>}<br><br>首先会提升IRQL到DISPATCH_LEVEL，然后调用KxAcquireSpinLock()。（若当前IRQL就是DISPATCH_LEVEL，那么就调用KeAcquireSpinLockAtDpcLevel，省去提升IRQL一步）。因为线程调度也是发生在DISPATCH_LEVEL，所以提升IRQL之后当前处理器上就不会发生线程切换。单处理器时，当前只能有一个线程被执行，而这个线程提升IRQL至DISPATCH_LEVEL之后又不会因为调度被切换出去，自然也可以实现我们想要的互斥"效果"，其实只操作IRQL即可，无需SpinLock。实际上单核系统的内核文件ntosknl.exe中导出的有关SpinLock的函数都只有一句话，就是return，呵呵。<br>而多处理器呢？提升IRQL只会影响到当前处理器，保证当前处理器的当前线程不被切换，那还得考虑其它处理器啊，继续看&nbsp;KxAcquireSpinLock()函数吧。在WRK中找到的KxAcquireSpinLock()函数是Amd64位处理器上的代码（位于(\inc\private\ntos\inc\Amd64.h)中），32位x86的没找到。不过原理相通，一样可以参考<br><br>__forceinline<br>VOID<br>KxAcquireSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(InterlockedBitTestAndSet64((LONG64&nbsp;*)SpinLock,&nbsp;0))//64位函数<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KxWaitForSpinLockAndAcquire(SpinLock);&nbsp;&nbsp;//只有声明没有定义的函数,应该是做了测试,等待的工作<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>InterlockedBitTestAndSet64()函数的32位版本如下：<br>ps:我汇编功底不太好，见谅~<br><br>BOOLEAN<br>FORCEINLINE<br>InterlockedBitTestAndSet&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;LONG&nbsp;*Base,<br>&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;LONG&nbsp;Bit<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>__asm&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;eax,&nbsp;Bit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;ecx,&nbsp;Base<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;bts&nbsp;[ecx],&nbsp;eax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setc&nbsp;al<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}<br><br>关键就在bts指令，是一个进行位测试并置位的指令。，这里在进行关键的操作时有lock前缀，保证了多处理器安全。InterLockedXXX函数都有这个特点。显然，KxAcquireSpinLock（）函数先测试锁的状态。若锁空闲，则*SpinLock为0，那么InterlockedBitTestAndSet()将返回0，并使*SpinLock置位，不再为0。这样KxAcquireSpinLock()就成功得到了锁，并设置锁为占用状态（*SpinLock不为0），函数返回。若锁已被占用呢？InterlockedBitTestAndSet()将返回1，此时将调用KxWaitForSpinLockAndAcquire()等待并获取这个锁。这表明，SPIN_LOCK为0则锁空闲，非0则已被占有。<br>由于WRK中仅有KxWaitForSpinLockAndAcquire（）的声明而无定义，我们只能从名字猜测其做了什么。在WRK中看到了这两个函数：<br><br>__forceinline<br>BOOLEAN<br>KxTryToAcquireSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>if&nbsp;(*(volatile&nbsp;LONG64&nbsp;*)SpinLock&nbsp;==&nbsp;0)&nbsp;<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;return&nbsp;!InterlockedBitTestAndSet64((LONG64&nbsp;*)SpinLock,&nbsp;0);<br>&nbsp;&nbsp;}&nbsp;<br>else&nbsp;<br>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeYieldProcessor();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;<br>&nbsp;}<br>}<br><br>从名字看应该是试图获取自旋锁，先判断锁是否被占有。若空闲，则设置其为占用状态，这就成功地抢占了。若已被占用，则调用KeYieldProcessor()，这个函数其实只是一个宏：<br>#define&nbsp;KeYieldProcessor()&nbsp;&nbsp;&nbsp;&nbsp;__asm&nbsp;{&nbsp;rep&nbsp;nop&nbsp;}&nbsp;//空转<br>都知道nop干啥的，CPU就是在空转进行等待而已。<br>下面这个函数则是仅测试自旋锁的状态：<br><br>__forceinline<br>BOOLEAN<br>KeTestSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__in&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;KeMemoryBarrierWithoutFence();//这个函数我也不知道干啥的<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*SpinLock&nbsp;!=&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeYieldProcessor();//若被占用，则空转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>好，看了获取部分，再看看释放锁的时候做了什么。<br><br>__forceinline<br>VOID<br>KeReleaseSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PKSPIN_LOCK&nbsp;SpinLock,<br>&nbsp;&nbsp;&nbsp;&nbsp;__in&nbsp;KIRQL&nbsp;OldIrql<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;KxReleaseSpinLock(SpinLock);//先释放锁<br>&nbsp;&nbsp;KeLowerIrql(OldIrql);//恢复至原IRQL<br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}<br><br>继续看KxReleaseSpinLock（）<br><br>__forceinline<br>VOID<br>KxReleaseSpinLock&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;__inout&nbsp;PKSPIN_LOCK&nbsp;SpinLock<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>InterlockedAnd64((LONG64&nbsp;*)SpinLock,&nbsp;0);//释放时进行与操作设置其为0<br>}<br><br>好了，对于自旋锁的初始化、获取、释放，都有了了解。但是只是谈谈原理，看看WRK，似乎有种纸上谈兵的感觉？那就实战一下，看看真实系统中是如何实现的。以双核系统中XP&nbsp;SP2下内核中关于SpinLock的实现细节为例：<br>用IDA分析双核系统的内核文件ntkrnlpa.exe，关于自旋锁操作的两个基本函数是KiAcquireSpinLock和KiReleaseSpinLock，其它几个类似。<br>.text:004689C0&nbsp;KiAcquireSpinLock&nbsp;proc&nbsp;near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;CODE&nbsp;XREF:&nbsp;<br>sub_416FEE+2D&nbsp;p<br>.text:004689C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;sub_4206C0+5&nbsp;j&nbsp;...<br>.text:004689C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;bts&nbsp;dword&nbsp;ptr&nbsp;[ecx],&nbsp;0<br>.text:004689C5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;loc_4689C8<br>.text:004689C7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retn<br>.text:004689C8&nbsp;;&nbsp;---------------------------------------------------------------------------<br>.text:004689C8<br>.text:004689C8&nbsp;loc_4689C8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;CODE&nbsp;XREF:&nbsp;KiAcquireSpinLock+5&nbsp;j<br>.text:004689C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;KiAcquireSpinLock+12&nbsp;j<br>.text:004689C8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;dword&nbsp;ptr&nbsp;[ecx],&nbsp;1<br>.text:004689CE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;KiAcquireSpinLock<br>.text:004689D0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pause<br>.text:004689D2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;loc_4689C8<br>.text:004689D2&nbsp;KiAcquireSpinLock&nbsp;endp<br>代码比较简单，还原成源码是这样子的（偷懒用了F5）：<br><br>void&nbsp;__fastcall&nbsp;KiAcquireSpinLock(int&nbsp;_ECX)<br>{<br>&nbsp;&nbsp;while&nbsp;(&nbsp;1&nbsp;)<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;__asm&nbsp;{&nbsp;lock&nbsp;bts&nbsp;dword&nbsp;ptr&nbsp;[ecx],&nbsp;0&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!_CF&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;*(_DWORD&nbsp;*)_ECX&nbsp;&amp;&nbsp;1&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__asm&nbsp;{&nbsp;pause&nbsp;}//应是rep&nbsp;nop，IDA将其翻译成pause<br>&nbsp;&nbsp;}<br>}<br><br>fastcall方式调用，参数KSPIN_LOCK在ECX中，可以看到是一个死循环，先测试其是否置位，若否，则CF将置0，并将ECX置位，即获取锁的操作成功；若是，即锁已被占有，则一直对其进行测试并进入空转状态，这和前面分析的完全一致，只是代码似乎更精炼了一点，毕竟是实用的玩意嘛。<br>再来看看释放时：<br>.text:004689E0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;KiReleaseSpinLock<br>.text:004689E0&nbsp;KiReleaseSpinLock&nbsp;proc&nbsp;near&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;CODE&nbsp;XREF:&nbsp;sub_41702E+E&nbsp;p<br>.text:004689E0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;sub_4206D0+5&nbsp;j&nbsp;...<br>.text:004689E0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;ptr&nbsp;[ecx],&nbsp;0<br>.text:004689E3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retn<br>.text:004689E3&nbsp;KiReleaseSpinLock&nbsp;endp<br>这个再清楚不过了，直接设置为0就代表了将其释放，此时那些如虎狼般疯狂空转的其它处理器将马上获知这一信息，于是，下一个获取、释放的过程开始了。这就是最基本的自旋锁，其它一些自旋锁形式是对这种基本形式的扩充。比如排队自旋锁，是为了解决多处理器竞争时的无序状态等等，不多说了。<br>现在对自旋锁可谓真的是明明白白了，之前我犯的错误就是以为用了自旋锁就能保证多核同步，其实不是的，<span style="color:red;"   >用自旋锁来保证多核同步的前提是大家都要用这个锁<span style="color:#13253c;"   >。若当前处理器已占有自旋锁，只有别的处理器也来请求这个锁时，才会进入空转，不进行别的操作，这时你的操作将不会受到干扰。但是假如某个需要互斥的操作只有你这个线程才做而别人根本不去做（以iceboy的安全实现Inline&nbsp;Hook为例，请求锁、修改代码、释放锁的过程只有这个线程才会做，别的处理器上的<br>线程如果要执行这里还是照样执行，人家又不用修改），所以人家不请求锁时还是该干嘛干嘛啊，自己在那儿自旋只是一厢情愿。所以MJ说"别人都不跟你旋，你自己旋个头啊"，经典经典…….</span></span></span></span></span></span></span></span></span></span></span></span></p>
</body></html>