<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：汇编一些有用的知识 （笔记）</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>汇编一些有用的知识 （笔记）</h2>
<p align="right">发布时间：2010-12-6 10:35
<br>分类名称：Debug_Crack</p><br>
<div>注释：里面的一些解释来自《使用OllyDbg从零开始系列》教程。</div><div><span style="line-height: 28px;"   >===============================================</span></div><div>RAX, EAX, AX, AL, AH 分别对应64bit， 32bit， 16bit（低），16bit（高）</div><div><span style="line-height: 28px;"   >===============================================</span></div><div><p><b><span lang="EN-US"   style="font-family: 宋体;"   >NOP</span><span style="font-family: 宋体;"   >（无操作<span lang="EN-US"   >) （对应的16进制编码为90）</span></span></b></p><p><span style="line-height: 28px; font-family: 宋体;"   >运行这条指令不会对寄存器</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >内存以及堆栈造成任何影响</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >英文单词的意思是</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >”</span><span style="line-height: 28px; font-family: 宋体;"   >无操作”，也就是说</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >它没有特殊的用途。例如，你用一个短指令来替换一个长指令的话，如果处理器没有错误</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >多余的空间将会被</span><span lang="EN-US"   style="line-height: 28px; font-family: 宋体;"   >NOP</span><span style="line-height: 28px; font-family: 宋体;"   >填充。</span></p></div><div>===============================================</div><div>Push，Pop</div><div>这本来很简单的两条指令，但如果不理解清楚，可能在反汇编的时候，会经常被Esp，Ebp搞得稀里糊涂。一开始我一直以为，Push 1，及相当与将1压栈，然后esp指向1紧邻的下一个单元，后来才发现这种理解是错误的。Push 1,相当于esp先下移（减小一个指针单元），然后将1存入esp指向的单元里。对应的，Pop先指向的值存入目标内存，然后再上移。</div><div><br></div><div><p><span lang="EN-US"   >PUSHAD </span></p>

<p><span lang="EN-US"   >PUSHAD</span><span>指令把所有通用寄存器的内容按一定顺序压入到堆栈中</span><span lang="EN-US"   >,PUSHAD</span><span>也就相当于</span><span lang="EN-US"   >’PUSH EAX, PUSH ECX, PUSH
EDX, PUSH EBX, PUSH ESP, PUSH EBP, PUSH ESI, PUSH EDI’</span><font face="宋体"   >。</font><br><span style="line-height: 28px;"   ><br>POPAD</span></p><p>

</p><p><span>该指令与</span><span lang="EN-US"   >PUSHAD</span><span>正好相反</span><span lang="EN-US"   >,</span><span>它从堆栈中取值</span><span lang="EN-US"   >,</span><span>并将它们放到相应的寄存器中。</span><span lang="EN-US"   >POPAD</span><span>等价于“</span><span lang="EN-US"   >POP EDI,POP ESI,POP ESP,POP
ESP,POP EBX,POP EDX,POP ECX,POP EAX</span><span>”。</span><span lang="EN-US"   ></span></p><p><font face="宋体"   >这俩条指令，通常在被加壳的程序里常见（如UPX等）。</font></p><p><font face="宋体"   ><br></font></p><p><span lang="EN-US"   >PUSHA </span><span>等价于</span><span lang="EN-US"   > 'PUSH AX, CX, DX, BX, SP, BP,
SI, DI'</span><span>。</span><span lang="EN-US"   ></span></p><p><span lang="EN-US"   >POPA </span><span>等价于</span><span lang="EN-US"   > 'pop DI, SI, BP, SP, BX, DX, CX,
AX'</span><span>。</span><span lang="EN-US"   ></span></p><p>



</p><p><span lang="EN-US"   >PUSHA,POPA</span><span>和</span><span lang="EN-US"   >PUSHAD,POPAD</span><span>就像姐妹一样</span><span lang="EN-US"   >,</span><span>只不过它们在</span><span lang="EN-US"   >16</span><span>位程序中使用</span></p></div><div><span style="line-height: 28px;"   >===============================================</span></div><div>mov 只要记住俩个只能赋值的情况，其余的情况都能随意赋值。</div><div>段寄存器只能通过普通寄存器来被赋值。 如：MOV DS，EAX</div><div>内存单元只能通过寄存器来被赋值。<span style="white-space:pre;"   ></span>&nbsp; &nbsp; &nbsp; &nbsp;如：MOV [12345678]，EAX</div><div><br></div><div><p><span lang="EN-US"   >MOVSX (</span><span>带符号（S)</span><span style="line-height: 28px; font-family: 宋体;"   >扩展(X)的传送指令</span><span lang="EN-US"   style="line-height: 28px;"   >)</span></p>

<p><span>第二个操作数可能一个寄存器也可能是内存单元</span><span lang="EN-US"   >,&nbsp;</span><span>第一个操作数的位数比第二个操作数多</span><span lang="EN-US"   >,&nbsp;</span><span>第二个操作数的符号位填充第一个操作数剩余部分。</span>&nbsp;<font face="宋体"   >如MOVSX EAX, BX, 其中BX值为F000，EAX中为全0，结果为EAX剩余的高位，用BX的最高位填充，如果是一个负数，最高位为1，全用1填充，EAX为FFFFF000.如果BX为1234，则EAX为00001234.</font></p><p><span><br></span></p></div><div><p><span lang="EN-US"   >MOVZX (</span><span>带</span><span lang="EN-US"   >0</span><span>扩展的传送指令</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >MOVZX</span><span>类似于前面的语句</span><span lang="EN-US"   >,</span><span>但是这种情况下</span><span lang="EN-US"   >,</span><span>剩余的部分不根据第二个操作数的正负来进行填充。我们这里不提供范例</span><span lang="EN-US"   >,</span><span>因为和上面是相似的</span><span lang="EN-US"   >,&nbsp;</span><span>剩余的部分总是被填充为</span><span lang="EN-US"   >0<font face="宋体"   >，不判断符号位。相当于无符号操作。</font></span></p></div><div>===============================================</div><div>[] 中放的地址，用来寻找地址对应内存中的值，只能是常数，bx，si，di，bp</div><div>正确用法</div><div>[bx],[bp],[si],[di],[bx+si],[bx+di],[bp+si],[bp+di],[bx+si+idata],[bx+di+idata],[bp+si+idta],[bp+di+idata]</div><div><br></div><div>错误用法</div><div>[bx+bp], [si+di]&nbsp;</div><div>SI DI 不能被分成8位寄存器来使用。</div><div>===============================================</div><div><p><span lang="EN-US"   >INC</span>和<span lang="EN-US"   >DEC<br></span><span style="line-height: 28px;"   >INC EAX 、INC DWORD/WORD/BYTE PTR [00452234] 自加一<br></span><span style="line-height: 28px;"   >INC EAX</span><span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >、INC&nbsp;</span><span style="line-height: 28px;"   >DWORD/WORD/BYTE PTR</span><span style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >[00452234]</span><span style="line-height: 28px;"   >&nbsp;自减一<br></span><span style="line-height: 28px;"   ><br>ADD<br></span><span lang="EN-US"   style="line-height: 28px;"   >ADD</span><span style="line-height: 28px;"   ><font face="宋体"   size="3"   >指令有两个操作数</font><span lang="EN-US"   style="font-family: 宋体; font-size: medium;"   >,</span><font face="宋体"   size="3"   >相加后的结果存放到第一个操作数中。</font><span lang="EN-US"   style="font-family: 宋体; font-size: medium;"   >ADD EAX,1</span><font face="宋体"   size="3"   >等价于</font><span lang="EN-US"   style="font-family: 宋体; font-size: medium;"   >INC EAX</span><font face="宋体"   size="3"   >。<br></font></span><span lang="EN-US"   style="line-height: 28px;"   ><font face="宋体"   size="3"   ><br></font>ADC(</span><span style="line-height: 28px;"   >带进位的加法</span><span lang="EN-US"   style="line-height: 28px;"   >)<br></span><span style="line-height: 28px;"   >在这种情况下</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >两个操作数的和加上进位标志的值</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >结果存放到第一个操作数中。如：<br></span><span style="line-height: 28px;"   >ADC ECX，3 &nbsp;；此时ECX为 21， 进位C 为1， ECX = ECX + 3 + 1 = 25<br><br></span></p><p><span lang="EN-US"   >SUB<br></span><span style="line-height: 28px;"   >这个指令与</span><span lang="EN-US"   style="line-height: 28px;"   >ADD</span><span style="line-height: 28px;"   >刚好相反</span><span lang="EN-US"   style="line-height: 28px;"   >-</span><span style="line-height: 28px;"   >它将第一个操作数减去第二个操作数的值存放到第一个操作数中。</span></p><p><span lang="EN-US"   >SBB<br></span><span style="line-height: 28px;"   >该指令跟</span><span lang="EN-US"   style="line-height: 28px;"   >ADC</span><span style="line-height: 28px;"   >正好相反</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >它计算两个操作数的差值</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >并且还要减去进位标志</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >结果存放到第一个操作数中。<br><br></span></p><p><span lang="EN-US"   >MUL(</span>无符号数的乘法<span lang="EN-US"   >)<br></span><span style="line-height: 28px;"   >有两种乘法</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >第一个种是</span><span lang="EN-US"   style="line-height: 28px;"   >MUL,</span><span style="line-height: 28px;"   >这种是无符号数乘法</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >只有一个操作数</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >另一个操作数是</span><span lang="EN-US"   style="line-height: 28px;"   >EAX,</span><span style="line-height: 28px;"   >结果存放到</span><span lang="EN-US"   style="line-height: 28px;"   >EDX:EAX</span><span style="line-height: 28px;"   >中。</span><span style="line-height: 28px;"   >例如</span><span lang="EN-US"   style="line-height: 28px;"   >:<br></span><span style="line-height: 28px;"   >MUL ECX<br></span><span style="line-height: 28px;"   >这里是无符号数</span><span lang="EN-US"   style="line-height: 28px;"   >EAX, ECX</span><span style="line-height: 28px;"   >相乘</span><span lang="EN-US"   style="line-height: 28px;"   >,&nbsp;</span><span style="line-height: 28px;"   >结果存放到</span><span lang="EN-US"   style="line-height: 28px;"   >EDX:EAX</span><span style="line-height: 28px;"   >中。<br><br></span></p><p><span lang="EN-US"   >IMUL(</span>有符号数的乘法<span lang="EN-US"   >)<br></span><span lang="EN-US"   style="line-height: 28px;"   >IMUL</span><span style="line-height: 28px;"   >指令用法类似于</span><span lang="EN-US"   style="line-height: 28px;"   >MUL</span><span style="line-height: 28px;"   >。<br></span><span style="line-height: 28px;"   >IMUL ECX<br></span><span style="line-height: 28px;"   >该指令将有有符号数</span><span lang="EN-US"   style="line-height: 28px;"   >ECX</span><span style="line-height: 28px;"   >乘以</span><span lang="EN-US"   style="line-height: 28px;"   >EAX,</span><span style="line-height: 28px;"   >结果存放到</span><span lang="EN-US"   style="line-height: 28px;"   >EDX:EAX</span><span style="line-height: 28px;"   >中。<br></span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >除了上面一条指令外</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 宋体;"   >,IMUL</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >还允许使用多个操作数</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 宋体;"   >,</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >这是与</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 宋体;"   >MUL</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >不同的地方。</span></p><p>尽管在默认情况下是使用<span lang="EN-US"   >EAX</span>和<span lang="EN-US"   >EDX</span>寄存器<span lang="EN-US"   >,</span>但是我们还可以指定其他的数据源以及目标多达三个操作数。第一个操作数<span lang="EN-US"   >,</span>用来乘以两个数<span lang="EN-US"   >,</span>并且保存相乘的结果<span lang="EN-US"   >,</span>结果必须保存在寄存器中。下面我们将看到两个和三个操作数的例子。<span lang="EN-US"   ></span></p><p>

</p><p><span lang="EN-US"   >F7EB&nbsp; IMUL
EBX&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EAX x EBX -&gt; EDX:EAX</span></p><p>这是第一个例子<span lang="EN-US"   >,</span>类似于<span lang="EN-US"   >MUL,</span>但是是有符号的乘法。<span lang="EN-US"   ></span></p><p><span lang="EN-US"   >696E74020080FF&nbsp;&nbsp;  IMUL EBP, DWORD PTR [ESI+74] &nbsp;; FF800002 [ESI+74] x FF800002 -&gt; EBP </span></p><p><span lang="EN-US"   ><font size="3"   >



<span style="font-family: 宋体;"   >这是第二个例子<span lang="EN-US"   >,</span>其中有三个操作数<span lang="EN-US"   >:&nbsp;
ESI+74</span>内存单元的值乘以<span lang="EN-US"   >FF800002,</span>并且将结果存储到<span lang="EN-US"   >EBP</span>中。我们可以在<span lang="EN-US"   >OD</span>中执行看看。相乘的结果，如果很大，最高位部分将被舍弃。（溢出了）。所以，如果想做大数运算，你得自己实现，溢出部分的处理。用大数库即可。</span></font></span></p><p>第三个例子<span lang="EN-US"   >,</span>只有两个操作数<span lang="EN-US"   >,</span>两者相乘<span lang="EN-US"   >,</span>并将结果存放到第一个操作数中。<span lang="EN-US"   ></span></p><p><span lang="EN-US"   >

</span></p><p><span lang="EN-US"   >0FAF55E8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMUL EDX, DWORD PTR [EBP-18] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDX
x [EBP-18] -&gt; EDX</span></p><p><span lang="EN-US"   ><br></span></p><p>正如你所看到的<span lang="EN-US"   >,</span>这些方法中<span lang="EN-US"   >,</span>最好的方式就是一个操作数的方式<span lang="EN-US"   >,</span>结果存放到<span lang="EN-US"   >EDX:EAX</span>中<span lang="EN-US"   >,</span>这意味着拥有两倍的大小<span lang="EN-US"   >,</span>通过两个操作数或者三个操作数无法完成的操作可以通过一个操作数的方式来完成。<span lang="EN-US"   ></span></p><p><span lang="EN-US"   >DIV(</span>无符号除法<span lang="EN-US"   >)/IDIV(</span>有符号除法<span lang="EN-US"   >)</span></p><p>这两个指令反别与<span lang="EN-US"   >MUL</span>和<span lang="EN-US"   >IMUL</span>相反。<span lang="EN-US"   ></span></p><p><span lang="EN-US"   >DIV</span>只有一个操作数<span lang="EN-US"   >,</span>该操作数必须是无符号数<span lang="EN-US"   >,</span>结果存放到<span lang="EN-US"   >EDX:EAX</span>中。<span lang="EN-US"   ></span></p><p><span lang="EN-US"   ><font size="3"   ><span style="font-family: 宋体;"   >IDIV指令经常被使用。如果是一个操作数的话<span lang="EN-US"   >,</span>那么它和<span lang="EN-US"   >DIV</span>类似<span lang="EN-US"   >,</span>只不过操作数是有符号的<span lang="EN-US"   >,</span>结果依然保存在<span lang="EN-US"   >EDX:EAX</span>中。两个操作数的情况<span lang="EN-US"   >,</span>第一个操作数除以第二个操作数，结果存放到第一个操作数中。三个操作数的情况<span lang="EN-US"   >,</span>第二个操作数除以第三个操作数<span lang="EN-US"   >,</span>结果存放到第一个操作数中。<br></span></font><span lang="EN-US"   style="line-height: 28px;"   ><br>XADD(</span><span style="line-height: 28px;"   >交换并相加</span><span lang="EN-US"   style="line-height: 28px;"   >)<br></span></span><span style="line-height: 28px;"   >正如你所猜想的一样</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >这个指令其实就是</span><span lang="EN-US"   style="line-height: 28px;"   >XCHG</span><span style="line-height: 28px;"   >和</span><span lang="EN-US"   style="line-height: 28px;"   >ADD</span><span style="line-height: 28px;"   >两个简单指令的组合。相当于：<br></span><span style="line-height: 28px;"   >XCHG EAX, EBX<br></span><span style="line-height: 28px;"   >ADD &nbsp; &nbsp;EAX, EBX<br><br></span></p><p><span lang="EN-US"   >NEG<br></span><span style="line-height: 28px;"   >该指令的目的是将操作数的符号取反</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >即如果我们有一个</span><span lang="EN-US"   style="line-height: 28px;"   >32</span><span style="line-height: 28px;"   >位的</span><span lang="EN-US"   style="line-height: 28px;"   >16</span><span style="line-height: 28px;"   >进制数</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >用</span><span lang="EN-US"   style="line-height: 28px;"   >NEG</span><span style="line-height: 28px;"   >操作以后</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >结果就会取反。例如：<br></span><span style="line-height: 28px;"   >NEG EAX ; EAX值为0x32，结果为-32 (补码表示：FFFFFFCE)<br></span><span style="line-height: 28px;"   ><br>逻辑指令<br></span><span style="line-height: 28px;"   >逻辑指令有两个操作数</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >两操作数按位运算</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >并将结果存放到第一个操作数中。</span></p><div style="line-height: 28px;"   ><p style="line-height: 28px;"   ><span lang="EN-US"   style="line-height: 28px;"   >AND<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >只有两个二进制位都为</span><span lang="EN-US"   style="line-height: 28px;"   >1</span><span style="line-height: 28px;"   >的时候结果才为</span><span lang="EN-US"   style="line-height: 28px;"   >1,</span><span style="line-height: 28px;"   >其他情况</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >结果都为</span><span lang="EN-US"   style="line-height: 28px;"   >0</span><span style="line-height: 28px;"   >。<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 and 1 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 and 0 = 0<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 and 1 = 0<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 and 0 = 0</span></p><p style="line-height: 28px;"   ><span lang="EN-US"   style="line-height: 28px;"   >&nbsp;</span><span style="line-height: 28px;"   >OR<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >该指令</span><span lang="EN-US"   style="line-height: 28px;"   >AND</span><span style="line-height: 28px;"   >的不同之处在于</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >两位中只要有一位为</span><span lang="EN-US"   style="line-height: 28px;"   >1,</span><span style="line-height: 28px;"   >结果就取</span><span lang="EN-US"   style="line-height: 28px;"   >1</span><span style="line-height: 28px;"   >。<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 or 1 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 or 0 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 or 1 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 or 0 = 0</span><span style="line-height: 28px;"   >&nbsp;</span></p><p style="line-height: 28px;"   ><span lang="EN-US"   style="line-height: 28px;"   >XOR<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >该指令时异或运算</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px;"   >当两位不同时取</span><span lang="EN-US"   style="line-height: 28px;"   >1,</span><span style="line-height: 28px;"   >相同时取</span><span lang="EN-US"   style="line-height: 28px;"   >0</span><span style="line-height: 28px;"   >。<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 xor 1 = 0<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >1 xor 0 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 xor 1 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >0 xor 0 = 0&nbsp;</span></p></div><div style="line-height: 28px;"   ><p style="line-height: 28px;"   ><span lang="EN-US"   style="line-height: 28px;"   >NOT<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >该指令是简单的按位取反。<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >not 1 = 0<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >not 0 = 1<br style="line-height: 28px;"   ></span><span style="line-height: 28px;"   >例如</span><span lang="EN-US"   style="line-height: 28px;"   >:not 0110 = 1001&nbsp;</span></p></div></div><div><span style="line-height: 28px;"   >===============================================</span></div><div><p><span lang="EN-US"   >XCHG (</span><span>交换</span> <span>寄存器</span><span lang="EN-US"   >/</span><span>内存单元</span> <span>和</span>
<span>寄存器</span><span lang="EN-US"   >)<br></span><span style="line-height: 28px; font-family: 宋体;"   >该指令交换两个操作数的值</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >例如</span><span lang="EN-US"   style="line-height: 28px;"   >:<br></span><span style="line-height: 28px;"   >XCHG EAX,ECX</span></p><p><span lang="EN-US"   ></span></p><div style="line-height: 28px; color: rgb(0, 0, 0); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"   ></div><p></p><div style="line-height: 28px; color: rgb(0, 0, 0); font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, 宋体; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"   >===============================================</div></div><div>xor eax，eax 相当于 mov eax，0<br>lea edi，[epb-0ch] 相当于 mov edi, epb-0ch，但后面的mov指令是错的。epb-0ch不能这么写。但可以将其放到[]中。<br><br>===============================================</div><div>X ptr 指明内存单元的长度。X可以为(word, byte)</div><div><br></div><div>===============================================</div><div>db 重复次数 dup (重复的字节型数据)</div><div>dw 重复次数 dup (重复的字节型数据)</div><div>dd 重复次数 dup (重复的字节型数据)</div><div><br></div><div>===============================================</div><div>无条件转移指令</div><div>段内转移</div><div><span style="white-space:pre;"   > </span>短转移(-128~127)</div><div><span style="white-space:pre;"   > </span>jmp short 标号(8bit)</div><div><span style="white-space:pre;"   > </span></div><div><span style="white-space:pre;"   > </span>近转移(-32768~32767)</div><div><span style="white-space:pre;"   > </span>jmp near 标号(16bit)</div><div><span style="white-space:pre;"   > </span>jmp reg(16bit)</div><div><span style="white-space:pre;"   > </span>jmp word ptr 内存地址(16bit)</div><div><span style="white-space:pre;"   > </span></div><div>段间转移</div><div><span style="white-space:pre;"   > </span>jmp far ptr 标号</div><div><span style="white-space:pre;"   > </span>jmp dword ptr 内存地址</div><div><br></div><div>条件转移指令 短转移</div><div>jcxz， cx=0，就跳</div><div><br></div><div>===============================================</div><div>过程</div><div>ret &nbsp;用于栈中的数据，修改IP的内容，实现近转移</div><div>相当于 pop IP</div><div><br></div><div>retf 用于栈中的数据，修改CS和IP的内容，实现远转移</div><div>相当于 pop IP，pop CS</div><div><br></div><div>call 将当前IP或CS和IP压栈，转移（不能实现短转移）</div><div><br></div><div>近转移</div><div><span style="white-space:pre;"   > </span>call reg(16bit)</div><div><span style="white-space:pre;"   > </span>call word ptr 内存地址(16bit)</div><div><span style="white-space:pre;"   > </span>call 标号</div><div>相当于：</div><div><span style="white-space:pre;"   > </span>push IP</div><div><span style="white-space:pre;"   > </span>jmp near ptr 标号</div><div><br></div><div>远转移</div><div><span style="white-space:pre;"   > </span>call dword ptr 内存地址</div><div><span style="white-space:pre;"   > </span>call far ptr 标号 段间转移</div><div>相当于：</div><div><span style="white-space:pre;"   > </span>push CS</div><div><span style="white-space:pre;"   > </span>push IP</div><div><span style="white-space:pre;"   > </span>jmp far ptr 标号</div><div>===============================================</div><div>中断</div><div><br></div><div>CPU 内部中断：</div><div>除法错误</div><div>单步执行</div><div>执行into指令</div><div>执行int指令</div><div><br></div><div>iret相当于：</div><div>pop IP</div><div>pop CS</div><div>popf</div><div><br></div><div>int n</div><div><br></div><div><br></div><div>===============================================</div><div>cmp opr1，opr2</div><div>opr1-opr2，不保存结果，影响标志位。</div><div>opr1 == opr2,<span style="white-space:pre;"   > </span>zf = 1</div><div>opr1 != opr2,<span style="white-space:pre;"   > </span>zf = 0</div><div>opr1 &lt; opr2,<span style="white-space:pre;"   > </span>cf = 1</div><div>opr1 &gt;= opr2,<span style="white-space:pre;"   > </span>cf = 0</div><div>opr1 &gt; opr2,<span style="white-space:pre;"   > </span>cf = 0 &amp;&amp; zf = 0</div><div>opr1 &lt;= opr2,<span style="white-space:pre;"   > </span>cf = 1 || zf = 1<br>大部分情况下，只判断zf即可。对应的跳转指令有：jz/je</div><div><br></div><div><p><span lang="EN-US"   >JMP </span><span  >–</span>
<span  >跳转</span> <span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JE, JZ </span><span  >–</span>
<span  >结果为零则跳转</span><span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JNE, JNZ </span><span  >–</span>
<span  >结果不为零则跳转</span> <span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JS </span><span  >–</span>
<span  >结果为负则跳转</span><span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JNS </span><span  >–</span>
<span  >结果不为负则跳转</span> <span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JP, JPE </span><span  >–</span>
<span  >结果中</span><span lang="EN-US"   >1</span><span  >的个数为偶数则跳转</span>
<span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JNP, JNPE </span><span  >–</span>
<span  >结果为</span><span lang="EN-US"   >1</span><span  >的个数为奇数则跳转</span>
<span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JO </span><span  >–</span>
<span  >结果溢出了则跳转</span> <span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JNO </span><span  >–</span>
<span  >结果没有溢出则跳转</span><span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >JB, JNAE </span><span  >–</span>
<span  >小于则跳转</span><span lang="EN-US"   > (</span><span  >无符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JNB, JAE </span><span  >–</span>
<span  >大于等于则跳转</span><span lang="EN-US"   > (</span><span  >无符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JBE, JNA </span><span  >–</span>
<span  >小于等于则跳转</span><span lang="EN-US"   > (</span><span  >无符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JNBE, JA </span><span  >–</span>
<span  >大于则跳转</span><span lang="EN-US"   >(</span><span  >无符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JL, JNGE </span><span  >–</span><span lang="EN-US"   >&nbsp; </span><span  >小于则跳转</span><span lang="EN-US"   > (</span><span  >有符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JNL, JGE </span><span  >–</span>
<span  >大于等于则跳转</span><span lang="EN-US"   > (</span><span  >有符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JLE, JNG </span><span  >–</span>
<span  >小于等于则跳转</span><span lang="EN-US"   > (</span><span  >有符号数</span><span lang="EN-US"   >)</span></p>

<p><span lang="EN-US"   >JNLE, JG </span><span  >–</span>
<span  >大于则跳转</span><span lang="EN-US"   >(</span><span  >有符号数</span><span lang="EN-US"   >)</span></p><p><span lang="EN-US"   ><br></span></p></div><div>常和条件转移一起使用：</div><div>je/jz<span style="white-space:pre;"   > </span>==,<span style="white-space:pre;"   > </span>zf == 0</div><div>jne/jnz<span style="white-space:pre;"   > </span>!=,<span style="white-space:pre;"   > </span>zf != 0</div><div>jb/jnae<span style="white-space:pre;"   > </span>&lt;,<span style="white-space:pre;"   > </span>cf == 1</div><div>jnb/jae<span style="white-space:pre;"   > </span>&gt;=,<span style="white-space:pre;"   > </span>cf == 0</div><div>ja/jnbe<span style="white-space:pre;"   > </span>&gt;,<span style="white-space:pre;"   > </span>cf == 0 &amp;&amp; zf == 0</div><div>jna/jbe<span style="white-space:pre;"   > </span>&lt;=, cf == 1 || zf == 1</div><div><p style="line-height: 28px;"   ><span lang="EN-US"   style="line-height: 28px;"   >JL/JNGE</span><span lang="EN-US"   style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >&lt;,</span><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >sf == 1</span><br></span><span lang="EN-US"   style="line-height: 28px;"   >JNL/JGE&nbsp;</span><span lang="EN-US"   style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >&gt;=,</span><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >cf == 0</span><br></span><span lang="EN-US"   style="line-height: 28px;"   >JLE/JNG</span><span lang="EN-US"   style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >&gt;,<span style="white-space: pre;"   >s</span></span><span style="line-height: 28px;"   >f == 0 &amp;&amp; zf == 0</span><br></span><span lang="EN-US"   style="line-height: 28px;"   >JNLE/JG</span><span style="line-height: 28px; white-space: pre;"   > </span><span style="line-height: 28px;"   >&lt;=, sf == 1 || zf == 1</span></p></div><div><br></div><div>写程序不必分析标志位，只要分析逻辑方式就可以。</div><div><br></div><div>===============================================</div><div>标志位：</div><div>ZF, zero flag<span style="white-space:pre;"   > </span>结果为0，则ZF = 1</div><div>PF, parity flag<span style="white-space:pre;"   > </span>结果1个个数是否为偶数，如果是偶数，则PF = 1</div><div>SF，sign flag，<span style="white-space:pre;"   > </span>结果为负，则SF = 1</div><div>CF，carry flag，进位</div><div>OF，overflow flag，溢出</div><div>DF，direction flag，方向标识 针对串处理，（SI，DI），DF == 0，SI，DI每次递增，反之递减。</div><div><br></div><div>===============================================</div><div>串处理</div><div><p><span lang="EN-US"   >MOVS<br><font size="3"   ><span style="font-family: 宋体;"   >该指令是从一个地址向另一个地址复制数据。源地址保存在</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >ESI</span><span style="font-family: 宋体;"   >寄存器中</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,</span><span style="font-family: 宋体;"   >目的地址保存在</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >EDI</span><span style="font-family: 宋体;"   >寄存器中。我们不需要显示地指定参数。</span>&nbsp;</font></span></p></div><div>MOVSB 传送一个字节</div><div><span style="line-height: 28px;"   >MOVSW</span><span style="line-height: 28px;"   >传送一个字</span><span style="line-height: 28px;"   >&nbsp;</span></div><div>MOVSD<span style="line-height: 28px;"   >传送一个双字</span></div><div><span style="line-height: 28px;"   ><br></span></div><div><span style="line-height: 28px;"   >MOVSB 传送一个字节</span></div><div>汇编描述：</div><div>mov es:[di], byte ptr ds:[si]<span style="white-space:pre;"   > </span>;8086不支持，只是用来描述</div><div>if df == 0:</div><div><span style="white-space:pre;"   > </span>inc si</div><div><span style="white-space:pre;"   > </span>inc di</div><div>if df == 1:</div><div><span style="white-space:pre;"   > </span>dec si</div><div><span style="white-space:pre;"   > </span>dec di</div><div><br></div><div>movsw 传送一个字</div><div>mov es:[di], word ptr ds:[si]<span style="white-space:pre;"   > </span>;8086不支持，只是用来描述</div><div>if df == 0:</div><div><span style="white-space:pre;"   > </span>add si,2</div><div><span style="white-space:pre;"   > </span>add di,2</div><div>if df == 1:</div><div><span style="white-space:pre;"   > </span>sub si,2</div><div><span style="white-space:pre;"   > </span>sub di,2</div><div><br></div><div><div style="line-height: 28px;"   >movsd 传送一个<span style="line-height: 28px;"   >双</span><span style="line-height: 28px;"   >字</span></div><div style="line-height: 28px;"   >mov es:[di], dword ptr ds:[si]<span style="line-height: 28px; white-space: pre;"   > </span>;8086不支持，只是用来描述</div><div style="line-height: 28px;"   >if df == 0:</div><div style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span>add si,4</div><div style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span>add di,4</div><div style="line-height: 28px;"   >if df == 1:</div><div style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span>sub si,4</div><div style="line-height: 28px;"   ><span style="line-height: 28px; white-space: pre;"   > </span>sub di,4</div></div><div><span style="white-space:pre;"   > </span></div><div><p><span lang="EN-US"   >REP </span></p>

<p><span  >该指令可做为前面介绍的一些指令的前缀</span><span lang="EN-US"   >,</span><span  >尤其是</span><span lang="EN-US"   >MOVS</span><span  >指令。该前缀表示当前指令需要执行的次数</span><span lang="EN-US"   >ECX</span><span  >。每次循环计数器</span><span lang="EN-US"   >ECX</span><span  >的值递减</span><span lang="EN-US"   >1,</span><span  >和前面介绍的循环一样。</span><span lang="EN-US"   ></span><font size="3"   ><span style="font-family: 宋体;"   >因此</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,REP MOVS</span><span style="font-family: 宋体;"   >不一定拷贝是</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >4</span><span style="font-family: 宋体;"   >个字节</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,</span><span style="font-family: 宋体;"   >它拷贝的大小为</span><span style="font-family: 'Times New Roman', serif;"   > </span><span style="font-family: 宋体;"   >每次拷贝的大小</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   > * ECX, </span><span style="font-family: 宋体;"   >源指针</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >ESI</span><span style="font-family: 宋体;"   >和目的指针</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >EDI</span><span style="font-family: 宋体;"   >每次递增</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >4</span><span style="font-family: 宋体;"   >或者递减</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >4(</span><span style="font-family: 宋体;"   >递增或递减取决于方向标志位</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >D)</span><span style="font-family: 宋体;"   >。</span></font></p></div><div><font size="3"   ><span style="font-family: 宋体;"   >此外</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,REP</span><span style="font-family: 宋体;"   >前缀还可以衍生出</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >REPE/REPZ</span><span style="font-family: 宋体;"   >和</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >REPNE/REPNZ</span><span style="font-family: 宋体;"   >指令</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,</span><span style="font-family: 宋体;"   >这个时候我们就需要考虑零标志位</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >Z</span><span style="font-family: 宋体;"   >了。但是</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >REPE/REPZ</span><span style="font-family: 宋体;"   >或者</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >REPNZ/REPNE</span><span style="font-family: 宋体;"   >连同</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >MOVS</span><span style="font-family: 宋体;"   >指令一起使用就没有太大意义了。此外还有其他指令支持前缀</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,</span><span style="font-family: 宋体;"   >我们以后再讨论。</span></font></div><div><font size="3"   ><span style="font-family: 宋体;"   ><br></span></font></div><div><p><span lang="EN-US"   >LODS<br></span><span style="line-height: 28px; font-family: 宋体;"   >该指令从源地址</span><span lang="EN-US"   style="line-height: 28px;"   >(</span><span style="line-height: 28px; font-family: 宋体;"   >像之前一样</span><span lang="EN-US"   style="line-height: 28px;"   >,ESI)</span><span style="line-height: 28px; font-family: 宋体;"   >拷贝数据到</span><span lang="EN-US"   style="line-height: 28px;"   >EAX</span><span style="line-height: 28px; font-family: 宋体;"   >中。如：<br></span><span style="line-height: 28px;"   ><font face="宋体"   >LODS DWORD PTR DS:[ESI]; EAX = ESI指向的内存值<br></font></span><span lang="EN-US"   style="line-height: 28px;"   >REP</span><span style="line-height: 28px; font-family: 宋体;"   >前缀也可以与</span><span lang="EN-US"   style="line-height: 28px;"   >LODS</span><span style="line-height: 28px; font-family: 宋体;"   >指令配合使用</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >他们会重复执行直到计数器</span><span lang="EN-US"   style="line-height: 28px;"   >ECX</span><span style="line-height: 28px; font-family: 宋体;"   >的值为</span><span lang="EN-US"   style="line-height: 28px;"   >0</span><span style="line-height: 28px; font-family: 宋体;"   >。</span></p><p><font size="3"   ><span style="font-family: 宋体;"   >也有一次拷贝两个字节和一个字节的</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >LODSW</span><span style="font-family: 宋体;"   >和</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >LODSB</span><span style="font-family: 宋体;"   >指令</span></font></p><p><span lang="EN-US"   >STOS<br></span><span style="line-height: 28px; font-family: 宋体;"   >该指令是将</span><span lang="EN-US"   style="line-height: 28px;"   >EAX</span><span style="line-height: 28px; font-family: 宋体;"   >的值拷贝到</span><span lang="EN-US"   style="line-height: 28px;"   >EDI</span><span style="line-height: 28px; font-family: 宋体;"   >指向的内存单元中。<br></span><font size="3"   ><span style="font-family: 宋体;"   >我们可以使用</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >REP</span><span style="font-family: 宋体;"   >前缀</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >,</span><span style="font-family: 宋体;"   >还有每次操作两个字节的</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >STOSW</span><span style="font-family: 宋体;"   >指令和每次操作一个字节的</span><span lang="EN-US"   style="font-family: 'Times New Roman', serif;"   >STOSB</span><span style="font-family: 宋体;"   >指令。</span></font></p><p><font face="宋体"   size="3"   >例如：Debug版本的VC编译出的函数头部，总有一段类似的代码：</font></p></div><div><span style="line-height: 28px;"   >mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,30h&nbsp;</span><br style="line-height: 28px;"   ><span style="line-height: 28px;"   >mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,0CCCCCCCCh&nbsp;</span><br style="line-height: 28px;"   ><span style="line-height: 28px;"   >rep stos&nbsp;&nbsp;&nbsp; dword ptr es:[edi]&nbsp;</span><br></div><div>将<span style="line-height: 28px;"   >es:[edi] 开始，一次填充4个byte，值为0x</span><span style="line-height: 28px;"   >CCCCCCCC，等一个填充了30*4个0xCC，为何填充CC？CC对应的汇编指令为INT 3，如果调试器在调试，调试器就能中断下来，让调试器最早发现错误的地方。</span></div><div><span style="line-height: 28px;"   ><br></span></div><div>串操作方向，可以通过如下指令指定：</div><div>cld， DF = 0</div><div>std， DF = 1</div><div><br></div><div><p><span lang="EN-US"   >CMPS<br></span><span style="line-height: 28px; font-family: 宋体;"   >该指令比较</span><span lang="EN-US"   style="line-height: 28px;"   >ESI</span><span style="line-height: 28px; font-family: 宋体;"   >和</span><span lang="EN-US"   style="line-height: 28px;"   >EDI</span><span style="line-height: 28px; font-family: 宋体;"   >指向内存单元的内容。<br></span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >指令影响的零标志位</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >Z,</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >所以你可以配合</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >REPE/REPZ</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >前缀指令使用</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >,</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >直到计数器</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >ECX</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >的值为</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >0</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >或者零标志位清</span><span lang="EN-US"   style="line-height: 28px; font-size: medium; font-family: 'Times New Roman', serif;"   >0</span><span style="line-height: 28px; font-size: medium; font-family: 宋体;"   >。</span></p></div><div>===============================================</div><div><div>test属于逻辑运算指令</div><div>功能: 执行BIT与BIT之间的逻辑运算</div><div>测试(两操作数作与运算,仅修改标志位,不回送结果).&nbsp;</div><div>Test对两个参数(目标，源)执行AND逻辑操作,并根据结果设置标志寄存器,结果本身不会保存。EST AX,BX 与 AND AX,BX 命令有相同效果</div><div><br></div><div>语法: TEST r/m,r/m/da<wbr>ta</div><div>影响标志: C,O,P,Z,S(其中C与O两个标志会被设为0)</div><div><br></div><div>运用举例:</div><div>1.Test用来测试一个位,例如寄存器:</div><div><br></div><div>test eax, 100b; b后缀意为二进制</div><div>jnz ******; 如果eax右数第三个位为1,jnz将会跳转</div><div><br></div><div>我是这样想的,jnz跳转的条件是ZF=0,ZF=0意味着ZF(零标志)没被置位,即逻辑与结果为1.</div><div><br></div><div>2.Test的一个非常普遍的用法是用来测试一方寄存器是否为空:</div><div><span style="line-height: 28px;"   >test ecx, ecx</span></div><div>jz somewhere</div><div>如果ecx为零,设置ZF零标志为1,Jz跳转<br><br>===============================================</div><div><p>循环：</p><p><span lang="EN-US"   >XOR ECX,ECX</span></p>

<p><span lang="EN-US"   >MOV ECX,15h</span></p>

<p><span  >将计数器初始化为循环次数</span><span lang="EN-US"   >15h</span><span  >。接下来就是循环体了</span><span lang="EN-US"   >:</span></p>

<p><span lang="EN-US"   >Label:</span></p>

<p><span lang="EN-US"   >DEC ECX</span></p>

<p><span  >该计数器每次递减</span><span lang="EN-US"   >1</span><span  >。</span><span lang="EN-US"   ></span></p>

<p><span  >其实就是循环体了</span><span lang="EN-US"   >,</span><span  >循环体里面可以是任意指令。</span><span lang="EN-US"   ></span></p>

<p><span  >最后</span><span lang="EN-US"   >,</span><span  >你需要添加一个判断计数器是否为</span><span lang="EN-US"   >0</span><span  >的指令以及条件跳转指令。</span><span lang="EN-US"   ></span></p>

<p><span lang="EN-US"   >CMP ECX,0</span></p>

<p><span lang="EN-US"   >JNE Label</span></p><p><span lang="EN-US"   ><br></span></p><div style="line-height: 28px;"   >循环指令（如loop）短转移<br><p><span lang="EN-US"   >LOOP<br></span><span lang="EN-US"   style="line-height: 28px;"   >LOOP</span><span style="line-height: 28px; font-family: 宋体;"   >指令可以帮我们完成前面例子中的事情</span><span lang="EN-US"   style="line-height: 28px;"   >- </span><span style="line-height: 28px; font-family: 宋体;"   >将计数器</span><span lang="EN-US"   style="line-height: 28px;"   >ECX</span><span style="line-height: 28px; font-family: 宋体;"   >的值减</span><span lang="EN-US"   style="line-height: 28px;"   >1,</span><span style="line-height: 28px; font-family: 宋体;"   >判断</span><span lang="EN-US"   style="line-height: 28px;"   >ECX</span><span style="line-height: 28px; font-family: 宋体;"   >的值是否为</span><span lang="EN-US"   style="line-height: 28px;"   >0,</span><span style="line-height: 28px; font-family: 宋体;"   >如果为</span><span lang="EN-US"   style="line-height: 28px;"   >0</span><span style="line-height: 28px; font-family: 宋体;"   >就跳转到指定的地址</span><span lang="EN-US"   style="line-height: 28px;"   >-</span><span style="line-height: 28px; font-family: 宋体;"   >将像前面的例子一样。</span><span lang="EN-US"   style="line-height: 28px;"   >(</span><span style="line-height: 28px; font-family: 宋体;"   >可惜的是</span><span lang="EN-US"   style="line-height: 28px;"   >,</span><span style="line-height: 28px; font-family: 宋体;"   >大多数现代的处理器中该指令的效率不如前面模拟的例子。</span><span lang="EN-US"   style="line-height: 28px;"   >)</span></p></div><div style="line-height: 28px;"   ><br></div>for循环：<br>mov &lt;循环变量&gt;,&lt;初始值&gt; ;给循环变量赋初值<br>jmp B&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ;跳到第一次循环处<br>A： （改变循环变量）&nbsp;&nbsp;&nbsp; ;修改循环变量<br>&nbsp;&nbsp;&nbsp; ... ...<br>B:&nbsp; cmp &lt;循环变量&gt;,&lt;限制变量&gt;&nbsp;&nbsp;&nbsp; ;检查循环调节<br>&nbsp;&nbsp;&nbsp; jge 跳出循环<br>&nbsp;&nbsp;&nbsp; （循环体）<br>&nbsp;&nbsp;&nbsp; ... ...<br>&nbsp;&nbsp;&nbsp; jmp A&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ;跳回去修改循环变量<br><br>如：<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 50; i++)<br>013D2DC7&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr [i],0 <br>013D2DCE&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fun1+39h (13D2DD9h) <br>013D2DD0&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,dword ptr [i] <br>013D2DD3&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,1 <br>013D2DD6&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr [i],eax <br>013D2DD9&nbsp; cmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr [i],32h <br>013D2DDD&nbsp; jge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fun1+4Ah (13D2DEAh) <br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c = c + i;<br>013D2DDF&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,dword ptr [c] <br>013D2DE2&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,dword ptr [i] <br>013D2DE5&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dword ptr [c],eax <br>&nbsp;&nbsp;&nbsp; }<br>013D2DE8&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fun1+30h (13D2DD0h) <br><br>do循环：<br>cmp &lt;循环变量&gt;,&lt;限制变量&gt;<br>jl&nbsp; &lt;循环开始点&gt;<br><br>while循环：<br>A:&nbsp;&nbsp;&nbsp; cmp &lt;循环变量&gt;,&lt;限制变量&gt;<br>&nbsp;&nbsp;&nbsp; jge B<br>&nbsp;&nbsp;&nbsp; (循环体)<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; jmp A<br>B: (循环结束)<br></div></div>
</body></html>