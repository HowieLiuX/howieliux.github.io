<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]深入分析ObReferenceObjectByName有时无法得到指定对象地址</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]深入分析ObReferenceObjectByName有时无法得到指定对象地址</h2>
<p align="right">发布时间：2013-6-24 12:04
<br>分类名称：Driver</p><br>
<P>From：<A rel="nofollow" href="http://bbs.byr.cn/#!article/Security/5093"   >http://bbs.byr.cn/#!article/Security/5093</A></P>
<P>深入分析ObReferenceObjectByName有时无法得到指定对象地址的原因 <BR>by flyingkisser 06.11.25 <BR>有时，我们需要得到像"\Device\XXX"或"\Driver\XXX"这种对象的地址，一般想到的最方便的方法是就是用 <BR>ObReferenceObjectByName.这个函数没有公开，但是被导出了。其参数也比较简单，没什么多说的。 <BR>比如我们想得到"\Driver\KbdClass"对象的地址，调用这个函数可以轻易获得。然而，当我们用这个API <BR>去获得"\Device\KeyboardClass0"对象的地址时，总是返回0xC0000024,即STATUS_OBJECT_TYPE_MIMATCH <BR>对象的类型不匹配，这是哪门子错误，虽然，此路不通时，还有别的方法可以获得这个对象的地址， <BR>但是，我总想把这个问题搞清楚，于是在xp下面逆向了一个这个函数，并结合win2k源代码，最后终于找到了 <BR>问题所在。 <BR>ObReferenceObjectByName是ObpLookupObjectName的包裹函数，对于给定的"\X1\X2"这样的名称， <BR>ObpLookupObjectName会通过ObpLookupDirectoryEntry得到"\X1"对象的地址，再定位到对象头，由对象头再 <BR>找到对象类型的对象的地址，然后再判断一下类型对象-&gt;TypeInfo-&gt;ParseProcedure有没有值，如果不为空， <BR>则调用。如果为空，则不调用(嗯，的确是费话...).对于"\Device"或是"\Driver"，他们的类型对象的 <BR>ParseProcdedure都是空，所以代码继续往下走，再通过ObpLookupDirectoryEntry得到"\X1\X2"对象的地址， <BR>然后，和上面是同样的过程，先定位到对象头，再找到对象类型对象的地址，再判断 <BR>类型对象-&gt;TypeInfo-&gt;ParseProcedure是不是为空. <BR>如果是Driver类型的对象，它的Type对象，名称为Driver,其ParseProcedure为空，没有被调用，成功返回 <BR>如果是Device类型的对象，它的Type对象，名称为Device,其ParseProcedure不为空，指向IopParseDevice， <BR>而在IopParseDevice内部，会对传入的一个参数进行检测，这个参数就是我们调用 <BR>ObReferenceObjectByName()时给定的第7个参数:ParseContext.先把这个指针转换成指向OPEN_PACKET类型的指针 <BR>如果这个指针为空，或是这个结构体的Type成员不等于IO_TYPE_OPEN_PACKET或者Size成员不等于sizeof(OPEN_PACKET) <BR>就返回0xC0000024错误，即STATUS_OBJECT_TYPE_MIMATCH.而这个参数一般我们给定的都是空。 <BR>所以，ObReferenceObjectByName最终返回了STATUS_OBJECT_TYPE_MIMATCH <BR>其实这里win2k源代码中是有一段注释的，意思是保证这个Routine的调用是从NtCreateFile()发起的，而不是 <BR>其实任意的对象打开或创建操作发起的，尽是这个参数被标记为"可选的". <BR>所以，看到这里大家应该清楚了吧，说到底，还是我们被M$玩弄了。 <BR>那么，如何解决这个问题呢？ <BR>我本想搞清楚这个ParseContext指向的OPEN_PACKET类型的结构体如何初始化的， <BR>不过在IopParseDevice里面会看到大量使用了这个结构体的成员，所以，我觉得分析下去挺没意思了，体力活， <BR>实在不想干。 <BR>其实解决这个问题也很简单，调用IoGetDeviceObjectPointer()就是了，当然，从它的名称也能看出，它只能 <BR>得到Device类型的对象的地址。 <BR>其实比较稳妥的方法是调用ZwCreateFile()得到给定名称的对象的句柄，再用ObReferenceObjectByHandle就能 <BR>得到对象的地址了，然后句柄就可以ZwClose掉了，最后对象用完以后可别忘了ObDereferenceObject一下。 <WBR></P>
</body></html>