<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：【转】汇编指令与机器码的相互转换</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>【转】汇编指令与机器码的相互转换</h2>
<p align="right">发布时间：2012-1-22 16:00
<br>分类名称：Debug_Crack</p><br>
<p><span style="font-family:宋体; font-size:12pt;"  >机器语言我们只要重点理解一下几个概念：<br><br>1. 机器语言指令有操作码(OP)和地址码两部分组成  </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><br>|_____________OP_______________|__d__|__w__| </span></p><p><span style="font-family:宋体; font-size:12pt;"  >|_____________OP_______________|__s__|__w__| &lt;--此格式用于立即寻址方式 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >在多数操作码中，常使用某些位来指示某些信息：<br>如图上结构里的： w＝1 时 对字来操作<br>w＝0 时 对字节来操作 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >d值在双操作数指令中才有效<br>当 d＝1 时 有且只有一个寄存器用于目的操作数<br>d＝0 时 有且只有一个寄存器用于源操作数 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >s＝1 时 立即数为8位，但要求扩展成16位数<br>s＝0 时 当指令作字节操作/有16位立即数 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >由于汇编的指令格式很多，这里我只作一些基本情况介绍，必要时读者可以下载/查阅80x86汇编小站http://www.x86asm.com提供的OPCODES手册来查阅。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2. 寻址方式的机器语言表示： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >| mod | reg | r/m |<br>|_____|_____|_____|_____|_____|_____|_____| </span></p><p><span style="font-family:宋体; font-size:12pt;"  >reg 表示寄存器方式，在不包括立即数的双操作数指令的情况下，规定必须有一个操作数在寄存器中，该寄存器由reg字段指定，并与操作码字节中的w位相组合确定的寄存器 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >mod字段与r/m(register/memory)字段结合在一起确定另一个操作数的寻址方式现在你们下载了80x86汇编小站(http://www.x86asm.com)提供的OPCODES 手册了吗？<br>下载好了，请解压后打开里面的：opcodes.html 文件，然后熟悉里面的表格：<br><br>现在熟悉简单的：<br>______________________________________________________________________________<br>表1 &lt;PS:部分资料&gt; rrr : W=0 : W=1 : reg32  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >000 : AL : AX : EAX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >001 : CL : CX : ECX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >010 : DL : DX : EDX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >011 : BL : BX : EBX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >100 : AH : SP : ESP  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >101 : CH : BP : EBP  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >110 : DH : SI : ESI  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >111 : BH : DI : EDI<br>______________________________________________________________________________<br>表2 &lt;PS:部分资料&gt; rrr : Index Register <br>000 : EAX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >001 : ECX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >010 : EDX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >011 : EBX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >100 : No Index  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >101 : EBP  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >110 : ESI  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >111 : EDI<br>______________________________________________________________________________<br>表3 &lt;PS:部分资料&gt; mmm : Function 11<br>w＝1<br>000 : DS:[BX+SI]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >001 : DS:[BX+DI]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >010 : SS:[BP+SI]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >011 : SS:[BP+DI] BX  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >100 : DS:[SI]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >101 : DS:[DI]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >110 : SS:[BP]  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >111 : DS:[BX]<br>______________________________________________________________________________<br>表4 &lt;PS:部分资料&gt;<br>oo : Function  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >00 : If mmm = 110, then a displacement follows the operation; otherwise, no displacement is used  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >01 : An 8-bit signed displacement follows the opcode  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >10 : A 16-bit signed displacement follows the opcode  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >11 : mmm specifies a register, instead of an addressing mode<br>______________________________________________________________________________<br>上面的表，你都看明白了吗？ 现在我就教你们如何利用这样的表格来把汇编指令翻译机器码 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3.指令格式简介 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >8086所用的16位指令格式： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >________ _____________ ________ ________<br>|操作码| + |mod-reg-r/m| + |位移量| + |立即数|<br>1~2字节 0~1字节 0~2字节 0~2字节 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >OK!以上就是基本知识，下面我们来实践吧： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >———————————————————————————————————————<br>问题： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MOV AX,1234H 对应的机器码为：B83412  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MOV EBX,0 对应的机器码为：66BB00000000 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >MOV CL,55H 对应的机器码为: B155<br><br>MOV AX,BX 对应的机器码为：8BC3 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >我在问一下，机器码的数据格式是什么？ 好像是 机器指令+操作数(高位存放在地址高位，低位存放在地址低位)，但是前面MOV AX,怎么就变成了B8,弄不明白，请指教。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >PS: 上面的题目是一个网友问的，现在我来实践一遍给你们看。<br>——————————————————————————————————————— </span></p><p><span style="font-family:宋体; font-size:12pt;"  >指令1 －&gt; MOV AX,1234H 对应的机器码为：B83412  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >解法： 判断－&gt; 这个是8086汇编16位汇编指令格式，并且是立即寻址方式<br>查表－&gt; 打开opcodes.html文件，找到标题为"Main Instructions"，单击"M"字母，然后对应查看 "MOV Reg,Imm"格式的"OpCode"项为：1011wrrr<br>再判断－&gt; 由于寄存器是AX, 立即数是1234H，明显是"对字操作"，所以w＝1<br>在查看本文章上面的"表1"，对应的查到rrr的值为000<br>组合结果－&gt; w＝1<br>rrr＝000<br>1011wrrr＝1011 1000B －&gt;B8H <br>根据" 3.指令格式简介" －&gt; B8H + |立即数(低位在前高位在后)|＝ B83412H  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >PS: "+" 符号不为"加号"  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >好了，已经解完第一题了，机器码为 B83412H  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >——————————————————————————————————————— </span></p><p><span style="font-family:宋体; font-size:12pt;"  >指令4 －&gt; MOV AX,BX 对应的机器码为：8BC3 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >解法： 判断－&gt; 这个是8086汇编16位汇编指令格式，并且是寄存器寻址方式<br>查表－&gt; 打开opcodes.html文件，找到标题为"Main Instructions"，单击"M </span></p><p><span style="font-family:宋体; font-size:12pt;"  >"字母，然后对应查看 "MOV Reg,Reg"格式的"OpCode"项为：1000101woorrrmmm<br>再判断－&gt; 由于寄存器是AX, BX 明显是"对字操作"，所以w＝1<br>在查看本文章上面的"表4"，对应查到oo＝11 因为是寄存器寻址方式<br>在查看本文章上面的"表1"，对应查到rrr的值为000 ，因为当两个操 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >作数都是寄存器，那么一般要以目的操作数为准<br>在查看本文章上面的"表3", 对应查到mmm的值为011 ，因为当两个操作数都是寄存器，那么一般要以源操作数为准<br>组合结果－&gt; w＝1<br>oo＝11<br>rrr＝000<br>mmm＝011<br>1000101woorrrmmm＝1000 1011 1100 0011B -&gt;8BC3H </span></p><p><span style="font-family:宋体; font-size:12pt;"  >好了，已经解完第二题了，机器码为8BC3H<br>——————————————————————————————————————— </span></p><p><span style="font-family:宋体; font-size:12pt;"  >呵呵，不错吧，很简单吧，有了80X86 OPCODES 查询表一切都是那么简单，如果还有什么问题，大家都来这里提问！ </span></p><p><span style="font-family:宋体; font-size:12pt;"  >剩下的：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >指令2 －&gt; MOV EBX,0 对应的机器码为：66BB00000000  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >指令3 －&gt; MOV CL,55H 对应的机器码为: B155 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >大家来练练手，注意指令2 需要用到32位指令格式，请查阅相关的80x86汇编语言书籍的机器语言部分，应该有解释的。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >指令2的解法，请大家等待，或者大家研究一下，把解法贴出来，给大家参考哦！ </span></p>
</body></html>