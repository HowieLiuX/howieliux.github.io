<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：What static_cast is actually doing</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>What static_cast is actually doing</h2>
<p align="right">发布时间：2011-11-28 13:05
<br>分类名称：C++</p><br>
<p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  ></span><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Introduction </strong></span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Most programmers learn C before C++, and get used to C style casting. When writing C++, sometimes we may be confused about when to use </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > and when to use </span><span style="color:blue; font-family:Courier New;"  >reinterpret_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  >. In this article, I will illustrate what </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > actually does, and will show some cases that will lead to errors. </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Generic Types </strong></span></p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >float</span> f = <span style="color:navy;"  >12</span>.<span style="color:navy;"  >3</span>;<span style="color:blue;"  ><br>float</span>* pf = &amp;f;</span><br> <span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// static cast&lt;&gt;<br>// OK, n = 12</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>int</span> n = <span style="color:blue;"  >static_cast&lt;int&gt;</span>(f);</span><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// Error, types pointed to are unrelated<br>//int* pn = static_cast&lt;int*&gt;(pf);<br>// OK</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>void</span>* pv = <span style="color:blue;"  >static_cast&lt;void</span>*<span style="color:blue;"  >&gt;</span>(pf);</span><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// OK, but *pn2 is rubbish</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>int</span>* pn2 = <span style="color:blue;"  >static_cast&lt;int</span>*<span style="color:blue;"  >&gt;</span>(pv);</span><br> <span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// reinterpret_cast&lt;&gt;<br>// Error, the compiler know you should<br>// call static_cast&lt;&gt;<br>//int i = reinterpret_cast&lt;int&gt;(f);<br>// OK, but *pn is actually rubbish, same as *pn2</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>int</span>* pi = <span style="color:blue;"  >reinterpret_cast&lt;int</span>*<span style="color:blue;"  >&gt;</span>(pf); </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >In short, </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > will try to convert, e.g., float-to-integer, while </span><span style="color:blue; font-family:Courier New;"  >reinterpret_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > simply changes the compiler's mind to reconsider that object as another type. </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Pointer Types </strong></span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Pointer casting is a bit complicated, we will use the following classes for the rest of the the article: </span></p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >class</span> CBaseX<br>{<span style="color:blue;"  ><br>public</span>:<span style="color:blue;"  ><br>int</span> x;<br>CBaseX() { x = <span style="color:navy;"  >10</span>; }<span style="color:blue;"  ><br>void</span> foo() { printf(<span style="color:purple;"  >"CBaseX::foo() x=%d\n"</span>, x); }<br>}; <br><span style="color:blue;"  ><br>class</span> CBaseY<br>{<span style="color:blue;"  ><br>public</span>:<span style="color:blue;"  ><br>int</span> y;<span style="color:blue;"  ><br>int</span>* py;<br>CBaseY() { y = <span style="color:navy;"  >20</span>; py = &amp;y; }<span style="color:blue;"  ><br>void</span> bar() { printf(<span style="color:purple;"  >"CBaseY::bar() y=%d, *py=%d\n"</span>, y, *py); }<br>};</span><br> <span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>class</span> CDerived : <span style="color:blue;"  >public</span> CBaseX, <span style="color:blue;"  >public</span> CBaseY<br>{<span style="color:blue;"  ><br>public</span>:<span style="color:blue;"  ><br>int</span> z;<br>}; </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Case 1: Casting between unrelated classes </strong></span></p><p style="background: #fbedbb;"  ><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em>// Convert between CBaseX* and CBaseY*</em></span><span style="font-family:Courier New; font-size:9pt;"  ><br>CBaseX* pX = <span style="color:blue;"  >new</span> CBaseX();</span><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// Error, types pointed to are unrelated<br>// CBaseY* pY1 = static_cast&lt;CBaseY*&gt;(pX);<br>// Compile OK, but pY2 is not CBaseX</em></span><span style="font-family:Courier New; font-size:9pt;"  ><br>CBaseY* pY2 = <span style="color:blue;"  >reinterpret_cast&lt;</span>CBaseY*<span style="color:blue;"  >&gt;</span>(pX);</span><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// System crash!!</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:green;"  ><em><br>// pY2-&gt;bar();</em></span>   </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >As we learnt in the generic types example, </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > will fail if you try to cast an object to another unrelated class, while </span><span style="color:blue; font-family:Courier New;"  >reinterpret_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > will always succeed by "cheating" the compiler to believe that the object is really that unrelated class. </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Case 2: Casting to related classes </strong></span></p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >1</span>.  CDerived* pD = <span style="color:blue;"  >new</span> CDerived();<span style="color:navy;"  ><br>2</span>.  printf(<span style="color:purple;"  >"CDerived* pD = %x\n"</span>, (<span style="color:blue;"  >int</span>)pD);<span style="color:navy;"  ><br>3</span>.<span style="color:navy;"  ><br>4</span>.  <span style="color:green;"  ><em>// static_cast&lt;&gt; CDerived* -&gt; CBaseY* -&gt; CDerived*<br>// OK, implicit static_cast&lt;&gt; casting</em></span><span style="color:navy;"  ><br>5</span>.  CBaseY* pY1 = pD;<span style="color:navy;"  ><br>6</span>.  printf(<span style="color:purple;"  >"CBaseY* pY1 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pY1);<span style="color:green;"  ><em><br>// OK, now pD1 = pD</em></span><span style="color:navy;"  ><br>7</span>.  CDerived* pD1 = <span style="color:blue;"  >static_cast&lt;</span>CDerived*<span style="color:blue;"  >&gt;</span>(pY1);<span style="color:navy;"  ><br>8</span>.  printf(<span style="color:purple;"  >"CDerived* pD1 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pD1);<span style="color:navy;"  ><br>9</span>.<span style="color:navy;"  ><br>10</span>. <span style="color:green;"  ><em>// reinterpret_cast<br>// OK, but pY2 is not CBaseY*</em></span><span style="color:navy;"  ><br>11</span>. CBaseY* pY2 = <span style="color:blue;"  >reinterpret_cast&lt;</span>CBaseY*<span style="color:blue;"  >&gt;</span>(pD);<span style="color:navy;"  ><br>12</span>. printf(<span style="color:purple;"  >"CBaseY* pY2 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pY2);<span style="color:navy;"  ><br>13</span>.<span style="color:navy;"  ><br>14</span>. <span style="color:green;"  ><em>// unrelated static_cast&lt;&gt;</em></span><span style="color:navy;"  ><br>15</span>. CBaseY* pY3 = <span style="color:blue;"  >new</span> CBaseY();<span style="color:navy;"  ><br>16</span>. printf(<span style="color:purple;"  >"CBaseY* pY3 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pY3);<span style="color:green;"  ><em><br>// OK, even pY3 is just a "new CBaseY()"</em></span><span style="color:navy;"  ><br>17</span>. CDerived* pD3 = <span style="color:blue;"  >static_cast&lt;</span>CDerived*<span style="color:blue;"  >&gt;</span>(pY3);<span style="color:navy;"  ><br>18</span>. printf(<span style="color:purple;"  >"CDerived* pD3 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pD3); </span></p><p style="background: white;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  >---------------------- output ---------------------------<br>CDerived* pD = 392fb8<br>CBaseY* pY1 = 392fbc<br>CDerived* pD1 = 392fb8<br>CBaseY* pY2 = 392fb8<br>CBaseY* pY3 = 390ff0<br>CDerived* pD3 = 390fec </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Noted that when </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  >-ing </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  > to </span><span style="color:#990000; font-family:Courier New;"  >CBaseY*</span><span style="font-family:Verdana; font-size:10pt;"  > (line 5), the result is </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  > offset by 4. To know what </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > is actually doing, we have to take a look at the memory layout of </span><span style="color:#990000; font-family:Courier New;"  >CDerived</span><span style="font-family:Verdana; font-size:10pt;"  >. </span></p><p style="text-align: center; background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  ><strong>Memory Layout of CDerived </strong></span></p><p style="text-align: center; background: white;"  ><img title="What static_cast is actually doing - Dsliu - Dspace"  src="pic/img6.ph.126.net_MBrRUJ6Gq6uCq8EKimMAgQ==_2787446694382733476.jpg"  alt=""  ><span style="font-family:Verdana; font-size:10pt;"  >   </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >As shown in the diagram, </span><span style="color:#990000; font-family:Courier New;"  >CDerived</span><span style="font-family:Verdana; font-size:10pt;"  >'s memory layout contains two objects, </span><span style="color:#990000; font-family:Courier New;"  >CBaseX</span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:#990000; font-family:Courier New;"  >CBaseY</span><span style="font-family:Verdana; font-size:10pt;"  >, and the compiler knows this. Therefore, when you cast </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  > to </span><span style="color:#990000; font-family:Courier New;"  >CBaseY*</span><span style="font-family:Verdana; font-size:10pt;"  >, it adds the pointer by 4, and when you cast </span><span style="color:#990000; font-family:Courier New;"  >CBaseY</span><span style="font-family:Verdana; font-size:10pt;"  > to </span><span style="color:#990000; font-family:Courier New;"  >CDerived</span><span style="font-family:Verdana; font-size:10pt;"  >, it subtracts the pointer by 4. However, you can do this even if it is not a </span><span style="color:#990000; font-family:Courier New;"  >CDerived</span><span style="font-family:Verdana; font-size:10pt;"  > (line 14-18) [1]. </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Of course, the problem happens only if you have multiple inheritance. </span><span style="color:blue; font-family:Courier New;"  >static_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:blue; font-family:Courier New;"  >reinterpret_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > make no different if you are casting </span><span style="color:#990000; font-family:Courier New;"  >CDerived</span><span style="font-family:Verdana; font-size:10pt;"  > to </span><span style="color:#990000; font-family:Courier New;"  >CBaseX</span><span style="font-family:Verdana; font-size:10pt;"  >. </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Case 3: Casting back and forth between void* </strong></span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Because any pointer can be cast to </span><span style="color:blue;"  ><span style="font-family:Courier New;"  >void<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  >, and </span><span style="font-family:Courier New;"  >void<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  > can be cast back to any pointer (true for both </span><span style="font-family:Courier New;"  >static_cast&lt;&gt;</span></span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:blue; font-family:Courier New;"  >reinterpret_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  >), errors may occur if not handled carefully. </span></p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  >CDerived* pD = <span style="color:blue;"  >new</span> CDerived();<br>printf(<span style="color:purple;"  >"CDerived* pD = %x\n"</span>, (<span style="color:blue;"  >int</span>)pD);</span><br> <span style="font-family:Courier New; font-size:9pt;"  ><br>CBaseY* pY = pD;                <span style="color:green;"  ><em>// OK, pY = pD + 4</em></span><br>printf(<span style="color:purple;"  >"CBaseY* pY = %x\n"</span>, (<span style="color:blue;"  >int</span>)pY);</span><br> <span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  ><br>void</span>* pV1 = pY;                    <span style="color:green;"  ><em>// OK, pV = pY</em></span><br>printf(<span style="color:purple;"  >"void* pV1 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pV1);</span><br> <span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// pD2 = pY, but we expect pD2 = pY - 4</em></span><span style="font-family:Courier New; font-size:9pt;"  ><br>CDerived* pD2 = <span style="color:blue;"  >static_cast&lt;</span>CDerived*<span style="color:blue;"  >&gt;</span>(pV1);<br>printf(<span style="color:purple;"  >"CDerived* pD2 = %x\n"</span>, (<span style="color:blue;"  >int</span>)pD2);</span><span style="color:green; font-family:Courier New; font-size:9pt;"  ><em><br>// System crash</em></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:green;"  ><em><br>// pD2-&gt;bar();</em></span>   </span></p><p style="background: white;"  > &nbsp;</p><p style="background: #fbedbb;"  ><span style="font-family:Courier New; font-size:9pt;"  >---------------------- output ---------------------------<br>CDerived* pD = 392fb8<br>CBaseY* pY = 392fbc<br>void* pV1 = 392fbc<br>CDerived* pD2 = 392fbc </span></p><p style="background: white;"  ><span style="font-family:Verdana; font-size:10pt;"  >Once we have cast the pointer to </span><span style="color:blue;"  ><span style="font-family:Courier New;"  >void<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  >, we can't cast it back to the original class easily. In the above example, the only way to get back a </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  > from a </span><span style="font-family:Courier New;"  >void<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  > is to cast it to a </span><span style="color:#990000; font-family:Courier New;"  >CBaseY*</span><span style="font-family:Verdana; font-size:10pt;"  > and then to </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  >. But if we are not sure whether it is </span><span style="color:#990000; font-family:Courier New;"  >CBaseY*</span><span style="font-family:Verdana; font-size:10pt;"  > or </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  >, then we have to use </span><span style="font-family:Courier New;"  >dynamic_cast&lt;&gt;</span></span><span style="font-family:Verdana; font-size:10pt;"  > or </span><span style="color:blue; font-family:Courier New;"  >typeid</span><span style="font-family:Verdana; font-size:10pt;"  > [2]. </span></p><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>Footnote </strong></span></p><ol><li><div style="background: white;"  ><span style="color:blue; font-family:Courier New;"  >dynamic_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  >, on the other hand, can guard against casting a generic </span><span style="color:#990000; font-family:Courier New;"  >CBaseY*</span><span style="font-family:Verdana; font-size:10pt;"  > to </span><span style="color:#990000; font-family:Courier New;"  >CDerived*</span><span style="font-family:Verdana; font-size:10pt;"  >.  </span></div></li><li><div style="background: white;"  ><span style="color:blue; font-family:Courier New;"  >dynamic_cast&lt;&gt;</span><span style="font-family:Verdana; font-size:10pt;"  > requires the classes to be "polymorphic", i.e., contains "virtual" function, and hence can't be </span><span style="color:blue;"  ><span style="font-family:Courier New;"  >void<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  >. </span></span><span style="font-family:Verdana; font-size:10pt;"  >     </span></div></li></ol><p style="background: white;"  ><span style="color:#ff9900; font-family:Verdana; font-size:13pt;"  ><strong>References </strong></span></p><ul><li><div style="background: white;"  ><span style="font-size:10pt;"  ><span style="font-family:Verdana;"  >[MSDN] </span><span style="color:blue; font-family:宋体;"  >C++ Language Reference -- Casting</span><span style="font-family:Verdana;"  >      </span></span></div></li><li><div style="background: white;"  ><span style="font-size:10pt;"  ><span style="font-family:Verdana;"  >Nishant Sivakumar, </span><span style="color:blue; font-family:宋体;"  >Casting Basics - Use C++ casts in your VC++.NET programs</span><span style="font-family:Verdana;"  >      </span></span></div></li><li><div style="background: white;"  ><span style="font-size:10pt;"  ><span style="font-family:Verdana;"  >Juan Soulie, </span><span style="color:blue; font-family:宋体;"  >C++ Language Tutorial: Type Casting</span><span style="font-family:Verdana;"  >      </span></span></div></li></ul>
</body></html>