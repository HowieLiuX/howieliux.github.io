<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] Windows 自旋锁分析</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] Windows 自旋锁分析</h2>
<p align="right">发布时间：2013-8-20 17:06
<br>分类名称：Driver</p><br>
<p style="background: white;"   ><span style="color:black;"   ><span style="font-family:微软雅黑;"   >From：</span>http://blog.csdn.net/zacklin/article/details/7445304</span>， <a rel="nofollow" href="http://blog.csdn.net/zacklin/article/details/7445314"   >http://blog.csdn.net/zacklin/article/details/7445314</a>
</p><p style="background: white;"   ><span style="color:black; font-family:微软雅黑;"   >自旋锁是一种在内核定义，只能在内核态下使用的同步机制。自旋锁用来保护共享数据或者资源，使得并发执行的程序或者在高优先级IRQL的对称多处理器的程序能够正确访问这些数据。分析Windows自旋锁，首先需要介绍Windows的IRQL。<span style="color:#333333;"   >
</span></span></p><p style="background: white;"   ><span style="color:black; font-family:微软雅黑;"   ><strong>1 Interrupt Request Level(IRQL)</strong><span style="color:#333333;"   >介绍
</span></span></p><p style="background: white;"   ><span style="color:black; font-family:微软雅黑;"   >IRQL是Interrupt RequestLevel，中断请求级别。一个由windows虚拟出来的概念，划分在windows下中断的优先级，这里中断包括了硬中断和软中断，硬中断是由硬件产生，而软中断则是完全虚拟出来的。处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。在同一处理器上，线程只能被更高级别IRQL的线程能中断。每个处理器都有自己的中断。IRQL在Windows下IRQL有如下值：<span style="color:#333333;"   >
</span></span></p><p style="background: white;"   >&nbsp;
&nbsp;</p><p style="background: white;"   ><span style="color:black; font-family:微软雅黑;"   >名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;级别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解释<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software IRQL<br>PASSIVE_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passive release level<br>LOW_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lowest interrupt level<br>APC_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APC interrupt level<br>DISPATCH_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispatcher level<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hardware IRQL<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from 3 to 26 for device ISR<br>PROFILE_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer used for profiling<br>CLOCK1_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intervalclock 1 level - Not used on x86<br>CLOCK2_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interval clock 2 level<br>SYNCH_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronizationlevel<br>IPI_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interprocessor interrupt level<br>POWER_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Powerfailure level<br>HIGH_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Highest interrupt level<span style="color:#333333;"   >
</span></span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   >Windows的自旋锁有一系列函数组成，实现在不同场景下的自旋锁机制。
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><strong>本系列文章主要涉及的体系结构是X86（32位）体系结构。如不特殊注明，都是在X86（32位）体系结构下。</strong>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   >下面分析KeAcquireSpinLock 的实现机制
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   ><strong>2 KeAcquireSpinLock 的实现机制</strong></span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >KeAcquireSpinLock 在单核处理器和多核处理器上的实现是不一样的。</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   ><strong>在单核处理器（WindowsXP）下</strong><br>hal!KfAcquireSpinLock:<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;edx,dword ptr ds:[0FFFE0080h]<br>&nbsp;&nbsp;&nbsp;&nbsp;movdword ptr ds:[0FFFE0080h],41h<br>&nbsp;&nbsp;&nbsp;&nbsp;shr&nbsp;&nbsp;&nbsp;&nbsp;edx,4<br>&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;eax,byte ptr hal!HalpVectorToIRQL [edx]<br>&nbsp;&nbsp;&nbsp;&nbsp;ret<br>观察KeGetCurrentIrql的实现<br>hal!KeGetCurrentIrql:<br>&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;eax,dword ptr ds:[FFFE0080h]<br>&nbsp;&nbsp;&nbsp;&nbsp;shr&nbsp;&nbsp;&nbsp;&nbsp;eax,4<br>&nbsp;&nbsp;&nbsp;&nbsp;movzx&nbsp;&nbsp;eax,byte ptr hal!HalpVectorToIRQL [eax]<br>&nbsp;&nbsp;&nbsp;&nbsp;ret<br>有充足的理由说明ds:[FFFE0080h]地址处存放的是IRQL相关的数据。<br>KfAcquireSpinLock就是改变当前的IRQL，KfAcquireSpinLock将IRQL改到一个什么值了呢？<br>db hal!HalpVectorToIRQL：<br>00&nbsp;&nbsp;ff&nbsp;&nbsp;ff 01 02ff&nbsp;&nbsp;05 06 07 08 09 0a 1b 1c 1d 1e<br>00&nbsp;&nbsp;00&nbsp;&nbsp;00 00 0000&nbsp;&nbsp;00 00 2a 00 00 00 c4 00 00 00<br>如果先调用KfAcquireSpinLock那么ds:[0FFFE0080h]的值是0x41,再调用KeGetCurrentIrql，由以上表得到返回值是(BYTE*)HalpVectorToIRQL[4]是2。单核处理器下，KfAcquireSpinLock的工作就是将IRQL升为DISPATCH_LEVEL。KfReleaseSpinLock就是将IRQL还原为原来的值了。</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   ><strong>在多核处理器（Windows2003）下</strong></span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >KeAcquireSpinLock&nbsp;通过调用KfAcquireSpinLock来实现功能<br>hal!KfAcquireSpinLock:<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;eax,dword ptr fs:[00000024h]<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;byte ptr fs:[24h],2<br>&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;hal!KeAcquireSpinLockRaiseToSynch+0xe<br>hal!KeAcquireSpinLockRaiseToSynch:<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;eax,dword ptr fs:[00000024h]<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;byte ptr fs:[24h],1Bh<br>hal!KeAcquireSpinLockRaiseToSynch+0xe<br>&nbsp;&nbsp;&nbsp;lock bts dword ptr[ecx],0<br>&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hal!KeAcquireSpinLockRaiseToSynch+0x16<br>&nbsp;&nbsp;&nbsp;ret<br>hal!KeAcquireSpinLockRaiseToSynch+0x16<br>&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;dwordptr [ecx],1<br>&nbsp;&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hal!KeAcquireSpinLockRaiseToSynch+0xe<br>&nbsp;&nbsp;&nbsp;pause<br>&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;hal!KeAcquireSpinLockRaiseToSynch+0x16<br>KfAcquireSpinLock是不会执行到KeAcquireSpinLockRaiseToSynch的头两行代码的。</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >fs:[00000024h] 保存的是当前线程的IRQL，可以通过函数来证实。<br>hal!KeGetCurrentIrql：<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;al,byte ptr fs:[00000024h]<br>&nbsp;&nbsp;&nbsp;&nbsp;ret<br>将KfAcquireSpinLock翻译成伪代码：<br>KfAcquireSpinLock(SpinLock){<br>&nbsp;&nbsp;&nbsp;KeRaiseIrql(DISPATCH_LEVEL,OldIrql);&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;While(TRUE){<br>&nbsp;&nbsp;&nbsp;&nbsp;//独占处理器和相关存储空间执行下面代码</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//由Lock指令实现<br>&nbsp;&nbsp;&nbsp;&nbsp;lastbit=SpinLock.lastbit;<br>&nbsp;&nbsp;&nbsp;&nbsp;SpinLock.lastbit=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;//释放独占<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(SpinLock.lastbit ==1) ;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;else break;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;ReturnOldIrql;&nbsp;<br>}<br>对KfAcquireSpinLock的解释就比较容易了，首先提升IRQL到DISPATCH_LEVEL，然后一直等到SpinLock被别人释放，设置SpinLock的值为占有然后退出。</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >在Windows2003多核处理器下KeReleaseSpinLock通过调用KfReleaseSpinLock来实现功能<br>hal!KfReleaseSpinLock:<br>&nbsp;&nbsp;&nbsp;&nbsp;lock andbyte ptr [ecx],0<br>&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;cl,dl<br>&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;hal!KfLowerIrql<br>&nbsp;&nbsp;&nbsp;&nbsp;ret<br>释放SpinLock，将IRQL还原。</span>
</span></p><p style="background: white;"   >&nbsp;
&nbsp;</p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   ><strong>分析：</strong></span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >显而易见，在单核环境里实现DISPATCH_LEVEL及其以下IRQL的同步，将当前线程升级到DISPATCH_LEVEL足够了。但是在多核环境下，每一个核都有自己的IRQL，提升IRQL来实现同步是不行的，在多核的情况下，Windows系统引入了lock指令来实现同步。</span>
</span></p><p style="background: white;"   >&nbsp;
&nbsp;</p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >现在DDK(3790)中是这么定义的</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >#if defined(_X86_)</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >#define KeAcquireSpinLock(a,b)&nbsp;&nbsp;*(b) =KfAcquireSpinLock(a)<br>#define KeReleaseSpinLock(a,b)&nbsp;KfReleaseSpinLock(a,b)</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >#else</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >//<br>// These functions are imported for IA64, ntddk, ntifs, nthal,ntosp, and wdm.<br>// They can be inlined for the system on AMD64.<br>//</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><span style="font-size:9pt;"   >#define KeAcquireSpinLock(SpinLock, OldIrql) \<br>&nbsp;&nbsp;&nbsp;&nbsp;*(OldIrql) =KeAcquireSpinLockRaiseToDpc(SpinLock)</span>
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><strong>3 KeAcquireSpinLockAtDpcLevel的实现机制</strong><br>MSDN上说明调用KeAcquireSpinLockAtDpcLevel的程序必须运行在DISPATCH_LEVEL上。
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><br><strong>在多核处理器（Windows2003）下</strong><br>先来查看一下KeAcquireSpinLockAtDpcLevel的汇编代码<br>nt!KeAcquireSpinLockAtDpcLevel:<br>&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;ecx,dword ptr [esp+4]<br>nt!KeAcquireSpinLockAtDpcLevel+0x4<br>&nbsp;&nbsp;&nbsp;lock bts dword ptr[ecx],0<br>&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!KeAcquireSpinLockAtDpcLevel+0xe<br>&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;4<br>nt!KeAcquireSpinLockAtDpcLevel+0xe：<br>&nbsp;&nbsp;test&nbsp;&nbsp;&nbsp;&nbsp;dwordptr [ecx],1<br>&nbsp;&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nt!KeAcquireSpinLockAtDpcLevel+0x4<br>&nbsp;&nbsp;&nbsp;pause<br>&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;nt!KeAcquireSpinLockAtDpcLevel+0xe<br>将KeAcquireSpinLockAtDpcLevel翻译成伪代码：<br>KeAcquireSpinLockAtDpcLevel (SpinLock){<br>&nbsp;&nbsp;&nbsp;&nbsp;while(TRUE) {<br>&nbsp;&nbsp;&nbsp;&nbsp;//独占处理器和相关存储空间执行下面代码<br>&nbsp;&nbsp;&nbsp;&nbsp;lastbit=SpinLock.lastbit;<br>&nbsp;&nbsp;&nbsp;&nbsp;SpinLock.lastbit=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;//释放独占<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(SpinLock.lastbit ==1) ;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elsebreak;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>对比一下KfAcquireSpinLock，KeAcquireSpinLockAtDpcLevel除了不提升IRQL到DISPATCH_LEVEL，其他都是一样的，KeAcquireSpinLockAtDpcLevel的运行环境已经在DISPATCH_LEVEL上了，确实也不要提升。
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><br>KefReleaseSpinLockFromDpcLevel的实现<br>nt!KefReleaseSpinLockFromDpcLevel:<br>&nbsp;&nbsp;&nbsp;lock and byte ptr [ecx],0
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   >&nbsp;&nbsp;&nbsp;ret<br>KefReleaseSpinLockFromDpcLevel就是简单实用lock指令把Spinlock的值置成0释放。
</span></p><p style="background: white;"   >&nbsp;
&nbsp;</p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><strong>在单核处理器（WindowsXP）下</strong><br>在单核处理器下KfAcquireSpinLock所作的工作就是简单提升一下IRQL到DISPATCH_LEVEL，那么KeAcquireSpinLockAtDpcLevel已经在DISPATCH_LEVEL，还需要做什么工作呢？是不是什么工作都不需要做了？<br>实际上观察KeAcquireSpinLockAtDpcLevel在单核处理器下的实现，发现确实什么也没做，直接返回了。<br>KefReleaseSpinLockFromDpcLevel也是一样,直接返回了。
</span></p><p style="background: white;"   ><span style="color:#333333; font-family:微软雅黑;"   ><br><strong>分析：<br></strong>关于KeAcquireSpinLockAtDpcLevel在MSDN上有这样一段文字：<br><em>当IRQL=DISPATCH_LEVEL时，驱动调用KeAcquireSpinLockAtDpcLevel比调用KeAcquireSpinLock有更好的性能。当IRQL&lt;DISPATCH_LEVEL时,驱动必须调用KeAcquireSpinLock。</em><br>其实观察具体实现，KeAcquireSpinLockAtDpcLevel"更好的性能"体现在多核状态下少运行了两条MOV指令，单核状态下少运行了三条MOV指令和一条SHR指令，不得不感叹下Windows的惜指令如金。
</span></p>
</body></html>