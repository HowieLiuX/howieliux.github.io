<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] RSA 基础 实践</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] RSA 基础 实践</h2>
<p align="right">发布时间：2010-3-4 13:47
<br>分类名称：PKI</p><br>
<br>讲讲自己学习RSA中的实践过程，已经对RSA熟悉的看家就不用在此浪费时间了。 <br> <br>&lt;一&gt;基础 <br> <br>RSA算法非常简单，概述如下： <br>找两素数p和q <br>取n=p*q <br>取t=(p-1)*(q-1) <br>取任何一个数e,要求满足e&lt;t并且e与t互素（就是最大公因数为1） <br>取d*e%t==1 <br> <br>这样最终得到三个数： n&nbsp; d&nbsp; e <br> <br>设消息为数M (M &lt;n) <br>设c=(M**d)%n就得到了加密后的消息c <br>设m=(c**e)%n则 m == M，从而完成对c的解密。 <br>注：**表示次方,上面两式中的d和e可以互换。 <br> <br>在对称加密中： <br>n d两个数构成公钥，可以告诉别人； <br>n e两个数构成私钥，e自己保留，不让任何人知道。 <br>给别人发送的信息使用e加密，只要别人能用d解开就证明信息是由你发送的，构成了签名机制。 <br>别人给你发送信息时使用d加密，这样只有拥有e的你能够对其解密。 <br> <br>rsa的安全性在于对于一个大数n，没有有效的方法能够将其分解 <br>从而在已知n d的情况下无法获得e；同样在已知n e的情况下无法 <br>求得d。 <br> <br> <br> <br>&lt;二&gt;实践 <br> <br>接下来我们来一个实践，看看实际的操作： <br>找两个素数： <br>p=47 <br>q=59 <br>这样 <br>n=p*q=2773 <br>t=(p-1)*(q-1)=2668 <br>取e=63，满足e&lt;t并且e和t互素 <br>用perl简单穷举可以获得满主 e*d%t ==1的数d： <br>C:\Temp&gt;perl -e "foreach $i (1..9999){ print($i),last if  $i*63%2668==1 }" <br>847 <br>即d＝847 <br> <br>最终我们获得关键的 <br>n=2773 <br>d=847 <br>e=63 <br> <br>取消息M=244我们看看 <br> <br>加密： <br> <br>c=M**d%n = 244**847%2773 <br>用perl的大数计算来算一下： <br>C:\Temp&gt;perl -Mbigint -e "print 244**847%2773" <br>465 <br>即用d对M加密后获得加密信息c＝465 <br> <br>解密： <br> <br>我们可以用e来对加密后的c进行解密，还原M： <br>m=c**e%n=465**63%2773 ： <br>C:\Temp&gt;perl -Mbigint -e "print 465**63%2773" <br>244 <br>即用e对c解密后获得m=244 , 该值和原始信息M相等。 <br> <br> <br>&lt;三&gt;字符串加密 <br> <br>把上面的过程集成一下我们就能实现一个对字符串加密解密的示例了。 <br>每次取字符串中的一个字符的ascii值作为M进行计算，其输出为加密后16进制 <br>的数的字符串形式，按3字节表示，如01F <br> <br>代码如下： <br> <br>#!/usr/bin/perl -w <br>#RSA 计算过程学习程序编写的测试程序 <br>#watercloud 2003-8-12 <br># <br>use strict; <br>use Math::BigInt; <br> <br>my %RSA_CORE = (n=&gt;2773,e=&gt;63,d=&gt;847); #p=47,q=59 <br> <br>my $N=new Math::BigInt($RSA_CORE{n}); <br>my $E=new Math::BigInt($RSA_CORE{e}); <br>my $D=new Math::BigInt($RSA_CORE{d}); <br> <br>print "N=$N&nbsp; D=$D&nbsp; E=$E\n"; <br> <br>sub RSA_ENCRYPT <br>{ <br>&nbsp;&nbsp;&nbsp; my $r_mess = shift @_; <br>&nbsp;&nbsp;&nbsp; my ($c,$i,$M,$C,$cmess); <br> <br>&nbsp;&nbsp;&nbsp; for($i=0;$i &lt; length($$r_mess);$i++) <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c=ord(substr($$r_mess,$i,1)); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $M=Math::BigInt-&gt;new($c); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $C=$M-&gt;copy(); $C-&gt;bmodpow($D,$N); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c=sprintf "%03X",$C; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $cmess.=$c; <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; return \$cmess; <br>} <br> <br>sub RSA_DECRYPT <br>{ <br>&nbsp;&nbsp;&nbsp; my $r_mess = shift @_; <br>&nbsp;&nbsp;&nbsp; my ($c,$i,$M,$C,$dmess); <br> <br>&nbsp;&nbsp;&nbsp; for($i=0;$i &lt; length($$r_mess);$i+=3) <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c=substr($$r_mess,$i,3); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c=hex($c); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $M=Math::BigInt-&gt;new($c); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $C=$M-&gt;copy(); $C-&gt;bmodpow($E,$N); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $c=chr($C); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $dmess.=$c; <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; return \$dmess; <br>} <br> <br>my $mess="RSA 娃哈哈哈～～～"; <br>$mess=$ARGV[0] if @ARGV &gt;= 1; <br>print "原始串：",$mess,"\n"; <br> <br>my $r_cmess = RSA_ENCRYPT(\$mess); <br>print "加密串：",$$r_cmess,"\n"; <br> <br>my $r_dmess = RSA_DECRYPT($r_cmess); <br>print "解密串：",$$r_dmess,"\n"; <br> <br>#EOF <br> <br>测试一下： <br>C:\Temp&gt;perl rsa-test.pl <br>N=2773&nbsp; D=847&nbsp; E=63 <br>原始串：RSA 娃哈哈哈～～～ <br>加密串：5CB6CD6BC58A7709470AA74A0AA74A0AA74A6C70A46C70A46C70A4 <br>解密串：RSA 娃哈哈哈～～～ <br> <br> <br>C:\Temp&gt;perl rsa-test.pl 安全焦点（xfocus） <br>N=2773&nbsp; D=847&nbsp; E=63 <br>原始串：安全焦点（xfocus） <br>加密串：3393EC12F0A466E0AA9510D025D7BA0712DC3379F47D51C325D67B <br>解密串：安全焦点（xfocus） <br> <br> <br> <br>&lt;四&gt;提高 <br> <br>前面已经提到，rsa的安全来源于n足够大，我们测试中使用的n是非常小的，根本不能保障安全性， <br>我们可以通过RSAKit、RSATool之类的工具获得足够大的N 及D E。 <br>通过工具，我们获得1024位的N及D E来测试一下： <br> <br>n=0x328C74784DF31119C526D18098EBEBB943B0032B599CEE13CC2BCE7B5FCD15F90B66EC3A85F5005D <br>BDCDED9BDFCB3C4C265AF164AD55884D8278F791C7A6BFDAD55EDBC4F017F9CCF1538D4C2013433B383B <br>47D80EC74B51276CA05B5D6346B9EE5AD2D7BE7ABFB36E37108DD60438941D2ED173CCA50E114705D7E2 <br>BC511951 <br> <br>d=0x10001 <br> <br>e=0xE760A3804ACDE1E8E3D7DC0197F9CEF6282EF552E8CEBBB7434B01CB19A9D87A3106DD28C523C2995 <br>4C5D86B36E943080E4919CA8CE08718C3B0930867A98F635EB9EA9200B25906D91B80A47B77324E66AFF2 <br>C4D70D8B1C69C50A9D8B4B7A3C9EE05FFF3A16AFC023731D80634763DA1DCABE9861A4789BD782A592D2B <br>1965 <br> <br> <br>设原始信息 <br>M=0x11111111111122222222222233333333333 <br> <br>完成这么大数字的计算依赖于大数运算库，用perl来运算非常简单： <br> <br>A) 用d对M进行加密如下： <br>c=M**d%n : <br>C:\Temp&gt;perl -Mbigint -e "  $x=Math::BigInt-&gt;bmodpow(0x11111111111122222222222233 <br>333333333, 0x10001,  0x328C74784DF31119C526D18098EBEBB943B0032B599CEE13CC2BCE7B5F <br>CD15F90B66EC3A85F5005DBDCDED9BDFCB3C4C265AF164AD55884D8278F791C7A6BFDAD55EDBC4F0 <br>17F9CCF1538D4C2013433B383B47D80EC74B51276CA05B5D6346B9EE5AD2D7BE7ABFB36E37108DD6 <br>0438941D2ED173CCA50E114705D7E2BC511951);print $x-&gt;as_hex" <br>0x17b287be418c69ecd7c39227ab681ac422fcc84bb35d8a632543b304de288a8d4434b73d2576bd <br>45692b007f3a2f7c5f5aa1d99ef3866af26a8e876712ed1d4cc4b293e26bc0a1dc67e247715caa6b <br>3028f9461a3b1533ec0cb476441465f10d8ad47452a12db0601c5e8beda686dd96d2acd59ea89b91 <br>f1834580c3f6d90898 <br> <br>即用d对M加密后信息为： <br>c=0x17b287be418c69ecd7c39227ab681ac422fcc84bb35d8a632543b304de288a8d4434b73d2576bd <br>45692b007f3a2f7c5f5aa1d99ef3866af26a8e876712ed1d4cc4b293e26bc0a1dc67e247715caa6b <br>3028f9461a3b1533ec0cb476441465f10d8ad47452a12db0601c5e8beda686dd96d2acd59ea89b91 <br>f1834580c3f6d90898 <br> <br> <br> <br>B) 用e对c进行解密如下： <br> <br>m=c**e%n ： <br>C:\Temp&gt;perl -Mbigint -e "  $x=Math::BigInt-&gt;bmodpow(0x17b287be418c69ecd7c39227ab <br>681ac422fcc84bb35d8a632543b304de288a8d4434b73d2576bd45692b007f3a2f7c5f5aa1d99ef3 <br>866af26a8e876712ed1d4cc4b293e26bc0a1dc67e247715caa6b3028f9461a3b1533ec0cb4764414 <br>65f10d8ad47452a12db0601c5e8beda686dd96d2acd59ea89b91f1834580c3f6d90898,&nbsp;  0xE760A <br>3804ACDE1E8E3D7DC0197F9CEF6282EF552E8CEBBB7434B01CB19A9D87A3106DD28C523C29954C5D <br>86B36E943080E4919CA8CE08718C3B0930867A98F635EB9EA9200B25906D91B80A47B77324E66AFF <br>2C4D70D8B1C69C50A9D8B4B7A3C9EE05FFF3A16AFC023731D80634763DA1DCABE9861A4789BD782A <br>592D2B1965,&nbsp;  0x328C74784DF31119C526D18098EBEBB943B0032B599CEE13CC2BCE7B5FCD15F90 <br>B66EC3A85F5005DBDCDED9BDFCB3C4C265AF164AD55884D8278F791C7A6BFDAD55EDBC4F017F9CCF <br>1538D4C2013433B383B47D80EC74B51276CA05B5D6346B9EE5AD2D7BE7ABFB36E37108DD60438941 <br>D2ED173CCA50E114705D7E2BC511951);print $x-&gt;as_hex" <br>0x11111111111122222222222233333333333 <br>(我的P4 1.6G的机器上计算了约5秒钟） <br> <br>得到用e解密后的m=0x11111111111122222222222233333333333&nbsp; == M <br> <br> <br>C) RSA通常的实现 <br>RSA简洁幽雅，但计算速度比较慢，通常加密中并不是直接使用RSA 来对所有的信息进行加密， <br>最常见的情况是随机产生一个对称加密的密钥，然后使用对称加密算法对信息加密，之后用 <br>RSA对刚才的加密密钥进行加密。 <br> <br> <br>最后需要说明的是，当前小于1024位的N已经被证明是不安全的 <br>自己使用中不要使用小于1024位的RSA，最好使用2048位的。<br><br><br><br><font size="5"  ><span style="font-weight: bold;"  >OpenSSL RSA 实现：</span></font><br style="font-weight: bold;"  ><style> < -- font-face font-family panose- mso-font-altsimsun mso-font-charset mso-generic-font-familyauto mso-font-pitchvariable mso-font-signature font-face font-familycambria math panose- mso-font-charset mso-generic-font-familyroman mso-font-pitchvariable mso-font-signature- font-face font-family panose- mso-font-charset mso-generic-font-familyauto mso-font-pitchvariable mso-font-signature pmsonormal limsonormal divmsonormal mso-style-unhideno mso-style-qformatyes mso-style-parent margincm margin-bottompt text-alignjustify text-justifyinter-ideograph mso-paginationnone font-sizept mso-bidi-font-sizept font-familytimes new romanserif mso-fareast-font-family mso-font-kerningpt h mso-style-unhideno mso-style-qformatyes mso-style-link char mso-style-next margin-toppt margin-rightcm margin-bottompt margin-leftcm text-alignjustify text-justifyinter-ideograph line-height mso-paginationlines-together page-break-afteravoid mso-outline-level font-sizept font-familytimes new romanserif mso-font-kerningpt spanchar mso-style-name char mso-style-unhideno mso-style-lockedyes mso-style-link mso-ansi-font-sizept mso-bidi-font-sizept mso-font-kerningpt font-weightbold p li div mso-style-name mso-style-unhideno margincm margin-bottompt text-alignjustify text-justifyinter-ideograph line-height mso-paginationnone font-sizept font-familytimes new romanserif mso-fareast-font-family mso-font-kerningpt msochpdefault mso-style-typeexport-onwbr>ly; mso-default-props:yes; font-size:10.0pt; mso-ansi-font-size:10.0pt; mso-bidi-font-size:10.0pt; mso-ascii-font-family:"times new roman"; mso-fareast-font-family:宋体; mso-hansi-font-family:"times new roman"; mso-font-kerning:0pt;} @page {mso-page-border-surround-header:no; mso-page-border-surround-footer:no;} @page section1 {size:612.0pt 792.0pt; margin:72.0pt 90.0pt 72.0pt 90.0pt; mso-header-margin:36.0pt; mso-footer-margin:36.0pt; mso-paper-source:0;} div.section1 {page:section1;} --&lt; --&lt;--&lt;--&lt;--&lt;--&lt;</style>  <p><span style="font-family: 宋体;"  >主要介绍了</span><span lang="EN-US"  >openssl</span><span style="font-family: 宋体;"  >之</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >相关函数，这个对学习和实现</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >算法比较有帮助。</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >1</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >RSA</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >基本结构</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >struct&nbsp; {</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >int pad;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >long version;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *meth;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >ENGINE *engine;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *n; &nbsp; &nbsp; &nbsp; n=p*q</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *e; &nbsp; &nbsp; &nbsp; </span><span style="font-family: 宋体;"  >公开的加密指数，经常为</span><span lang="EN-US"  >65537</span><span style="font-family: 宋体;"  >（</span><span lang="EN-US"  >ox10001</span><span style="font-family: 宋体;"  >）</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *d; &nbsp; &nbsp; &nbsp; </span><span style="font-family: 宋体;"  >私钥</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *p; &nbsp; &nbsp; &nbsp; </span><span style="font-family: 宋体;"  >大素数</span><span lang="EN-US"  >p</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *q; &nbsp; &nbsp; &nbsp; </span><span style="font-family: 宋体;"  >大素数</span><span lang="EN-US"  >q</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *dmp1; &nbsp; &nbsp; d mod (p-1)</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *dmq1; &nbsp; &nbsp; d mod (q-1)</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BIGNUM *iqmp; &nbsp; &nbsp; (inverse of q) mod p</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >int references;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >int flags;</span></p>  <p style="text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >// ...</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >}RSA</span><span style="font-family: 宋体;"  >；</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >2</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．初始化函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >RSA * RSA_new(void);</span><span style="font-family: 宋体;"  >初始化一个</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >结构</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >void RSA_free(RSA *rsa);</span><span style="font-family: 宋体;"  >释放一个</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >结构</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >3</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >RSA</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >私钥产生函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >RSA *RSA_generate_key(int num, unsigned long e,void (*callback)(int,int,void *), void *cb_arg);</span><span style="font-family: 宋体;"  >产生一个模为</span><span lang="EN-US"  >num</span><span style="font-family: 宋体;"  >位的密钥对，</span><span lang="EN-US"  >e</span><span style="font-family: 宋体;"  >为公开的加密指数，一般为</span><span lang="EN-US"  >65537</span><span style="font-family: 宋体;"  >（</span><span lang="EN-US"  >ox10001</span><span style="font-family: 宋体;"  >），假如后两个参数不为</span><span lang="EN-US"  >NULL</span><span style="font-family: 宋体;"  >，将有些调用。在产生密钥对之前，一般需要指定随机数种子</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >4</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．判断位数函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_size(const RSA *rsa);</span><span style="font-family: 宋体;"  >返回</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >模的位数，他用来判断需要给加密值分配空间的大小</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_check_key(RSA *rsa);</span><span style="font-family: 宋体;"  >他测试</span><span lang="EN-US"  >p,q</span><span style="font-family: 宋体;"  >是否为素数，</span><span lang="EN-US"  >n=p*q,d*e = 1 mod (p-1*q-1), dmp1, dmq1, iqmp</span><span style="font-family: 宋体;"  >是否均设置正确了。</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >5</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >RSA</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >的</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >RSA_METHOD</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >了解</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >的运算那就必须了解</span><span lang="EN-US"  >RSA_METHOD</span><span style="font-family: 宋体;"  >，下面我们先看看</span><span lang="EN-US"  >RSA_METHOD</span><span style="font-family: 宋体;"  >结构</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >typedef struct rsa_meth_st{</span></p>  <p style="text-indent: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >const char *name;</span></p>  <p style="text-indent: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_pub_enc)(int flen,const unsigned char *from,</span></p>  <p style="margin-left: 42pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to,RSA *rsa,int padding);</span></p>  <p style="text-indent: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_pub_dec)(int flen,const unsigned char *from,</span></p>  <p style="margin-left: 63pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to,RSA *rsa,int padding);</span></p>  <p style="text-indent: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_priv_enc)(int flen,const unsigned char *from,</span></p>  <p style="margin-left: 42pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to, RSA *rsa,int padding);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_priv_dec)(int flen,const unsigned char *from,</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=""  >&nbsp; </span>unsigned char *to,RSA *rsa,int padding);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int(*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa); &nbsp; &nbsp; </span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  ><span style=""  >&nbsp;</span>&nbsp; &nbsp; &nbsp; &nbsp; const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*init)(RSA *rsa); &nbsp; &nbsp; &nbsp; /* called at new */</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*finish)(RSA *rsa); &nbsp; &nbsp; /* called at free */</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int flags; &nbsp; &nbsp; &nbsp; &nbsp; /* RSA_METHOD_FLAG_* things */</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >char *app_da<wbr>ta; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* may be needed! */</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_sign)(int type,const unsigned char *m, unsigned int m_length,unsigned char *sigret, unsigned int *siglen, const RSA *rsa);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >int (*rsa_verify)(int dtype,const unsigned char *m, unsigned int m_length,unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >} RSA_METHOD;</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *RSA_PKCS1_SSLeay(void);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *RSA_null_method(void);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span style="font-family: 宋体;"  >主要有上面两个函数。第二个函数是定义了</span><span lang="EN-US"  >RSA_null</span><span style="font-family: 宋体;"  >才会调用，其实要调用这个函数以后几乎什么都不能干，只是输出错误信息。第一个是常用的</span><span lang="EN-US"  >METHOD</span><span style="font-family: 宋体;"  >，下面我们看看它的定义</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *RSA_PKCS1_SSLeay(void)&nbsp; &nbsp; {</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >return(&amp;rsa_pkcs1_eay_meth);</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >}</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >static RSA_METHOD rsa_pkcs1_eay_meth={</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >"Eric Young's PKCS#1 RSA",</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_public_encrypt,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_public_decrypt, /* signature verification */</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_private_encrypt, /* signing */</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_private_decrypt,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_mod_exp,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >BN_mod_exp_mont,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_init,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >RSA_eay_finish,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >0, /* flags */</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >NULL,</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >0, /* rsa_sign */</span></p>  <p style="margin-left: 15.75pt; text-indent: 16.5pt; line-height: 150%;"  ><span lang="EN-US"  >0 /* rsa_verify */</span></p>  <p style="margin-left: 15.75pt; line-height: 150%;"  ><span lang="EN-US"  >};</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >由此可以看出，一般</span><span lang="EN-US"  >rsa-&gt;meth-&gt; rsa_pub_enc</span><span style="font-family: 宋体;"  >对应于</span><span lang="EN-US"  >RSA_eay_public_encrypt</span><span style="font-family: 宋体;"  >，刚开始看</span><span lang="EN-US"  >openssl</span><span style="font-family: 宋体;"  >的时候最难得就是这个指向函数的指针，根本不知道</span><span lang="EN-US"  >rsa-&gt;meth-&gt; rsa_pub_enc</span><span style="font-family: 宋体;"  >对应于哪里。在</span><span lang="EN-US"  >openssl</span><span style="font-family: 宋体;"  >里面这种指针很多，到以后也能够看到。下面是设置</span><span lang="EN-US"  >meth</span><span style="font-family: 宋体;"  >的一些函数应该都很容易理解</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >void RSA_set_default_method(const RSA_METHOD *meth);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *RSA_get_default_method(void);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >const RSA_METHOD *RSA_get_method(const RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_flags(const RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >RSA *RSA_new_method(ENGINE *engine);</span></p>  <p style="margin-left: 15.75pt;"  ><span lang="EN-US"  >&nbsp;</span></p>  <p style="line-height: 150%;"  ><span><span style="font-size: 14pt; line-height: 150%;"  lang="EN-US"  >6</span></span><span><span style="font-size: 14pt; line-height: 150%; font-family: 宋体;"  >．加解密函数</span></span><span lang="EN-US"  ><br> int RSA_public_encrypt(int flen, unsigned char *from,</span></p>  <p style="margin-left: 78.75pt; text-indent: 5.25pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to, RSA *rsa, int padding);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_private_decrypt(int flen, unsigned char *from,</span></p>  <p style="margin-left: 63pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to, RSA *rsa, int padding);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_private_encrypt(int flen, unsigned char *from,</span></p>  <p style="margin-left: 63pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to, RSA *rsa,int padding);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_public_decrypt(int flen, unsigned char *from,</span></p>  <p style="margin-left: 63pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *to, RSA *rsa,int padding);</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >有了第</span><span lang="EN-US"  >4</span><span style="font-family: 宋体;"  >节的基础，那理解这些加解密函数就容易了，假如</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >RSA_set_method(rsa, RSA_PKCS1_SSLeay())</span><span style="font-family: 宋体;"  >的话，那</span><span lang="EN-US"  >RSA_public_encrypt</span><span style="font-family: 宋体;"  >对应于</span><span lang="EN-US"  >RSA_eay_public_encrypt</span><span style="font-family: 宋体;"  >，这样我们就可以调试公钥加密的过程了。</span><span lang="EN-US"  >Flen</span><span style="font-family: 宋体;"  >为要加密信息的长度，</span><span lang="EN-US"  >from</span><span style="font-family: 宋体;"  >为需要加密的信息，</span><span lang="EN-US"  >to</span><span style="font-family: 宋体;"  >为加密后的信息，一般</span><span lang="EN-US"  >to</span><span style="font-family: 宋体;"  >至少要申请</span><span lang="EN-US"  >BN_num_bytes(rsa-&gt;n)</span><span style="font-family: 宋体;"  >大的空间。</span><span lang="EN-US"  >Padding</span><span style="font-family: 宋体;"  >是采取的加解密方案。</span><span lang="EN-US"  >PKCS#1</span><span style="font-family: 宋体;"  >中主要提供了两种加密方案，</span><span lang="EN-US"  >RSAEX-OAEP</span><span style="font-family: 宋体;"  >和</span><span lang="EN-US"  >PSAES-PKCS1-v1_5</span><span style="font-family: 宋体;"  >（反正就是两种加密过程了，有点复杂，它主要是先对先对需要加密的数据进行了编码，比如</span><span lang="EN-US"  >RSAES-OAEP</span><span style="font-family: 宋体;"  >采用</span><span lang="EN-US"  >EME-OAEP</span><span style="font-family: 宋体;"  >编码，再进行加密或解密）。</span><span lang="EN-US"  >Openssl</span><span style="font-family: 宋体;"  >中已经编好了编码的函数：</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >case RSA_PKCS1_PADDING:</span></p>  <p style="text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);</span></p>  <p style="text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >#ifndef OPENSSL_NO_SHA</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >Case RSA_PKCS1_OAEP_PADDING: &nbsp; &nbsp; </span></p>  <p style="margin-left: 21pt; line-height: 150%;"  ><span lang="EN-US"  >i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);</span></p>  <p style="margin-left: 21pt; line-height: 150%;"  ><span lang="EN-US"  >#endif</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >case RSA_SSLV23_PADDING:</span></p>  <p style="text-indent: 10.5pt; line-height: 150%;"  ><span lang="EN-US"  >&nbsp; i=RSA_padding_add_SSLv23(buf,num,from,flen);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >case RSA_NO_PADDING:</span></p>  <p style="text-indent: 10.5pt; line-height: 150%;"  ><span lang="EN-US"  >&nbsp; i=RSA_padding_add_none(buf,num,from,flen);</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >等上面编好码后，就调用</span><span lang="EN-US"  >BN_mod_exp_mont</span><span style="font-family: 宋体;"  >来进行模幂了。最后得出值，这也就是具体的加密和解密过程。在这里还可以发现，加密时输入的</span><span lang="EN-US"  >rsa</span><span style="font-family: 宋体;"  >有两种方式，一是</span><span lang="EN-US"  >p,q,...</span><span style="font-family: 宋体;"  >为</span><span lang="EN-US"  >NULL,</span><span style="font-family: 宋体;"  >只有</span><span lang="EN-US"  >rsa-&gt;d,</span><span style="font-family: 宋体;"  >和</span><span lang="EN-US"  >rsa-&gt;n</span><span style="font-family: 宋体;"  >不为空，这样就直接用</span><span lang="EN-US"  >rsa-&gt;d</span><span style="font-family: 宋体;"  >和</span><span lang="EN-US"  >rsa-&gt;n</span><span style="font-family: 宋体;"  >进行模幂计算，假如</span><span lang="EN-US"  >p,q.....</span><span style="font-family: 宋体;"  >都不为空的话，他会调用中国剩余定理来进行加密。</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >7</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．签名函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_sign(int type, unsigned char *m, unsigned int m_len,</span></p>  <p style="margin-left: 21pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *sigret, unsigned int *siglen, RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_verify(int type, unsigned char *m, unsigned int m_len,</span></p>  <p style="margin-left: 21pt; text-indent: 21pt; line-height: 150%;"  ><span lang="EN-US"  >unsigned char *sigbuf, unsigned int siglen, RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >其实签名其实和用私钥加密差不多是一回事，所以签名函数最终调用的就是私钥加密的函数，在</span><span lang="EN-US"  >openssl</span><span style="font-family: 宋体;"  >中这个签名函数很少单独拿出来用的，都是为了给</span><span lang="EN-US"  >EVP_SignFinal</span><span style="font-family: 宋体;"  >来调用的。所以假如是利用</span><span lang="EN-US"  >RSA</span><span style="font-family: 宋体;"  >进行签名的话，</span><span lang="EN-US"  >RSA_private_encrypt</span><span style="font-family: 宋体;"  >，</span><span lang="EN-US"  >BN_mod_exp_mont</span><span style="font-family: 宋体;"  >是最基本的，所有的都需要调用他，区别无非就在于在需要签名的信息上做了一下处理（一般将需要签名的信息求取摘要值得到</span><span lang="EN-US"  >m</span><span style="font-family: 宋体;"  >）</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >8</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．写入文件函数</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_print(BIO *bp, RSA *x, int offset);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_print_fp(FILE *fp, RSA *x, int offset);offset</span><span style="font-family: 宋体;"  >是为了调整输出格式的，随意一个数都可以（例如</span><span lang="EN-US"  >2</span><span style="font-family: 宋体;"  >，</span><span lang="EN-US"  >12</span><span style="font-family: 宋体;"  >，</span><span lang="EN-US"  >16</span><span style="font-family: 宋体;"  >。。）</span></p>  <h1><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  >9</span><span style="font-size: 14pt; line-height: 240%; font-family: 宋体;"  >．其他</span><span style="font-size: 14pt; line-height: 240%;"  lang="EN-US"  ></span></h1>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >void RSA_blinding_off(RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >为了防止时间攻击，</span><span lang="EN-US"  >openssl</span><span style="font-family: 宋体;"  >还在签名的时候产生一个随机因子，附加在私钥上。</span></p>  <p><span lang="EN-US"  >int RSA_sign_ASN1_OCTET_STRING(int dummy, unsigned char *m,unsigned int m_len, unsigned char *sigret, unsigned int *siglen,RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span lang="EN-US"  >int RSA_verify_ASN1_OCTET_STRING(int dummy, unsigned char *m,unsigned int m_len, unsigned char *sigbuf, unsigned int siglen</span><span style="font-family: 宋体;"  >，</span><span lang="EN-US"  >RSA *rsa);</span></p>  <p style="line-height: 150%;"  ><span style="font-family: 宋体;"  >用私钥对八元组串进行签名，原理同</span><span lang="EN-US"  >RSA_sign</span></p>
</body></html>