<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] 城里城外看SSDT</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] 城里城外看SSDT</h2>
<p align="right">发布时间：2014-2-18 11:59
<br>分类名称：Debug_Crack</p><br>

<P><SPAN style="FONT-SIZE: 9pt; COLOR: black;"   ><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >转自</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;http://www.titilima.cn/readarticle.php?id=78&nbsp;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >2007</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >年</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >7</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >月</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >5</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >日作于京师海淀</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >2006</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >Rootkit……</SPAN><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >在这篇文章里，李马首度从</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（应用层）的围城跨出，一跃而投身于</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（内核层）这一更广阔的天地，为你展现</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（系统服务描述符表）的奥秘。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >点这里下载本文的配套代码</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >引子</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >2006</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >年，中国互联网上的斗争硝烟弥漫。这时的战场上，先前颇为流行的窗口挂钩、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >挂钩、进程注入等技术已然成为昨日黄花，大有逐渐淡出之势；取而代之的，则是更狠毒、更为赤裸裸的词汇：驱动、隐藏进程、</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >Rootkit……</SPAN><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >前不久，我不经意翻出自己</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2005</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >年</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >9</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >月写下的一篇文章《</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DLL</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的远程注入技术》，在下面看到了一位名叫</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >L4bm0s</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的网友说这种技术已经过时了。虽然我也曾想过拟出若干辩解之词聊作应对，不过最终还是作罢了毕竟，拿出些新的、有技术含量的东西才是王道。于是这一次，李马首度从</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（应用层）的围城跨出，一跃而投身于</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（内核层）这一更广阔的天地，便有了这篇《城里城外看</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >》。顾名思义，城里和城外的这一墙之隔，就是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >与</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的分界。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >在这篇文章里，我会用到太多杂七杂八的东西，比如汇编，比如内核调试器，比如</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。这诚然是一件令我瞻前顾后畏首畏尾的事情一方面在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >我不得不依靠这些东西，另一方面我实在担心它们会导致我这篇文章的阅读门槛过高。所以，我决定尽可能少地涉及驱动、内核与</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，也不会对诸如如何使用内核调试器等问题作任何讲解你只需要知道我大概在做些什么，这就足够了。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >什么是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >？</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >什么是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >？自然，这个是我必须回答的问题。不过在此之前，请你打开命令行（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >cmd.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >）窗口，并输入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"dir"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >并回车好了，列出了当前目录下的所有文件和子目录。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >那么，以程序员的视角来看，整个过程应该是这样的：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >由用户输入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >dir</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >命令。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >cmd.exe</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >获取用户输入的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >dir</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >命令，在内部调用对应的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Win32&nbsp;API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >函数</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >FindFirstFile</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >FindNextFile</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >和</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >FindClose</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，获取当前目录下的文件和子目录。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >cmd.exe</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >将文件名和子目录输出至控制台窗口，也就是返回给用户。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到此为止我们可以看到，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >cmd.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >扮演了一个非常至关重要的角色，也就是用户与</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Win32&nbsp;API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的交互。你大概已经可以猜到，我下面要说到的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >亦必将扮演这个角色，这实在是一点新意都没有。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >没错，你猜对了。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的全称是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >System&nbsp;Services&nbsp;Descriptor&nbsp;Table</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，系统服务描述符表。这个表就是一个把</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Win32&nbsp;API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >和</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的内核</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >联系起来的角色，下面我将以</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >API</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >函数</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >OpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >为例说明这个联系的过程。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >你可以用任何反汇编工具来打开你的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >kernel32.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，然后你会发现在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >OpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中有类似这样的汇编代码：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >call&nbsp;ds:NtOpenProcess&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >这就是说，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >OpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >调用了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >函数。那么继续反汇编之，你会发现</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的这个函数很短：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >mov&nbsp;eax,&nbsp;7Ah</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >mov&nbsp;edx,&nbsp;7FFE0300h</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >call&nbsp;dword&nbsp;ptr&nbsp;[edx]</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >retn&nbsp;10h&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >另外，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >call</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的一句实质是调用了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >KiFastSystemCall</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >mov&nbsp;edx,&nbsp;esp</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >sysenter&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >上面是我的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP&nbsp;Professional&nbsp;sp2</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的反汇编结果，如果你用的是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2000</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >系统，那么可能是这个样子：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >mov&nbsp;eax,&nbsp;6Ah</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >lea&nbsp;edx,&nbsp;[esp+4]</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >int&nbsp;2Eh</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >retn&nbsp;10h&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >虽然它们存在着些许不同，但都可以这么来概括：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >把一个数放入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >eax</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >0x7A</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2000</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >0x6A</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >），这个数值称作系统的服务号。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >把参数堆栈指针（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >esp+4</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >）放入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >edx</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >sysenter</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >或</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >int&nbsp;2Eh</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;</SPAN><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >好了，你在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >能看到的东西就到此为止了。事实上，在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的这些函数可以称作真正的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >系统服务的存根（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Stub</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >）函数。分隔</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >与</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >城里城外的这一道叹息之墙，也正是由它们打通的。接下来</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >就要出场了，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >come&nbsp;some&nbsp;music</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >站在城墙看城外</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >插一句先，貌似到现在为止我仍然没有讲出来</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >是个什么东西，真正可以算是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >犹抱琵琶半遮面</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >了。书接上文，在你调用</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >sysenter</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >或</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >int&nbsp;2Eh</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >之后，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Windows</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >系统将会捕获你的这个调用，然后进入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >层，并调用内核服务函数</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，这个过程如下图所示。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><IMG title="2014年2月18日 - Howie - Dspace"   alt=""   src="pic/img2.ph.126.net_5NYlUrdw7aUYtV62GznTJw==_852306229580000900.jpg"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >SSDT</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >在这个过程中所扮演的角色是至关重要的。让我们先看一看它的结构，如下图。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><IMG title="2014年2月18日 - Howie - Dspace"   alt=""   src="pic/img0.ph.126.net_N1RsIOf7ptp9JrfVluMCrQ==_827536431629676642.jpg"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >当程序的处理流程进入</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >之后，系统会根据服务号（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >eax</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >）在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >这个系统服务描述符表中查找对应的表项，这个找到的表项就是系统服务函数</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的真正地址。之后，系统会根据这个地址调用相应的系统服务函数，并把结果返回给</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。图中的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"SSDT"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >所示即为系统服务描述符表的各个表项；右侧的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"ntoskrnl.exe"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >则为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Windows</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >系统内核服务进程（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >即为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NT&nbsp;OS&nbsp;KerneL</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的缩写），它提供了相对应的各个系统服务函数。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >这个文件位于</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Windows</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >system32</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >目录下，有兴趣的朋友可以反汇编一下。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >附带说两点。根据你处理器的不同，系统内核服务进程可能也是不一样的。真正运行于系统上的内核服务进程可能还有</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntkrnlmp.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntkrnlpa.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >这样的情况不过为了统一起见，下文仍统称这个进程为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。另外，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的各个表项也未必会全部指向</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的服务函数，因为你机器上的杀毒监控或其它驱动程序可能会改写</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的某些表项这也就是所谓的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >挂钩</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >以达到它们的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >主动防御</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >式杀毒方式或其它的特定目的。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >KeServiceDescriptorTable</SPAN><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >事实上，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等等。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的一个导出项</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >KeServiceDescriptorTable</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >即是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的真身，亦即它在内核中的数据实体。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的数据结构定义如下：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >typedef&nbsp;struct&nbsp;_tagSSDT&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pvSSDTBase;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pvServiceCounterTable;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ulNumberOfServices;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;pvParamTableBase;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;SSDT,&nbsp;*PSSDT;&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >其中，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >pvSSDTBase</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >就是上面所说的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >系统服务描述符表</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的基地址。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >pvServiceCounterTable</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >则指向另一个索引表，该表包含了每个服务表项被调用的次数；不过这个值只在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Checkd&nbsp;Build</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的内核中有效，在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Free&nbsp;Build</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的内核中，这个值总为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NULL</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（注：</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Check/Free</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Build</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >模式，如果你只使用</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，可以简单地把它们理解为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Debug/Release</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >）。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ulNumberOfServices</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >表示当前系统所支持的服务个数。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >pvParamTableBase</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >指向</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSPT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >（</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >System&nbsp;Service&nbsp;Parameter&nbsp;Table</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，即系统服务参数表），该表格包含了每个服务所需的参数字节数。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >下面，让我们开看看这个结构里边到底有什么。打开内核调试器（以</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >kd</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >为例），输入命令显示</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >KeServiceDescriptorTable</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，如下。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >lkd&gt;&nbsp;dd&nbsp;KeServiceDescriptorTable&nbsp;l4</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >8055ab80&nbsp;804e3d20&nbsp;00000000&nbsp;0000011c&nbsp;804d9f48&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >接下来，亦可根据基地址与服务总数来查看整个服务表的各项：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >lkd&gt;&nbsp;dd&nbsp;804e3d20&nbsp;l11c</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >804e3d20&nbsp;80587691&nbsp;f84317aa&nbsp;f84317b4&nbsp;f84317be</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >804e3d30&nbsp;f84317c8&nbsp;f84317d2&nbsp;f84317dc&nbsp;f84317e6</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >804e3d40&nbsp;8057741c&nbsp;f84317fa&nbsp;f8431804&nbsp;f843180e</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >804e3d50&nbsp;f8431818&nbsp;f8431822&nbsp;f843182c&nbsp;f8431836</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >...&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >你获得的结果可能和我会有不同我指的是那堆以十六进制</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >f</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >开头的地址项，因为我的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >被</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >System&nbsp;Safety&nbsp;Monitor</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >接管了，没留下几个原生的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >表项。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >现在是写些代码的时候了。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >KeServiceDescriptorTable</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >及</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >各个表项的读取只能在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >层完成，于是这里我使用了内核驱动并借助</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DeviceIoControl</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >来完成。其中</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DeviceIoControl</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的分发代码实现如下面的代码所示，没有什么技术含量，所以不再解释。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >switch&nbsp;(&nbsp;IoControlCode&nbsp;)&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >case&nbsp;IOCTL_GETSSDT:</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__try</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProbeForWrite(&nbsp;OutputBuffer,&nbsp;sizeof(&nbsp;SSDT&nbsp;),&nbsp;sizeof(&nbsp;ULONG&nbsp;)&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlCopyMemory(&nbsp;OutputBuffer,&nbsp;KeServiceDescriptorTable,&nbsp;sizeof(&nbsp;SSDT&nbsp;)&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__except&nbsp;(&nbsp;EXCEPTION_EXECUTE_HANDLER&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoStatus-&gt;Status&nbsp;=&nbsp;GetExceptionCode();</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;break;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >case&nbsp;IOCTL_GETPROC:</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;uIndex&nbsp;=&nbsp;0;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PULONG&nbsp;pBase&nbsp;=&nbsp;NULL;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__try</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProbeForRead(&nbsp;InputBuffer,&nbsp;sizeof(&nbsp;ULONG&nbsp;),&nbsp;sizeof(&nbsp;ULONG&nbsp;)&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProbeForWrite(&nbsp;OutputBuffer,&nbsp;sizeof(&nbsp;ULONG&nbsp;),&nbsp;sizeof(&nbsp;ULONG&nbsp;)&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__except(&nbsp;EXCEPTION_EXECUTE_HANDLER&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoStatus-&gt;Status&nbsp;=&nbsp;GetExceptionCode();</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uIndex&nbsp;=&nbsp;*(PULONG)InputBuffer;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;KeServiceDescriptorTable-&gt;ulNumberOfServices&nbsp;&lt;=&nbsp;uIndex&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoStatus-&gt;Status&nbsp;=&nbsp;STATUS_INVALID_PARAMETER;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBase&nbsp;=&nbsp;KeServiceDescriptorTable-&gt;pvSSDTBase;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*((PULONG)OutputBuffer)&nbsp;=&nbsp;*(&nbsp;pBase&nbsp;+&nbsp;uIndex&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;break;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >//&nbsp;...</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >补充一下，再。</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的头文件中有一件很遗憾的事情，那就是其中并未声明</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >KeServiceDescriptorTable</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，不过我们可以自己手动添加之：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >extern&nbsp;PSSDT&nbsp;KeServiceDescriptorTable;&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >当然，如果你对</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DDK</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >开发实在不感兴趣的话，亦可以直接使用配套代码压缩包中的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDTDump.sys</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，并使用</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >DeviceIoControl</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >发送</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >IOCTL_GETSSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >和</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >IOCTL_GETPROC</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >控制码即可；或者，直接调用我为你准备好的两个函数：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >BOOL&nbsp;GetSSDT(&nbsp;IN&nbsp;HANDLE&nbsp;hDriver,&nbsp;OUT&nbsp;PSSDT&nbsp;buf&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >BOOL&nbsp;GetProc(&nbsp;IN&nbsp;HANDLE&nbsp;hDriver,&nbsp;IN&nbsp;ULONG&nbsp;ulIndex,&nbsp;OUT&nbsp;PULONG&nbsp;buf&nbsp;);&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >获取详细模块信息</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >虽然我们现在可以获取任意一个服务号所对应的函数地址了已经，但是你可能仍然不满意，认为只有获得了这个服务函数所在的模块才是王道。换句话说，对于一个干净的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >表来说，它里边的表项应该都是指向</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的；如果</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >之中有若干个表项被改写（挂钩），那么我们应该知道是哪一个或哪一些模块替换了这些服务。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >首先我们需要获得当前在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >层加载了那些模块。如我在本文开头所说，为了尽可能地少涉及</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >层的东西，于是在这里我使用了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtQuerySystemInformation</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >函数。关键代码如下：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >typedef&nbsp;struct&nbsp;_SYSTEM_MODULE_INFORMATION&nbsp;{&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Reserved[2];&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;Base;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Size;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;Flags;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;Index;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;Unknown;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;LoadCount;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;USHORT&nbsp;ModuleNameOffset;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;CHAR&nbsp;ImageName[256];&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;SYSTEM_MODULE_INFORMATION,&nbsp;*PSYSTEM_MODULE_INFORMATION;&nbsp;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >typedef&nbsp;struct&nbsp;_tagSysModuleList&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ulCount;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM_MODULE_INFORMATION&nbsp;smi[1];</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;SYSMODULELIST,&nbsp;*PSYSMODULELIST;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >s&nbsp;=&nbsp;NtQuerySystemInformation(&nbsp;SystemModuleInformation,&nbsp;pRet,</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;sizeof(&nbsp;SYSMODULELIST&nbsp;),&nbsp;&amp;nRetSize&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >if&nbsp;(&nbsp;STATUS_INFO_LENGTH_MISMATCH&nbsp;==&nbsp;s&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >缓冲区太小，重新分配</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;pRet;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;pRet&nbsp;=&nbsp;(PSYSMODULELIST)new&nbsp;BYTE[nRetSize];</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;NtQuerySystemInformation(&nbsp;SystemModuleInformation,&nbsp;pRet,</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nRetSize,&nbsp;&amp;nRetSize&nbsp;);&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >需要说明的是，这个函数是利用内核的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >PsLoadedModuleList</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >链表来枚举系统模块的，因此如果你遇到了能够隐藏驱动的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Rootkit</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，那么这种方法是无法找到被隐藏的模块的。在这种情况下，枚举系统的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"\Driver"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >目录对象可能可以更好解决这个问题，在此不再赘述了就。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >接下来，是根据</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >中的地址表项查找模块。有了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SYSTEM_MODULE_INFORMATION</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >结构中的模块基地址与模块大小，这个工作完成起来也很容易：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >BOOL&nbsp;FindModuleByAddr(&nbsp;IN&nbsp;ULONG&nbsp;ulAddr,&nbsp;IN&nbsp;PSYSMODULELIST&nbsp;pList,</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUT&nbsp;LPSTR&nbsp;buf,&nbsp;IN&nbsp;DWORD&nbsp;dwSize&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;ULONG&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pList-&gt;ulCount;&nbsp;++i&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ulBase&nbsp;=&nbsp;(ULONG)pList-&gt;smi[i].Base;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ulMax&nbsp;&nbsp;=&nbsp;ulBase&nbsp;+&nbsp;pList-&gt;smi[i].Size;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ulBase&nbsp;&lt;=&nbsp;ulAddr&nbsp;&amp;&amp;&nbsp;ulAddr&nbsp;&lt;&nbsp;ulMax&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >对于路径信息，截取之</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCSTR&nbsp;pszModule&nbsp;=&nbsp;strrchr(&nbsp;pList-&gt;smi[i].ImageName,&nbsp;'\\'&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;NULL&nbsp;!=&nbsp;pszModule&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lstrcpynA(&nbsp;buf,&nbsp;pszModule&nbsp;+&nbsp;1,&nbsp;dwSize&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lstrcpynA(&nbsp;buf,&nbsp;pList-&gt;smi[i].ImageName,&nbsp;dwSize&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TRUE;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >详细枚举系统服务项</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到现在为止，还遗留有一个问题，就是获得服务号对应的服务函数名。比如</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >下</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >0x7A</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >对应着</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，但是到</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2000</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >下，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >NtOpenProcess</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >就改为</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >0x6A</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >了。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >有一个好消息一个坏消息，你先听哪个？</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >什么坏消息？</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >Windows</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >并没有给我们开放这样现成的函数，所有的工作都需要我们自己来做。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >那好消息呢？</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >牛粪有的是。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >坏了，串词儿了。好消息是我们可以通过枚举</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的导出函数来间接枚举</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >所有表项所对应的函数，因为所有的内核服务函数对应于</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的同名函数都是这样开头的：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >mov&nbsp;eax,&nbsp;&lt;ServiceIndex&gt;&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >对应的机器码为：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >B8&nbsp;&lt;ServiceIndex&gt;&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >再说一遍：非常幸运，仅就我手头上的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2000&nbsp;sp4</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP&nbsp;sp1</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP&nbsp;sp2</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >、</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >2003</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >而言，无一例外。不过</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Mark&nbsp;Russinovich</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的《深入解析</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >Windows</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >操作系统》一书中指出，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >IA64</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的调用方式与此不同由于手头上没有相应的文件，所以在这里不进行讨论了就。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >接着说。我们可以把</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >mov</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的一句用如下的一个结构来表示：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >#pragma&nbsp;pack(&nbsp;push,&nbsp;1&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >typedef&nbsp;struct&nbsp;_tagSSDTEntry&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;byMov;&nbsp;&nbsp;&nbsp;//&nbsp;0xb8</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwIndex;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;SSDTENTRY;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >#pragma&nbsp;pack(&nbsp;pop&nbsp;)&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >那么，我们可以对</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的所有导出函数进行枚举，并筛选出</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >"Nt"</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >开头者，以</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDTENTRY</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的结构取出其开头</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >5</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >个字节进行比对这就是整个的枚举过程。相关的</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >PE</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >文件格式解析我不再解释，可参考注释。整个代码如下：</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >#define&nbsp;MOV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xb8</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >void&nbsp;EnumSSDT(&nbsp;IN&nbsp;HANDLE&nbsp;hDriver,&nbsp;IN&nbsp;HMODULE&nbsp;hNtDll&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;dwOffset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(DWORD)hNtDll;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PIMAGE_EXPORT_DIRECTORY&nbsp;pExpDir&nbsp;=&nbsp;NULL;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;nNameCnt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;LPDWORD&nbsp;pNameArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;NULL;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >PE</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >头部</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;dwOffset&nbsp;+=&nbsp;((PIMAGE_DOS_HEADER)hNtDll)-&gt;e_lfanew&nbsp;+&nbsp;sizeof(&nbsp;DWORD&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到第一个数据目录</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;dwOffset&nbsp;+=&nbsp;sizeof(&nbsp;IMAGE_FILE_HEADER&nbsp;)&nbsp;+&nbsp;sizeof(&nbsp;IMAGE_OPTIONAL_HEADER&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;IMAGE_NUMBEROF_DIRECTORY_ENTRIES&nbsp;*&nbsp;sizeof(&nbsp;IMAGE_DATA_DIRECTORY&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到导出表位置</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;dwOffset&nbsp;=&nbsp;(DWORD)hNtDll</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;((PIMAGE_DATA_DIRECTORY)dwOffset)-&gt;VirtualAddress;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;pExpDir&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)dwOffset;</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;nNameCnt&nbsp;=&nbsp;pExpDir-&gt;NumberOfNames;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >到函数名</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >RVA</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >数组</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;pNameArray&nbsp;=&nbsp;(LPDWORD)(&nbsp;(DWORD)hNtDll&nbsp;+&nbsp;pExpDir-&gt;AddressOfNames&nbsp;);</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >初始化系统模块链表</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;PSYSMODULELIST&nbsp;pList&nbsp;=&nbsp;CreateModuleList(&nbsp;hNtDll&nbsp;);</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >循环查找函数名</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nNameCnt;&nbsp;++i&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCSTR&nbsp;pszName&nbsp;=&nbsp;(PCSTR)(&nbsp;pNameArray[i]&nbsp;+&nbsp;(DWORD)hNtDll&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;'N'&nbsp;==&nbsp;pszName[0]&nbsp;&amp;&amp;&nbsp;'t'&nbsp;==&nbsp;pszName[1]&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >找到了函数，则定位至查找表</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPWORD&nbsp;pOrdNameArray&nbsp;=&nbsp;(LPWORD)(&nbsp;(DWORD)hNtDll&nbsp;+&nbsp;pExpDir-&gt;AddressOfNameOrdinals&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >定位至总表</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPDWORD&nbsp;pFuncArray&nbsp;&nbsp;&nbsp;=&nbsp;(LPDWORD)(&nbsp;(DWORD)hNtDll&nbsp;+&nbsp;pExpDir-&gt;AddressOfFunctions&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPCVOID&nbsp;pFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(LPCVOID)(&nbsp;(DWORD)hNtDll&nbsp;+&nbsp;pFuncArray[pOrdNameArray[i]]&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >解析函数，获取服务名</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSDTENTRY&nbsp;entry;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyMemory(&nbsp;&amp;entry,&nbsp;pFunc,&nbsp;sizeof(&nbsp;SSDTENTRY&nbsp;)&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;MOV&nbsp;==&nbsp;entry.byMov&nbsp;)</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULONG&nbsp;ulAddr&nbsp;=&nbsp;0;</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetProc(&nbsp;hDriver,&nbsp;entry.dwIndex,&nbsp;&amp;ulAddr&nbsp;);</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHAR&nbsp;strModule[MAX_PATH]&nbsp;=&nbsp;"[Unknown&nbsp;Module]";</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FindModuleByAddr(&nbsp;ulAddr,&nbsp;pList,&nbsp;strModule,&nbsp;MAX_PATH&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;"0x%04X\t%s\t0x%08X\t%s\r\n",&nbsp;entry.dwIndex,</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strModule,&nbsp;ulAddr,&nbsp;pszName&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >&nbsp;&nbsp;&nbsp;&nbsp;DestroyModuleList(&nbsp;pList&nbsp;);</SPAN><BR><SPAN style="BACKGROUND-COLOR: white;"   >}&nbsp;</SPAN><BR><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >下图是示例程序</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDTDump</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >XP&nbsp;sp2</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >上的部分运行截图，显示了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的基地址、服务个数，以及各个表项所对应的服务号、所在模块、地址和服务名。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><IMG title="2014年2月18日 - Howie - Dspace"   alt=""   src="pic/img1.ph.126.net_yvxqIf73p-7qE2hjH5_G3Q==_6597884504774611651.jpg"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >结语</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR><SPAN style="BACKGROUND-COLOR: white;"   >ring3</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >与</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring0</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >，城里与城外之间为一道叹息之墙所间隔，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >则是越过此墙的一道必经之门。因此，很多杀毒软件也势必会围绕着它大做文章。无论是</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >System&nbsp;Safety&nbsp;Monitor</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的系统监控，还是卡巴斯基的主动防御，都是挂钩了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >。这样，病毒尚在</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >内发作之时，便被扼杀于摇篮之内。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >内核最高权限，本就是兵家必争之地，魔高一尺道高一丈的争夺于此亦已变成颇为稀松平常之事。可以说和这些争夺比起来，</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的相关技术简直不值一提。但最初发作的病毒体总是从</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >ring3</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >开始的换句话说，任你未来会成长为何等的武林高手，我都可以在你学走路的时候杀掉你知晓了</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >SSDT</SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >的这点优势，所有的病毒咂吧咂吧也就都没味儿了。所以说么，杀毒莫如防毒。</SPAN><SPAN style="FONT-FAMILY: 宋体;"   ><BR><BR></SPAN><SPAN style="FONT-FAMILY: 宋体; BACKGROUND-COLOR: white;"   >就此打住罢，貌似扯远大发了。</SPAN></SPAN></P>
</body></html>