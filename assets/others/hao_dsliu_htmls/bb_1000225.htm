<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] 谈谈Windows程序中的字符编码</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] 谈谈Windows程序中的字符编码</h2>
<p align="right">发布时间：2011-4-14 11:30
<br>分类名称：windows</p><br>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >写这篇文章的起因是这么一个问题：我们在使用和安装<SPAN lang="EN-US"  >Windows</SPAN>程序时，有时会看到以<SPAN lang="EN-US"  >“2052”</SPAN>、<SPAN lang="EN-US"  >“1033”</SPAN>这些数字为名的文件夹，这些数字似乎和字符集有关，但它们究竟是什么意思呢？<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >研究这个问题的同时，又会遇到其它问题。我们会谈到<SPAN lang="EN-US"  >Windows</SPAN>的内部架构、<SPAN lang="EN-US"  >Win32 API</SPAN>的<SPAN lang="EN-US"  >A/W</SPAN>函数、<SPAN lang="EN-US"  >Locale</SPAN>、<SPAN lang="EN-US"  >ANSI</SPAN>代码页、与字符编码有关的编译参数、<SPAN lang="EN-US"  >MBCS</SPAN>和<SPAN lang="EN-US"  >Unicode</SPAN>程序、资源和乱码等，一起经历这段琐碎细节为主，间或乐趣点缀的旅程。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >0 Where is Win32 API</SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Windows</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序有用户态和核心态的说法。在<SPAN lang="EN-US"  >32</SPAN>位地址空间中，用户态代码只能访问<SPAN lang="EN-US"  >0x80000000</SPAN>以下空间（其实只是<SPAN lang="EN-US"  > 0x00010000-0x7FFEFFFF</SPAN>），核心态代码可以访问<SPAN lang="EN-US"  >0x80000000</SPAN>以上空间。所有硬件管理都在核心态。用户态代码不能直接使用核心态的任何代码。所谓用户态、核心态其实只是不同的<SPAN lang="EN-US"  >CPU</SPAN>特权级别。在<SPAN lang="EN-US"  >x86 CPU</SPAN>上，用户态处于<SPAN lang="EN-US"  >ring 3</SPAN>，核心态处于<SPAN lang="EN-US"  >ring 0</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >从用户态进入核心态的最常用的方法是在寄存器<SPAN lang="EN-US"  >eax</SPAN>填一个功能码，然后执行<SPAN lang="EN-US"  >int 2e</SPAN>。这有点像<SPAN lang="EN-US"  >DOS</SPAN>时代的<SPAN lang="EN-US"  >DOS</SPAN>和<SPAN lang="EN-US"  >BIOS</SPAN>系统调用。在<SPAN lang="EN-US"  >NT</SPAN>架构中这种机制被称作<SPAN lang="EN-US"  >system service</SPAN>。<SPAN lang="EN-US"  > </SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在核心态提供<SPAN lang="EN-US"  >system service</SPAN>的有两个家伙：<SPAN lang="EN-US"  >ntoskrnl.exe</SPAN>和<SPAN lang="EN-US"  >win32k.sys</SPAN>。 <SPAN lang="EN-US"  >ntoskrnl.exe</SPAN>是<SPAN lang="EN-US"  >Windows</SPAN>的大脑，它的上层被称为<SPAN lang="EN-US"  > Executive</SPAN>，下层被称作<SPAN lang="EN-US"  >Kernel</SPAN>。<SPAN lang="EN-US"  >Win32k.sys</SPAN>提供与显示有关的<SPAN lang="EN-US"  >system service</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在用户态一侧，有一个重要的角色叫作<SPAN lang="EN-US"  >ntdll.dll</SPAN>，大多数<SPAN lang="EN-US"  >system service</SPAN>都是它调用的。它封装这些<SPAN lang="EN-US"  >system service</SPAN>，然后提供一个<SPAN lang="EN-US"  >API</SPAN>接口。这个接口被称作<SPAN lang="EN-US"  >native API</SPAN>。<SPAN lang="EN-US"  > native API</SPAN>的用户是各个子系统（<SPAN lang="EN-US"  >subsystem</SPAN>），包括<SPAN lang="EN-US"  >Win32</SPAN>子系统、<SPAN lang="EN-US"  >OS/2</SPAN>子系统、<SPAN lang="EN-US"  >POSIX</SPAN>子系统。各个子系统为<SPAN lang="EN-US"  >Win32</SPAN>、<SPAN lang="EN-US"  >OS2</SPAN>、<SPAN lang="EN-US"  >POSIX</SPAN>程序提供了运行平台。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >ntdll.dll</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >由于提供了平台无关的<SPAN lang="EN-US"  >API</SPAN>接口，所以被看作是<SPAN lang="EN-US"  >NT</SPAN>系统的原生接口，由之得到了<SPAN lang="EN-US"  >“native API”</SPAN>的匪号。其实它的主要工作是将调用传递到核心态。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Win32</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >、<SPAN lang="EN-US"  >OS/2</SPAN>、<SPAN lang="EN-US"  >POSIX</SPAN>，听起来很庞大。其实真正做好的只有<SPAN lang="EN-US"  >Win32</SPAN>子系统。<SPAN lang="EN-US"  >OS2</SPAN>、<SPAN lang="EN-US"  >POSIX</SPAN>都是<SPAN lang="EN-US"  >Console UI</SPAN>，即只有字符界面。提供<SPAN lang="EN-US"  >OS/2</SPAN>子系统，只因为在<SPAN lang="EN-US"  >1988</SPAN>年，<SPAN lang="EN-US"  >NT</SPAN>的主要设计目标就是与<SPAN lang="EN-US"  >OS/2</SPAN>兼容，后来由于<SPAN lang="EN-US"  >Windows 3.0</SPAN>卖得很好，所以设计目标被变更为与<SPAN lang="EN-US"  >Windows</SPAN>兼容。提供<SPAN lang="EN-US"  >POSIX</SPAN>子系统，是为了应付美国政府的一个编号为<SPAN lang="EN-US"  >FIPS 151-2</SPAN>的标准。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Win32</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >子系统的管理员是一个叫作<SPAN lang="EN-US"  >csrss.exe</SPAN>的弟兄，它的全名是：<SPAN lang="EN-US"  >Client/Server Run-Time Subsystem</SPAN>。它刚上任时，本来要分管所有的子系统，但后来<SPAN lang="EN-US"  >POSIX</SPAN>和<SPAN lang="EN-US"  >OS/2</SPAN>都被分别处理了，所以只管了一个<SPAN lang="EN-US"  >Win32</SPAN>。即使这样也很了不起， 所有的<SPAN lang="EN-US"  >Win32</SPAN>程序的进程、线程们都要向它登记。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >不过<SPAN lang="EN-US"  >Win32</SPAN>程序用得最多的还是<SPAN lang="EN-US"  >Win32</SPAN>子系统的<SPAN lang="EN-US"  >DLL</SPAN>们，最核心的<SPAN lang="EN-US"  >DLL</SPAN>包括：<SPAN lang="EN-US"  >kernel32.dll</SPAN>、<SPAN lang="EN-US"  >User32.dll</SPAN>、<SPAN lang="EN-US"  >Gdi32.dll</SPAN>、<SPAN lang="EN-US"  >Advapi32.dll</SPAN>。这些<SPAN lang="EN-US"  >DLL</SPAN>包装了<SPAN lang="EN-US"  >ntdll.dll</SPAN>的<SPAN lang="EN-US"  >native API</SPAN>。其中<SPAN lang="EN-US"  >Gdi32.dll</SPAN>比较特殊，它与核心态的<SPAN lang="EN-US"  >win32k.sys</SPAN>直接保持联系，以提高<SPAN lang="EN-US"  >NT</SPAN>系统的图形处理能力。<SPAN lang="EN-US"  >Win32</SPAN>子系统的<SPAN lang="EN-US"  >DLL</SPAN>们提供的接口函数在<SPAN lang="EN-US"  >MSDN</SPAN>文档中被详细介绍，它们就是<SPAN lang="EN-US"  >Win32 API</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >附录<SPAN lang="EN-US"  >0 Windows</SPAN>的启动<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >计算机上电后，从<SPAN lang="EN-US"  >BIOS</SPAN>的<SPAN lang="EN-US"  >ROM</SPAN>开始运行。<SPAN lang="EN-US"  >BIOS</SPAN>在做一些初始化后会将硬盘的第一个扇区的数据读入内存，然后将控制权交给它，这段数据被称作<SPAN lang="EN-US"  >Master Boot Record</SPAN>（<SPAN lang="EN-US"  >MBR</SPAN>）。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >MBR</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >包含一段启动代码和硬盘的主分区表。这段启动代码扫描主分区表，找到第一个可以启动的分区，然后将这个分区的第一个扇区读入内存并运行。这个扇区被称作引导扇区（<SPAN lang="EN-US"  >boot sector</SPAN>）。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >引导扇区的代码具备读文件系统根目录的能力，显然不同的文件系统需要不同的代码。引导扇区会从根目录中读出一个叫作<SPAN lang="EN-US"  >ntldr</SPAN>的文件。顾名思义，这个文件是<SPAN lang="EN-US"  >load NT</SPAN>的主要角色。它的业绩主要包括将<SPAN lang="EN-US"  >CPU</SPAN>从实模式转入保护模式，启动分页机制，处理<SPAN lang="EN-US"  >boot.ini</SPAN>等。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >如果<SPAN lang="EN-US"  >boot.ini</SPAN>中有一句：<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >C:\bootsect.rh="Red Hat Linux"</SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >bootsect.rh</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >的内容是<SPAN lang="EN-US"  >Linux</SPAN>引导扇区，用户又选择了<SPAN lang="EN-US"  >“Red Hat Linux”</SPAN>，<SPAN lang="EN-US"  >ntldr</SPAN>就会将执行<SPAN lang="EN-US"  >Linux</SPAN>的引导扇区，开始<SPAN lang="EN-US"  >Linux</SPAN>的引导。如果用户选择继续使用<SPAN lang="EN-US"  >Windows</SPAN>，<SPAN lang="EN-US"  >ntldr</SPAN>会装载并运行我们前面提到的<SPAN lang="EN-US"  >ntoskrnl.exe</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >ntoskrnl.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >会启动会话管理器<SPAN lang="EN-US"  >smss.exe</SPAN>。<SPAN lang="EN-US"  >smss.exe</SPAN>启动<SPAN lang="EN-US"  >csrss.exe</SPAN>和<SPAN lang="EN-US"  >winlogon.exe</SPAN>。<SPAN lang="EN-US"  > smss.exe</SPAN>会永远等待<SPAN lang="EN-US"  >csrss.exe</SPAN>和<SPAN lang="EN-US"  >winlogon.exe</SPAN>返回。如果两者之一异常中止，就会导致系统崩溃。所以病毒们经常以打击<SPAN lang="EN-US"  > csrss.exe</SPAN>为乐。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >winlogon.exe</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >负责用户登录，在完成登录后，它会启动注册表<SPAN lang="EN-US"  >HKLM\SOFTWARE\Microsoft\Windows NT\Current Version\Winlogon</SPAN>项下<SPAN lang="EN-US"  >Userinit</SPAN>值指定的程序。该值的缺省数据是<SPAN lang="EN-US"  >userinit.exe</SPAN>。<SPAN lang="EN-US"  >userinit.exe</SPAN>会装载个人设 置，让硬盘响个不停，并考验我们的耐性，最后启动注册表同一项下<SPAN lang="EN-US"  >Shell</SPAN>值指定的程序。该值的缺省数据是<SPAN lang="EN-US"  >Explorer.exe</SPAN>。<SPAN lang="EN-US"  > Explorer.exe</SPAN>运行后，我们就会看到熟悉的开始菜单和桌面。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >1 Win32 API</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >的<SPAN lang="EN-US"  >A/W</SPAN>函数<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >要了解<SPAN lang="EN-US"  >Win32</SPAN>子系统的<SPAN lang="EN-US"  >DLL</SPAN>们提供了哪些<SPAN lang="EN-US"  >API</SPAN>，最直接的方法就是用<SPAN lang="EN-US"  >Win32dsm</SPAN>直接查看<SPAN lang="EN-US"  >DLL</SPAN>们的导出表。这时我们会发现<SPAN lang="EN-US"  >Win32 API</SPAN>中带字符串的<SPAN lang="EN-US"  >API</SPAN>一般都有两个版本，例如<SPAN lang="EN-US"  >CreateFileA</SPAN>和<SPAN lang="EN-US"  >CreateFileW</SPAN>。当然也有例外，例如<SPAN lang="EN-US"  >GetProcAddress</SPAN>函 数。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >A</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >代表<SPAN lang="EN-US"  >ANSI</SPAN>代码页，<SPAN lang="EN-US"  >W</SPAN>是宽字符，即<SPAN lang="EN-US"  >Unicode</SPAN>字符。<SPAN lang="EN-US"  >Windows</SPAN>中的<SPAN lang="EN-US"  >Unicode</SPAN>字符一般指<SPAN lang="EN-US"  >UCS2</SPAN>的<SPAN lang="EN-US"  >UTF16-LE</SPAN>编码。让我们通过几个实例观察<SPAN lang="EN-US"  >A/W</SPAN>版本间的关系。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >例<SPAN lang="EN-US"  >1</SPAN>：用<SPAN lang="EN-US"  >WIn32dsm</SPAN>查看<SPAN lang="EN-US"  >gdi32.dll</SPAN>的汇编代码，可以看到<SPAN lang="EN-US"  >TextOutA</SPAN>调用<SPAN lang="EN-US"  >GdiGetCodePage</SPAN>获取当前代码页，再调用<SPAN lang="EN-US"  >MultiByteToWideChar</SPAN>转换输入的字符串，然后调用一个内部函数。而<SPAN lang="EN-US"  >TextOutW</SPAN>直接调用这个内部函数。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >例<SPAN lang="EN-US"  >2</SPAN>：用调试器跟踪一个使用了<SPAN lang="EN-US"  >CreateFileA</SPAN>的程序，可以看到：<SPAN lang="EN-US"  >CreateFileA</SPAN>在将输入字符串转换为<SPAN lang="EN-US"  >Unicode</SPAN>后，会调用<SPAN lang="EN-US"  >CreateFileW</SPAN>。假设输入文件名是<SPAN lang="EN-US"  >“</SPAN>测试<SPAN lang="EN-US"  >.txt”</SPAN>，对应的数据就是：<SPAN lang="EN-US"  >“B2 E2 CA D4 2E 74 78 74 00”</SPAN>。<SPAN lang="EN-US"  ><BR></SPAN>在调试器中可以看到传给<SPAN lang="EN-US"  >CreateFileW</SPAN>的文件名数据是：<SPAN lang="EN-US"  >“4B 6D D5 8B 2E 00 74 00 78 00 74 00 00 00”</SPAN>。 这是<SPAN lang="EN-US"  >"</SPAN>测试<SPAN lang="EN-US"  >.txt"</SPAN>对应的<SPAN lang="EN-US"  >Unicdoe</SPAN>字符串。<SPAN lang="EN-US"  >CreateFileW</SPAN>会接着调用<SPAN lang="EN-US"  >ntdll.dll</SPAN>中的<SPAN lang="EN-US"  >NtCreateFile</SPAN>。顺便看看<SPAN lang="EN-US"  > NtCreateFile</SPAN>的代码：<SPAN lang="EN-US"  ><BR>mov eax, 00000020<BR>lea edx, dword ptr [esp+04]<BR>int 2E<BR>ret 002C<BR></SPAN>可见这个<SPAN lang="EN-US"  >native API</SPAN>只是简单地调用了核心态提供的<SPAN lang="EN-US"  >0x20</SPAN>号<SPAN lang="EN-US"  >system service</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >例<SPAN lang="EN-US"  >3</SPAN>：<SPAN lang="EN-US"  >gdi32.dll</SPAN>中的<SPAN lang="EN-US"  >GetGlyphOutline</SPAN>函数可以获取指定字符的字模。<SPAN lang="EN-US"  >GetGlyphOutlineA</SPAN>和<SPAN lang="EN-US"  >GetGlyphOutlineW</SPAN>函数都会调用同一个内部函数（记作<SPAN lang="EN-US"  >F</SPAN>）。函数<SPAN lang="EN-US"  >F</SPAN>在返回前将通过<SPAN lang="EN-US"  >int 2E</SPAN>调用<SPAN lang="EN-US"  >0x10B1</SPAN>号<SPAN lang="EN-US"  >system service</SPAN>。<SPAN lang="EN-US"  ><BR>GetGlyphOutlineW</SPAN>直接调用函数<SPAN lang="EN-US"  >F</SPAN>。<SPAN lang="EN-US"  >GetGlyphOutlineA</SPAN>在调用函数<SPAN lang="EN-US"  >F</SPAN>前，要依次调用<SPAN lang="EN-US"  >GdiGetCodePage</SPAN>、<SPAN lang="EN-US"  > IsDBCSLeadByteEx</SPAN>和<SPAN lang="EN-US"  >MultiByteToWideChar</SPAN>，将当前代码页的字符编码转换成<SPAN lang="EN-US"  >Unicode</SPAN>编码。<SPAN lang="EN-US"  ><BR></SPAN>如果我们调用<SPAN lang="EN-US"  >GetGlyphOutlineA</SPAN>时传入<SPAN lang="EN-US"  >“baba”</SPAN>，这是<SPAN lang="EN-US"  >“</SPAN>汉<SPAN lang="EN-US"  >”</SPAN>字的<SPAN lang="EN-US"  >GBK</SPAN>编码，用调试器可以看到传给函数<SPAN lang="EN-US"  >F</SPAN>的字符编码是<SPAN lang="EN-US"  >“6c49”</SPAN>，这是<SPAN lang="EN-US"  >“</SPAN>汉<SPAN lang="EN-US"  >”</SPAN>字的<SPAN lang="EN-US"  >Unicode</SPAN>编码。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >从以上例子可见，<SPAN lang="EN-US"  >A</SPAN>版本总会在某处将输入的字符串转换为<SPAN lang="EN-US"  >Unicode</SPAN>字符串，然后和<SPAN lang="EN-US"  >W</SPAN>版本执行相同的代码。在由<SPAN lang="EN-US"  >A/W</SPAN>版本<SPAN lang="EN-US"  >API</SPAN>引出<SPAN lang="EN-US"  >MBCS</SPAN>程序和<SPAN lang="EN-US"  >Unicode</SPAN>程序前，让我们先解释一下<SPAN lang="EN-US"  >Locale</SPAN>和<SPAN lang="EN-US"  >ANSI</SPAN>代码页。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >2 Locale</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >和<SPAN lang="EN-US"  >ANSI</SPAN>代码页<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >2.1 Locale</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >和<SPAN lang="EN-US"  >LCID</SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Locale</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >是指特定于某个国家或地区的一组设定，包括字符集，数字、货币、时间和日期的格式等。在<SPAN lang="EN-US"  >Windows</SPAN>中，每个<SPAN lang="EN-US"  >Locale</SPAN>可以用一个<SPAN lang="EN-US"  > 32</SPAN>位数字表示，记作<SPAN lang="EN-US"  >LCID</SPAN>。在<SPAN lang="EN-US"  >winnt.h</SPAN>中可以看到<SPAN lang="EN-US"  >LCID</SPAN>的组成。它的高<SPAN lang="EN-US"  >16</SPAN>位表示字符的排序方法，一般为<SPAN lang="EN-US"  >0</SPAN>。在它的低<SPAN lang="EN-US"  >16</SPAN>位中，低<SPAN lang="EN-US"  >10</SPAN>位是<SPAN lang="EN-US"  > primary language</SPAN>的<SPAN lang="EN-US"  >ID</SPAN>，高<SPAN lang="EN-US"  >4</SPAN>位指定<SPAN lang="EN-US"  >sublanguage</SPAN>。<SPAN lang="EN-US"  >sublanguage</SPAN>被用来区分同一种语言的不同编码。下面是部分<SPAN lang="EN-US"  >primary language</SPAN>和<SPAN lang="EN-US"  >sublanguage</SPAN>的常数定义：<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >#define LANG_CHINESE 0x04<BR>#define LANG_ENGLISH 0x09<BR>#define LANG_FRENCH 0x0c<BR>#define LANG_GERMAN 0x07</SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >#define SUBLANG_CHINESE_TRADITIONAL 0x01 // Chinese (Taiwan Region)<BR>#define SUBLANG_CHINESE_SIMPLIFIED 0x02 // Chinese (PR China)<BR>#define SUBLANG_ENGLISH_US 0x01 // English (USA)<BR>#define SUBLANG_ENGLISH_UK 0x02 // English (UK)</SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >好，现在我们可以计算简体中文的<SPAN lang="EN-US"  >LCID</SPAN>了，将<SPAN lang="EN-US"  >sublanguage</SPAN>的常数左移<SPAN lang="EN-US"  >10</SPAN>位，即乘上<SPAN lang="EN-US"  >1024</SPAN>，再加上<SPAN lang="EN-US"  >primary language</SPAN>的常数：<SPAN lang="EN-US"  >2*1024+4=2052</SPAN>，<SPAN lang="EN-US"  >16</SPAN>进制是<SPAN lang="EN-US"  >0804</SPAN>。美国英语是：<SPAN lang="EN-US"  >1*1024+9=1033</SPAN>，<SPAN lang="EN-US"  >16</SPAN>进制是<SPAN lang="EN-US"  >0409</SPAN>。。繁体中文是<SPAN lang="EN-US"  > 1*1024+4=1028</SPAN>，<SPAN lang="EN-US"  >16</SPAN>进制是<SPAN lang="EN-US"  >0404</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >2.2 </SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >代码页<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >每个<SPAN lang="EN-US"  >Locale</SPAN>都联系着很多信息，可以通过<SPAN lang="EN-US"  >GetLocalInfo</SPAN>函数读取。其中最重要的信息就是字符集了，即<SPAN lang="EN-US"  >Locale</SPAN>对应的语言文字的编码。<SPAN lang="EN-US"  >Windows</SPAN>将字符集称作代码页。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >每个<SPAN lang="EN-US"  >Locale</SPAN>可以对应一个<SPAN lang="EN-US"  >ANSI</SPAN>代码页和一个<SPAN lang="EN-US"  >OEM</SPAN>代码页。<SPAN lang="EN-US"  >Win32 API</SPAN>使用<SPAN lang="EN-US"  >ANSI</SPAN>代码页，底层设备使用<SPAN lang="EN-US"  >OEM</SPAN>代码页，两者可以相互映射。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >例如<SPAN lang="EN-US"  >English (US)</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>和<SPAN lang="EN-US"  >OEM</SPAN>代码页分别为<SPAN lang="EN-US"  >“1252 (ANSI - Latin I)”</SPAN>和<SPAN lang="EN-US"  >“437 (OEM - United States)”</SPAN>。<SPAN lang="EN-US"  > Chinese (PRC)</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>和<SPAN lang="EN-US"  >OEM</SPAN>代码页都是<SPAN lang="EN-US"  >“936 (ANSI/OEM - Simplified Chinese GBK)”</SPAN>。<SPAN lang="EN-US"  > Chinese (TW)</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>和<SPAN lang="EN-US"  >OEM</SPAN>代码页都是<SPAN lang="EN-US"  >“950 (ANSI/OEM - Traditional Chinese Big5)”</SPAN>。<SPAN lang="EN-US"  > </SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >附录<SPAN lang="EN-US"  >1</SPAN>中有一张很长的表。列出了我正在使用的<SPAN lang="EN-US"  >Windows</SPAN>所支持的<SPAN lang="EN-US"  >135</SPAN>个<SPAN lang="EN-US"  >Locale</SPAN>的部分信息，包括<SPAN lang="EN-US"  > LCID</SPAN>、国家<SPAN lang="EN-US"  >/</SPAN>地区名称、语言名称、语言缩写和对应的<SPAN lang="EN-US"  >ANSI</SPAN>代码页。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >2.3 </SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >系统<SPAN lang="EN-US"  >Locale</SPAN>、用户<SPAN lang="EN-US"  >Locale</SPAN>，再谈<SPAN lang="EN-US"  >ANSI</SPAN>代码页<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在<SPAN lang="EN-US"  >Windows</SPAN>中，通过控制面板可以为系统和用户分别设置<SPAN lang="EN-US"  >Locale</SPAN>。系统<SPAN lang="EN-US"  >Locale</SPAN>决定代码页，用户<SPAN lang="EN-US"  >Locale</SPAN>决定数字、货币、时间和日期的格式。这不是一个好的设计，后面会谈到它带来的问题。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >使用<SPAN lang="EN-US"  >GetSystemDefaultLCID</SPAN>函数和<SPAN lang="EN-US"  >GetUserDefaultLCID</SPAN>函数分别得到系统和用户的<SPAN lang="EN-US"  >LCID</SPAN>。有很多材料将这两个函数和另外两个函数混淆：<SPAN lang="EN-US"  >GetSystemDefaultUILanguage</SPAN>和<SPAN lang="EN-US"  >GetUserDefaultUILanguage</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >GetSystemDefaultUILanguage</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >和<SPAN lang="EN-US"  >GetUserDefaultUILanguage</SPAN>得到的是您当前使用的<SPAN lang="EN-US"  >Windows</SPAN>版本所带的<SPAN lang="EN-US"  >UI</SPAN>资源的语言。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >用户程序缺省使用的代码页是当前系统<SPAN lang="EN-US"  >Locale</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>代码页，可以称作<SPAN lang="EN-US"  >ANSI</SPAN>编码，也就是<SPAN lang="EN-US"  >A</SPAN>版本的<SPAN lang="EN-US"  >Win32 API</SPAN>默认的字符编码。对于一个未指定编码方式的文本文件，<SPAN lang="EN-US"  >Windows</SPAN>会按照<SPAN lang="EN-US"  >ANSI</SPAN>编码解释。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >2.4 AppLocale</SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >如果一个文本文件采用<SPAN lang="EN-US"  >BIG5</SPAN>编码，系统当前的<SPAN lang="EN-US"  >ANSI</SPAN>代码页是<SPAN lang="EN-US"  >GBK</SPAN>。打开这个文件，就会显示乱码。例如<SPAN lang="EN-US"  >“</SPAN>中文<SPAN lang="EN-US"  >”</SPAN>在<SPAN lang="EN-US"  >BIG5</SPAN>中的编码是<SPAN lang="EN-US"  >A4A4</SPAN>、<SPAN lang="EN-US"  >A4E5</SPAN>，这两个编码在<SPAN lang="EN-US"  >GBK</SPAN>中对应的字符是<SPAN lang="EN-US"  >“</SPAN>いゅ<SPAN lang="EN-US"  >”</SPAN>。这是日文的两个平假名。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在<SPAN lang="EN-US"  >Windows XP</SPAN>平台有一个<SPAN lang="EN-US"  >AppLocale</SPAN>程序，可以以指定的语言运行非<SPAN lang="EN-US"  >Unicode</SPAN>程序。用<SPAN lang="EN-US"  >Win32dsm</SPAN>打开看一看，其实它只是在运行程序前设置了两个环境变量。我们可以用个批处理文件模仿一下：<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >@ECHO OFF<BR>SET __COMPAT_LAYER=#ApplicationLocale<BR>SET ApplocaleID=0404<BR>start notepad.exe</SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在简体中文平台，用这个批处理文件启动的记事本可以正确显示<SPAN lang="EN-US"  >BIG5</SPAN>编码的文本文件。用它打开<SPAN lang="EN-US"  >GBK</SPAN>编码的文本文件会怎么样？<SPAN lang="EN-US"  >“</SPAN>中文<SPAN lang="EN-US"  >”</SPAN>会被显示为<SPAN lang="EN-US"  >“</SPAN>笢恅<SPAN lang="EN-US"  >”</SPAN>。设置这两个环境变量会作用于当前进程和其子进程。<SPAN lang="EN-US"  >Windows 2000</SPAN>平台不支持这个方法。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >3 MBCS</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序和<SPAN lang="EN-US"  >Unicode</SPAN>程序<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >3.1 </SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >与字符编码有关的编译参数<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >让我们回到<SPAN lang="EN-US"  >Win32 API</SPAN>。我们在程序中使用的<SPAN lang="EN-US"  >Win32 API</SPAN>没有<SPAN lang="EN-US"  >A/W</SPAN>后缀，<SPAN lang="EN-US"  >Windows</SPAN>的头文件会根据编译参数<SPAN lang="EN-US"  >UNICODE</SPAN>将没有后缀的函数名替换为<SPAN lang="EN-US"  >A</SPAN>版本或<SPAN lang="EN-US"  >W</SPAN>版本，例如：<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >#ifdef UNICODE<BR>#define CreateFile CreateFileW<BR>#else<BR>#define CreateFile CreateFileA<BR>#endif</SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >C RunTime</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >库（<SPAN lang="EN-US"  >CRT</SPAN>）使用<SPAN lang="EN-US"  >_UNICODE</SPAN>和<SPAN lang="EN-US"  >_MBCS</SPAN>来区分三套字符串处理函数，分别用于<SPAN lang="EN-US"  >SBCS</SPAN>、<SPAN lang="EN-US"  >MBCS</SPAN>和<SPAN lang="EN-US"  >Unicdoe</SPAN>字符串。<SPAN lang="EN-US"  >SBCS</SPAN>和<SPAN lang="EN-US"  > MBCS</SPAN>分别指单字节字符串和多字节字符串。例如<SPAN lang="EN-US"  >_tcsclen</SPAN>的<SPAN lang="EN-US"  >3</SPAN>个版本分别为<SPAN lang="EN-US"  >strlen</SPAN>、<SPAN lang="EN-US"  >_mbslen</SPAN>和<SPAN lang="EN-US"  >wcslen </SPAN>，猜猜以下函数返回几？<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >strlen("VOIP</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >网关<SPAN lang="EN-US"  >");<BR>_mbslen((unsigned char *)"VOIP</SPAN>网关<SPAN lang="EN-US"  >");<BR>wcslen(L"VOIP</SPAN>网关<SPAN lang="EN-US"  >");</SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >答案是<SPAN lang="EN-US"  >8</SPAN>、<SPAN lang="EN-US"  >6</SPAN>、<SPAN lang="EN-US"  >6</SPAN>。<SPAN lang="EN-US"  >L"ANSI</SPAN>字符串<SPAN lang="EN-US"  >"</SPAN>通知编译器将<SPAN lang="EN-US"  >ANSI</SPAN>字符串转换为<SPAN lang="EN-US"  >Unicode</SPAN>字符串，这是<SPAN lang="EN-US"  >VC++</SPAN>编译器提供的一个小甜点。不过我们应 该用宏：<SPAN lang="EN-US"  >_T("ANSI</SPAN>字符串<SPAN lang="EN-US"  >")</SPAN>。<SPAN lang="EN-US"  >_T</SPAN>宏只在我们定义了<SPAN lang="EN-US"  >_UNICODE</SPAN>时才转换。这样同一套代码既可以编译<SPAN lang="EN-US"  >MBCS</SPAN>版本，也可以编译<SPAN lang="EN-US"  >Unicode </SPAN>版本。<SPAN lang="EN-US"  > </SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >用<SPAN lang="EN-US"  >_UNICODE</SPAN>参数区分<SPAN lang="EN-US"  >Unicode</SPAN>版本特有的代码，决定使用什么版本的导入库或静态库。<SPAN lang="EN-US"  > </SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >3.2 Unicode</SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序、<SPAN lang="EN-US"  >MBCS</SPAN>程序和多语言支持<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Unicode</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序直接使用<SPAN lang="EN-US"  >Unicode</SPAN>版本的<SPAN lang="EN-US"  >CRT</SPAN>和<SPAN lang="EN-US"  >Win32 API</SPAN>。<SPAN lang="EN-US"  >Unicode</SPAN>程序的运行与当前的<SPAN lang="EN-US"  >ANSI</SPAN>代码页没有关系。<SPAN lang="EN-US"  >MBCS</SPAN>程序的运行依赖于<SPAN lang="EN-US"  >ANSI</SPAN>代码页。如果设计者和使用者使用不同的代码页，就可能出现乱码。微软开发的程序大都是<SPAN lang="EN-US"  >Unicode</SPAN>程序，不管我们怎样变换系统<SPAN lang="EN-US"  >Locale</SPAN>，它们总能正常运行。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >使用<SPAN lang="EN-US"  >VCL</SPAN>类库的<SPAN lang="EN-US"  >Delphi</SPAN>程序都是<SPAN lang="EN-US"  >MBCS</SPAN>程序。<SPAN lang="EN-US"  >VCL</SPAN>框架在程序启动会调用<SPAN lang="EN-US"  >GetThreadLocale</SPAN>获取当前用户的<SPAN lang="EN-US"  >LCID</SPAN>，然后在当前目录查找对应的资源文件，命名规则是：程序名<SPAN lang="EN-US"  >+'.'+</SPAN>语言缩写，语言缩写可以参见附录<SPAN lang="EN-US"  >1</SPAN>。在找不到时才会使用<SPAN lang="EN-US"  >EXE</SPAN>文件中的资源。不过如果系统<SPAN lang="EN-US"  > LCID</SPAN>是<SPAN lang="EN-US"  >English(United States)</SPAN>，用户<SPAN lang="EN-US"  >LCID</SPAN>是<SPAN lang="EN-US"  >Chinese(PRC)</SPAN>，由<SPAN lang="EN-US"  >VCL</SPAN>产生的程序就会出现乱码。读者可以自己分析原因。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >为<SPAN lang="EN-US"  >VCL</SPAN>程序做多语言版本。只要用<SPAN lang="EN-US"  >Delphi</SPAN>自带的<SPAN lang="EN-US"  >Resource DLL Wizard</SPAN>再做一个特定语言的资源<SPAN lang="EN-US"  >DLL</SPAN>，原来的程序都不用改。不过很多程序员用其它组件做多语言版本，例如<SPAN lang="EN-US"  >TsiLang </SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >MBCS</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序虽然也可以做成多语言版本，但它无法在同时显示不同代码页特有的字符，这时就必须使用<SPAN lang="EN-US"  >Unicode</SPAN>程序了。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >VS.NET</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >文档中有个多语言资源的例子：<SPAN lang="EN-US"  >SatDLL</SPAN>。它只用<SPAN lang="EN-US"  >Win32 API</SPAN>的例子，却用了<SPAN lang="EN-US"  >VC7</SPAN>项目。我在学习时将它改成了<SPAN lang="EN-US"  >VC6</SPAN>项目，并纠正了它的两个问题：<SPAN lang="EN-US"  ><BR>1</SPAN>、用<SPAN lang="EN-US"  >GetUserDefaultUILanguage</SPAN>读到的是<SPAN lang="EN-US"  >Windows</SPAN>资源版本，不是当前用户设置的代码页。<SPAN lang="EN-US"  ><BR>2</SPAN>、启动时没有使用资源<SPAN lang="EN-US"  >DLL</SPAN>里的菜单。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >在我的个人主页<SPAN lang="EN-US"  >(http://www.fmddlmyy.cn)</SPAN>上可以下载修改过的</SPAN><SPAN lang="EN-US"  ><A rel="nofollow" href="http://www.fmddlmyy.cn/satdll.rar"  ><SPAN style="FONT-FAMILY: 宋体; COLOR: blue; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >SatDLL</SPAN></A></SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >。 这个程序说明了支持多语言资源的基本思路：将不同语言资源放到不同的<SPAN lang="EN-US"  >DLL</SPAN>中，在程序启动时根据当前<SPAN lang="EN-US"  >Locale</SPAN>装载对应的资源<SPAN lang="EN-US"  >DLL</SPAN>。必要时动态切换资源。为了标记不同语言的资源，可以将它们放到不同的目录中，以<SPAN lang="EN-US"  >LCID</SPAN>作为目录名，例如<SPAN lang="EN-US"  >“2052”</SPAN>、<SPAN lang="EN-US"  >“1033”</SPAN>。当然我们也可以用其它方法联系<SPAN lang="EN-US"  > LCID</SPAN>和资源<SPAN lang="EN-US"  >DLL</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序可以在<SPAN lang="EN-US"  >App</SPAN>类的<SPAN lang="EN-US"  >InitInstance</SPAN>函数中用<SPAN lang="EN-US"  >AfxSetResourceHandle</SPAN>函数设置资源<SPAN lang="EN-US"  >DLL</SPAN>。在<SPAN lang="EN-US"  >Delphi</SPAN>中动态切换资源可以参考<SPAN lang="EN-US"  >Delphi Demo</SPAN>目录<SPAN lang="EN-US"  >RichEdit</SPAN>项目的<SPAN lang="EN-US"  >ReInit.pas</SPAN>。在读取当前设定时，建议用<SPAN lang="EN-US"  >GetSystemDefaultLCID</SPAN>函数，因为系统<SPAN lang="EN-US"  >Locale</SPAN>决定<SPAN lang="EN-US"  >ANSI</SPAN>代码页。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 4;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >3.4 </SPAN></B><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >资源和乱码<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >通过检查可执行文件，我们可以确定<SPAN lang="EN-US"  >VC</SPAN>和<SPAN lang="EN-US"  >Delphi</SPAN>的资源编译器都以<SPAN lang="EN-US"  >Unicode</SPAN>保存字符资源。在<SPAN lang="EN-US"  >VC</SPAN>环境编辑资源时，我们会指定资源的代码页。编译器根据资源的代码页，将其转换到<SPAN lang="EN-US"  >Unicode</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >Unicode</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >程序直接使用以<SPAN lang="EN-US"  >Unicode</SPAN>编码保存的资源。<SPAN lang="EN-US"  >MBCS</SPAN>程序需要将<SPAN lang="EN-US"  >Unicode</SPAN>资源先转换回当前<SPAN lang="EN-US"  >ANSI</SPAN>代码页，然后再使用。如果资源中的<SPAN lang="EN-US"  >Unicode</SPAN>字符串不能映射到当前代码页中的字符，就会出现<SPAN lang="EN-US"  >??</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >例如<SPAN lang="EN-US"  >Windows</SPAN>的标准对话框也会出现乱码。假设我们使用简体中文<SPAN lang="EN-US"  >Windows</SPAN>，当前<SPAN lang="EN-US"  >Locale</SPAN>是<SPAN lang="EN-US"  >Chinese (TW)</SPAN>，我们的程序是<SPAN lang="EN-US"  >MBCS</SPAN>的，使用标准的打开文件对话框。因为在<SPAN lang="EN-US"  >BIG5</SPAN>中没有<SPAN lang="EN-US"  >“</SPAN>开<SPAN lang="EN-US"  >”</SPAN>这个字，所以<SPAN lang="EN-US"  >“</SPAN>打开<SPAN lang="EN-US"  >”</SPAN>会被显示成<SPAN lang="EN-US"  >“</SPAN>打<SPAN lang="EN-US"  >?”</SPAN>。将程序编译成<SPAN lang="EN-US"  > Unicode</SPAN>版本，就可以避免这个问题。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >如果字符不是保存在资源中，而是硬编码在程序中。然后开发者和用户使用不同的代码页，就会导致乱码。假设开发者的<SPAN lang="EN-US"  >Locale</SPAN>是<SPAN lang="EN-US"  >Chinese (PRC)</SPAN>，用户的<SPAN lang="EN-US"  >Locale</SPAN>是<SPAN lang="EN-US"  >English (US)</SPAN>，程序中硬编码了字符串<SPAN lang="EN-US"  >“</SPAN>文件<SPAN lang="EN-US"  >”</SPAN>。<SPAN lang="EN-US"  > Chinese (PRC)</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>代码页是<SPAN lang="EN-US"  >GBK</SPAN>，<SPAN lang="EN-US"  >“</SPAN>文件<SPAN lang="EN-US"  >”</SPAN>的编码<SPAN lang="EN-US"  >“CE C4 BC FE”</SPAN>。<SPAN lang="EN-US"  >English (US)</SPAN>的<SPAN lang="EN-US"  >ANSI</SPAN>代码页是<SPAN lang="EN-US"  >Latin I</SPAN>，用户按照<SPAN lang="EN-US"  >Latin I</SPAN>编码去解释<SPAN lang="EN-US"  >“CE C4 BC FE”</SPAN>，就会看到<SPAN lang="EN-US"  >“???t”</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >回答我前面提过的一个问题：<SPAN lang="EN-US"  >Delphi</SPAN>程序根据用户<SPAN lang="EN-US"  >LCID</SPAN>转换资源中的字符串。如果用户<SPAN lang="EN-US"  >LCID</SPAN>是<SPAN lang="EN-US"  >Chinese (PRC)</SPAN>，系统<SPAN lang="EN-US"  >LCID</SPAN>是<SPAN lang="EN-US"  >English (US)</SPAN>。那么资源中的<SPAN lang="EN-US"  >Unicode</SPAN>字符串会被转换为<SPAN lang="EN-US"  >GBK</SPAN>编码，然后按照<SPAN lang="EN-US"  >Latin I</SPAN>显示，这时我们看到的就是类似<SPAN lang="EN-US"  >“???t”</SPAN>的东东，不是<SPAN lang="EN-US"  >??</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >既然资源是以<SPAN lang="EN-US"  >Unicode</SPAN>保存的，<SPAN lang="EN-US"  >MBCS</SPAN>程序如果不将其转换到<SPAN lang="EN-US"  >ANSI</SPAN>代码页，而用<SPAN lang="EN-US"  >W</SPAN>版本的函数直接显示，就不会产生乱码。例如<SPAN lang="EN-US"  >MFC</SPAN>程序菜单里的中文，在<SPAN lang="EN-US"  >English (US)</SPAN>的<SPAN lang="EN-US"  >Locale</SPAN>也可以正常显示。不过这取决于各部分代码的具体实现，<SPAN lang="EN-US"  >menu bar</SPAN>控件里的中文在<SPAN lang="EN-US"  >English (US)</SPAN>的<SPAN lang="EN-US"  >Locale</SPAN>会全部显示成<SPAN lang="EN-US"  >??</SPAN>。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >进一步的参考资料<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >本文的第<SPAN lang="EN-US"  >0</SPAN>节和附录<SPAN lang="EN-US"  >0</SPAN>主要参考了《<SPAN lang="EN-US"  >Inside Windows 2000 Third Edition</SPAN>》，国内出过该书的影印版。<SPAN lang="EN-US"  >DDK</SPAN>文档中有大量<SPAN lang="EN-US"  >Windows</SPAN>内核的信息。用<SPAN lang="EN-US"  >Win32dsm</SPAN>和各种调试器查看<SPAN lang="EN-US"  >Windows</SPAN>系统文件可以获得更直接的信息。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >关于<SPAN lang="EN-US"  >Window</SPAN>程序的字符编码，最好的参考资料是<SPAN lang="EN-US"  >winnt.h</SPAN>等<SPAN lang="EN-US"  >SDK</SPAN>的包含文件、<SPAN lang="EN-US"  >VCL</SPAN>、<SPAN lang="EN-US"  >MFC</SPAN>、<SPAN lang="EN-US"  >CRT</SPAN>的源文件。我们不需要阅读它们，只要找到自己感兴趣的信息就可以了，用<SPAN lang="EN-US"  >Source Insight</SPAN>可能方便一些。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >本文所谈的不是什么万古不迁的道理，只是别的程序员的一些设定，我们因为需要使用他们的程序，所以有必要了解一些细节。研究问题的方法和兴趣永远比问题本身重要，如一句拉丁俗语所说：<SPAN lang="EN-US"  >res, non verba</SPAN>，实质胜于文字。<SPAN lang="EN-US"  ></SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan; mso-outline-level: 3;"  align="left"  ><B><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 13.5pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >尾声<SPAN lang="EN-US"  ></SPAN></SPAN></B></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >“</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >明月虽有圆缺，但毕竟永恒不灭，人生却如过眼烟云，一去不回，真不知计较为何？<SPAN lang="EN-US"  >”</SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  lang="EN-US"  >“</SPAN><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >蛙声虽是短促，但却是万籁中一个活泼的禅机，也可以说万古如斯，永恒不迁，无奈感受到的，能有几人？<SPAN lang="EN-US"  >”</SPAN></SPAN></P>  <P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; mso-pagination: widow-orphan;"  align="left"  ><SPAN style="FONT-FAMILY: 宋体; FONT-SIZE: 12pt; mso-bidi-font-family: 宋体; mso-font-kerning: 0pt;"  >这是一本武侠书中的对话。在时间的长河中，人生和蛙声一样易逝。说到蛙声，我的<SPAN lang="EN-US"  >20</SPAN>个月的小宝宝在喝汤后，略加酝酿，就会紧闭着嘴巴，发出很像蛙鸣的声音。我们会逗他说：<SPAN lang="EN-US"  >“</SPAN>小青蛙又来了<SPAN lang="EN-US"  >”</SPAN>。小家伙益发得意，不管我的抗议，将连汤带油的小下巴亲热地贴在我的身上。</SPAN></P><WBR>
</body></html>