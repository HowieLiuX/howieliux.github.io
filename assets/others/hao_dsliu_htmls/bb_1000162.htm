<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]C语言内存管理</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]C语言内存管理</h2>
<p align="right">发布时间：2012-5-15 20:51
<br>分类名称：Debug_Crack</p><br>
<p><span style="font-family:宋体; font-size:14pt;"  ><strong>转自：http://lizzy115.blog.163.com/blog/static/364919582010111011587929/ </strong></span></p><p> &nbsp;</p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >C语言内存管理</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Batang;"  >对于一个</span><span style="font-family:Times New Roman;"  >c/c++</span><span style="font-family:Batang;"  >程序员来说，内存泄漏是一个常见的也是令人头疼的问题，为了应对这个问题，有许多技术被研究出来来解决这个问题，例如</span><span style="font-family:Times New Roman;"  >Smart Pointer</span><span style="font-family:Batang;"  >，</span><span style="font-family:Times New Roman;"  >Garbage Collection</span><span style="font-family:Batang;"  >等。一般我们常说的内存泄漏是指堆内存的泄漏。那么为什么会导致内存泄漏呢？通过学习内存管理，相信你一定能解决好这个问题。</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-1</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >C语言内存管理方式</span><span style="font-family:宋体;"  >     </span></span></strong></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在进入本专题前，我们先看一下下面的程序，来简单分析以下</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言的内存管理： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;stdio.h&gt; </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;malloc.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >//</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >全局变量定义</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >int iGlobalInt1=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >int iGlobalInt2=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >int iGlobalInt3=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//</span><span style="font-family:宋体;"  >全局常量定义 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >const int iGlobalConstInt1=1;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >const int iGlobalConstInt2=5;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >const int iGlobalConstInt3=6;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//</span><span style="font-family:宋体;"  >全局静态变量定义 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >static int iGlobalStaticInt1=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >static int iGlobalStaticInt2=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >static int iGlobalStaticInt3=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//</span><span style="font-family:宋体;"  >函数定义 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >void  funcParamTest(int iFuncParam1,int iFuncParam2,int iFuncParam3) </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{ </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >            //</span><span style="font-family:宋体;"  >函数私有变量定义 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >      int    iLocalInt1=iFuncParam1;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int    iLocalInt2=iFuncParam2;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int    iLocalInt3=iFuncParam3;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >函数参数变量内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iFuncParam1=<span style="color:#3366ff;"  >0x%08x\n</span>",&amp;iFuncParam1);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iFuncParam2=0x%08x\n",&amp;iFuncParam2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iFuncParam3=0x%08x\n\n",&amp;iFuncParam3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >函数本地变量的内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt1=0x%08x\n",&amp;iLocalInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt2=0x%08x\n",&amp;iLocalInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt3=0x%08x\n\n",&amp;iLocalInt3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return; </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >} </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >//</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >入口函数</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >int main(int argc, char* argv[])</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >局部静态变量 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;static int iStaticInt1=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;static int iStaticInt2=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;static int iStaticInt3=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >局部静态常量定义 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const static int iConstStaticInt1=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const static int iConstStaticInt2=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const static int iConstStaticInt3=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >局部常量 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const int iConstInt1=1;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const int iConstInt2=5;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;const int iConstInt3=6;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >局部变量 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int    iLocalInt1=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int    iLocalInt2=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int    iLocalInt3=0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;char  * pMalloc1,*pMalloc2,*pMalloc3;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    char  * pNew1,*pNew2,*pNew3;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >全局常量的内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalConstInt1=0x%08x\n",&amp;iGlobalConstInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalConstInt2=0x%08x\n",&amp;iGlobalConstInt2); &nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalConstInt3=0x%08x\n\n",&amp;iGlobalConstInt3);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstStaticInt1=0x%08x\n",&amp;iConstStaticInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstStaticInt2=0x%08x\n",&amp;iConstStaticInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstStaticInt3=0x%08x\n\n",&amp;iConstStaticInt3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >全局变量的内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalInt1=0x%08x\n",&amp;iGlobalInt1);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalInt2=0x%08x\n",&amp;iGlobalInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalInt3=0x%08x\n\n",&amp;iGlobalInt3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >静态变量的内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalStaticInt1=0x%08x\n",&amp;iGlobalStaticInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalStaticInt2=0x%08x\n",&amp;iGlobalStaticInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iGlobalStaticInt3=0x%08x\n\n",&amp;iGlobalStaticInt3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iStaticInt1=0x%08x\n",&amp;iStaticInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iStaticInt2=0x%08x\n",&amp;iStaticInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iStaticInt3=0x%08x\n\n",&amp;iStaticInt3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >本地变量的内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstInt1=0x%08x\n",&amp;iConstInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstInt2=0x%08x\n",&amp;iConstInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iConstInt3=0x%08x\n\n",&amp;iConstInt3);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt1=0x%08x\n",&amp;iLocalInt1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt2=0x%08x\n",&amp;iLocalInt2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("iLocalInt3=0x%08x\n\n",&amp;iLocalInt3);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;funcParamTest(iLocalInt1,iLocalInt2,iLocalInt3);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >在堆上分配内存，使用</span><span style="font-family:Times New Roman;"  >new</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew1=new char[16];</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew2=new char[16];</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew3=new char[16];</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >在堆上分配内存，使用</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc1 = (char *)malloc( 16 ); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc2 = (char *)malloc( 16 ); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc3 = (char *)malloc( 16 );  </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("</span><span style="font-family:宋体;"  >在堆上分配内存内存地址</span><span style="font-family:Courier New;"  >\n");</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("pMalloc1=0x%08x\n",pMalloc1); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("pMalloc2=0x%08x\n",pMalloc2); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;printf("pMalloc3=0x%08x\n\n",pMalloc3); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >释放</span><span style="font-family:Times New Roman;"  >new </span><span style="font-family:宋体;"  >分配的内存空间 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    delete [] pNew1;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;delete [] pNew2;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;delete [] pNew3;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew1=NULL;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew2=NULL;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;pNew3=NULL;</span><span style="font-family:宋体;"  >    </span></span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >释放</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >分配的内存空间 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;free(pMalloc1);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;free(pMalloc2);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;free(pMalloc3);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc1=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc2=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;pMalloc3=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return 0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >本程序在</span><span style="font-family:Times New Roman;"  >Windows XP </span><span style="font-family:宋体;"  >下，</span><span style="font-family:Times New Roman;"  >VC6</span><span style="font-family:宋体;"  >编译后的执行结果是： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >注</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >意，上面我们输出的完全是内存地址，也就是说，是程序在进程中内存地址（注意是虚拟内存地址而不是物理内存地址）。我们认真观察程序输出，发现每种类型的</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >内存地址都是连续的，而不同类型之间内存地址有的是连续的，有的差别极大（注意：不同编译器可能输出的结果不一样，但这并不影响我们分析问题）。基本上，</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >我们可以把这些地址范围分为如下几个部分：<span style="color:blue;"  >堆、栈、全局</span></span><span style="font-family:Times New Roman;"  >/</span><span style="color:blue; font-family:宋体;"  >静态存储区和常量存储区<span style="color:#3366ff;"  >。</span>    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >栈，就是那些由编译器在需要的时候分配，在不需要的时候自动释放的存储区</span>。<span style="color:blue;"  >里面的变量通常是局部变量、函数参数等</span>。<span style="color:blue;"  >在栈上分配内存，通常是指在执行函数时，函数内局部变量在栈上创建，函数执行结束时这被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</span>   </span></p><p><span style="font-size:12pt;"  ><span style="color:blue;"  ><span style="font-family:宋体;"  >堆，就是那些由</span><span style="font-family:Times New Roman;"  >new</span><span style="font-family:宋体;"  >或使用</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个</span><span style="font-family:Times New Roman;"  >new/malloc</span><span style="font-family:宋体;"  >就要对应一个</span><span style="font-family:Times New Roman;"  >delete/free</span><span style="font-family:宋体;"  >。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。动态内存的生存期由我们决定，使用非常灵活，但</span></span><span style="font-family:宋体;"  >问题最多，也是我们本章讨论的重点。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >全局</span><span style="font-family:Times New Roman;"  >/</span><span style="font-family:宋体;"  >静态存储区，<span style="color:blue;"  >全局变量和静态变量被分配到同一块内存中</span>，在以前的</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言中，全局变量又分为初始化的和未初始化的，在</span><span style="font-family:Times New Roman;"  >C++</span><span style="font-family:宋体;"  >里面没有这个区分了，他们共同占用同一块内存区。<span style="color:blue;"  >静态存储区在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。</span>    </span></span></p><p><span style="font-size:12pt;"  ><span style="color:blue; font-family:宋体;"  >常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改</span><span style="font-family:宋体;"  >（通过特殊手段当然是可以修改的，例如</span><span style="color:blue;"  ><span style="font-family:Times New Roman;"  >Windows</span><span style="font-family:宋体;"  >下可直接修改</span><span style="font-family:Times New Roman;"  >PE</span><span style="font-family:宋体;"  >文件</span></span><span style="font-family:宋体;"  >）。 </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >通过分析上面的程序，我们大抵可以绘出程序内存分配情况 </span></p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >… …</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="color:black; font-family:宋体; font-size:9pt;"  >栈</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >… …</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >代码区</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >静态数据区</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >低端内存区域</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >高端内存区域</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >… …</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >常量存储区</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >堆</span></p></td></tr></table></div><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 1 </span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >通过上面分析，我们知道，<span style="color:blue;"  >全局常量（例如</span></span><span style="font-family:Times New Roman;"  >iGlobalConstInt1</span><span style="color:blue;"  ><span style="font-family:宋体;"  >）和局部静态常量（例如</span><span style="font-family:Times New Roman;"  >iConstStaticInt1</span><span style="font-family:宋体;"  >）位于<span style="color:red;"  >常量存储区<span style="color:blue;"  >；全局变量（例如</span></span></span><span style="font-family:Times New Roman;"  >iGlobalInt1</span><span style="font-family:宋体;"  >）和局部静态变量（</span><span style="font-family:Times New Roman;"  >iStaticInt1</span><span style="font-family:宋体;"  >）位于<span style="color:red;"  >静态数据区</span>；本地变量（例如</span><span style="font-family:Times New Roman;"  >iLocalInt1</span><span style="font-family:宋体;"  >）和函数参数变量（例如</span><span style="font-family:Times New Roman;"  >iFuncParam1</span><span style="font-family:宋体;"  >）位于<span style="color:red;"  >栈<span style="color:blue;"  >区，它是动态存储区的一部分；使用</span></span></span><span style="font-family:Times New Roman;"  >malloc/new</span><span style="font-family:宋体;"  >（例如</span><span style="font-family:Times New Roman;"  >pMalloc1</span><span style="font-family:宋体;"  >，</span><span style="font-family:Times New Roman;"  >pNew1</span><span style="font-family:宋体;"  >）分配的内存位于<span style="color:red;"  >堆<span style="color:blue;"  >区，它也是动态存储区的一部分。</span>      </span></span></span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >由于常量存储区和静态数据区都是在程序编译的时候就分配好空间了，而堆栈是在程序运行过程中自动分配好的空间。使用堆分配内存是显式分配的，我们在稍后详细介绍。下面简单介绍一下使用栈分配内存空间的原理。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >我们来看看我们</span><span style="font-family:Times New Roman;"  >DEMO</span><span style="font-family:宋体;"  >程序对于函数参数那一部分，我们发现，栈分配如下所示 </span></span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >… …</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >iLocalInt2 = 0x0012ff3c</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >iLocalInt3 = 0x0012ff40</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >RET</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >iFuncParam2 = 0x0012ff4c</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >低端内存区域</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:宋体; font-size:12pt;"  >高端内存区域</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >… …</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >iFuncParam1 = 0x0012ff48</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-family:Times New Roman; font-size:12pt;"  >iFuncParam3 = 0x0012ff50</span></p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:576px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="border-top:  none; border-left:  none; border-bottom:  none; border-right:  none;"  ><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >iLocalInt1 = 0x0012ff38</span><span style="font-family:宋体;"  >         </span></span></p><p><span style="font-family:Times New Roman; font-size:12pt;"  >&nbsp;</span>&nbsp;</p></td></tr></table></div><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 2 </span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >我们发现函数参数地址和变量地址分布如上，其中多了四个字节，正好就是</span><span style="font-family:Times New Roman;"  >RET</span><span style="font-family:宋体;"  >指令。首先，<span style="color:red;"  >三个参数以从右到左的次序压入堆栈</span>，先压"</span><span style="font-family:Times New Roman;"  >iFuncParam3</span><span style="font-family:宋体;"  >"，再压"</span><span style="font-family:Times New Roman;"  >iFuncParam2</span><span style="font-family:宋体;"  >"，最后压入"</span><span style="font-family:Times New Roman;"  >iFuncParam1</span><span style="font-family:宋体;"  >"；<span style="color:red;"  >然后压入函数的返回地址</span></span><span style="font-family:Times New Roman;"  >(RET)</span><span style="font-family:宋体;"  >，<span style="color:red;"  >接着跳转到函数地址接着执行</span>。第三步，将栈顶</span><span style="font-family:Times New Roman;"  >(ESP)</span><span style="font-family:宋体;"  >减去一个数，为本地变量分配内存空间，接着就初始化本地变量的内存空间。感兴趣的读者可以使用工具反汇编上面的代码，然后就可以看到</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言是如何编译的了。 </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >从上面我们可以看出，对于栈分配内存而言，是由编译器自动管理，无需我们手工控制。然而，对于堆而言，内存分配与释放由程序员控制了，方法非常灵活，但也最容易出现问题。 </span></p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-2</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >C语言内存管理</span><span style="font-family:宋体;"  >     </span></span></strong></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >上一节中我们简单分析了</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言内存管理方式，其中对于堆的管理，我们仅进行了简单描述。在本节中我们要详细描述</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言内存管理。在介绍之前，我们需要先熟悉</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言堆内存管理涉及的函数。 </span></span></p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 3</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  ><strong>_alloca</strong></span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void * alloca( size_t size );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >的作用分配一块大小为</span><span style="font-family:Times New Roman;"  >size</span><span style="font-family:宋体;"  >个字节的可用内存块，并返回首地址。不能分配的时候返回</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。</span><span style="color:red;"  ><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >是从栈中分配内存空间</span></span><span style="font-family:宋体;"  >，使用</span><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >分配内存后不必使用</span><span style="font-family:Times New Roman;"  >free</span><span style="font-family:宋体;"  >来释放内存。</span><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >是分配一块未经初始化的内存，这和</span><span style="font-family:Times New Roman;"  > malloc </span><span style="font-family:宋体;"  >一样，如果需要初始化可以调用</span><span style="font-family:Times New Roman;"  > memset </span><span style="font-family:宋体;"  >函数。在上节中，我们已经对栈分配做了详细的描述，栈的释放是由编译器自动管理的，所以不需要我们手动去释放它。 </span></span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >示范代码如下： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;stdio.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;malloc.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >int main()</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    int     size = 1000;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    int     errcode = 0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    void    *pData = NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >    if (size &gt; 0 &amp;&amp; size &lt; 1024)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    {</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >         pData = alloca( size );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >         </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    printf_s( "Allocated %d bytes of stack at <span style="color:red;"  >0x%p"</span>,size, pData);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}else{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    printf_s( "Allocated %d bytes of stack failed",size);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    }else{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >         printf_s("Tried to allocate too many bytes.\n");        </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    }</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 4</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><strong><span style="font-family:Times New Roman;"  >malloc </span><span style="font-family:宋体;"  >与</span><span style="font-family:Times New Roman;"  > free</span></strong><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >void * malloc( size_t size );    </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >void    free( void *ptr );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >的作用分配一块大小为</span><span style="font-family:Times New Roman;"  >size</span><span style="font-family:宋体;"  >个字节的可用内存块，并返回首地址。不能分配的时候返回</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。</span><span style="font-family:Times New Roman;"  >malloc </span><span style="font-family:宋体;"  >是从堆中分配内存空间，使用</span><span style="font-family:Times New Roman;"  >malloc </span><span style="font-family:宋体;"  >分配内存后必须使用</span><span style="font-family:Times New Roman;"  >free</span><span style="font-family:宋体;"  >释放内存。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >free</span><span style="font-family:宋体;"  >清除</span><span style="font-family:Times New Roman;"  >ptr</span><span style="font-family:宋体;"  >所指向的地址，它只作清除的工作，并告诉系统，这块地址已经被释放和清除，可以重新被分配。使用</span><span style="color:red;"  ><span style="font-family:Times New Roman;"  >malloc </span><span style="font-family:宋体;"  >分配的内存没有进行初始化</span></span><span style="font-family:宋体;"  >，也就是说，该内存区中可能存在先前内容，而</span><span style="color:red;"  ><span style="font-family:Times New Roman;"  >calloc </span><span style="font-family:宋体;"  >则将内存初始化为</span><span style="font-family:Times New Roman;"  >0</span></span><span style="font-family:宋体;"  >。如果需要对</span><span style="font-family:Times New Roman;"  >malloc </span><span style="font-family:宋体;"  >分配的内存初始化，可以使用</span><span style="font-family:Times New Roman;"  >memset </span><span style="font-family:宋体;"  >函数。 </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >示范代码如下： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;stdlib.h&gt;         /* For _MAX_PATH definition */</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;stdio.h&gt;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;malloc.h&gt;</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >void main( void )</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >{</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   char *string;</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   /* Allocate space for a path name */</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   string = malloc( _MAX_PATH );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   // In a C++ file, explicitly cast malloc's return.  For example, </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   // string = (char *)malloc( _MAX_PATH );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      printf( "Insufficient memory available\n" );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   else</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   {</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      printf( "Memory space allocated for path name\n" );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      free( string );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      printf( "Memory freed\n" );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   }</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >}</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 5</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  ><strong>calloc</strong></span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void * calloc( size_t </span><span style="font-family:Verdana; font-size:9pt;"  >nmemb</span><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >，</span><span style="font-family:Courier New;"  >size_t </span></span><span style="font-family:Verdana; font-size:9pt;"  >size</span><span style="font-family:Courier New; font-size:10pt;"  >)</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >；</span><span style="font-size:12pt;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >的作用是分配并初始化内存块，返回一个指向</span><span style="font-family:Times New Roman;"  >nmemb</span><span style="font-family:宋体;"  >块数组的指针，每块大小为</span><span style="font-family:Times New Roman;"  >size</span><span style="font-family:宋体;"  >个字节。它和</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >的主要不同之处是会初始化（清零）分配到的内存。 </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >示范代码如下： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;stdio.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;malloc.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void main( void )</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   long *buffer;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >   buffer = (long *)calloc( 40, sizeof( long ) );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >      printf( "Allocated 40 long integers\n" );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   else</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >      printf( "Can't allocate memory\n" );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    <span style="color:red;"  >free</span>( buffer );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 6</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  ><strong>Realloc</strong></span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void * realloc( void *ptr, size_t size );</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >以</span><span style="font-family:Times New Roman;"  >ptr</span><span style="font-family:宋体;"  >所指地址为首址，分配</span><span style="font-family:Times New Roman;"  >size</span><span style="font-family:宋体;"  >个字节的内存，并返回</span><span style="font-family:Times New Roman;"  >ptr</span><span style="font-family:宋体;"  >所指地址。</span><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >不会初始化分配到的内存块，如果</span><span style="font-family:Times New Roman;"  >ptr</span><span style="font-family:宋体;"  >为</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >则相当于</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >，如果</span><span style="font-family:Times New Roman;"  >size</span><span style="font-family:宋体;"  >为</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >则相当于</span><span style="font-family:Times New Roman;"  >free(ptr)</span><span style="font-family:宋体;"  >。不能分配返回</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。 </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >示范代码如下： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;stdio.h&gt;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;malloc.h&gt;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >#include &lt;stdlib.h&gt;</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >void main( void )</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >{</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   long *buffer;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   size_t size;</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   malloc( 1000 * sizeof( long ) )) == NULL )</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      exit( 1 );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   size = _msize( buffer );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   printf( "Size of block after malloc of 1000 longs: %u\n", size );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   /* Reallocate and show new size: */</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   ) )) </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >        ==  NULL )</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >      exit( 1 );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   size = _msize( buffer );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   printf( "Size of block after realloc of 1000 more longs: %u\n", </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >            size );</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >     <span style="color:red;"  > free</span>( buffer );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >   exit( 0 );</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >}</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 7</span><span style="font-size:24pt;"  >     </span></strong></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >通过上面的学习，<span style="color:red;"  >我们知道：</span></span><span style="font-family:Times New Roman;"  >alloca</span><span style="color:red;"  ><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >realloc </span><span style="font-family:宋体;"  >负责分配内存，</span><span style="font-family:Times New Roman;"  >free </span><span style="font-family:宋体;"  >负责释放内存。其中</span><span style="font-family:Times New Roman;"  > alloca </span><span style="font-family:宋体;"  >是在栈中分配内存，而</span><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >realloc </span><span style="font-family:宋体;"  >是在堆中分配内存，也就是说</span><span style="font-family:Times New Roman;"  > alloca </span><span style="font-family:宋体;"  >的内存分配，是有作用域的，不需要释放，而</span><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >内存是没有作用域的，需要调用</span><span style="font-family:Times New Roman;"  > free </span><span style="font-family:宋体;"  >主动释放分配内存区域。</span><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >，</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >，</span><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >只负责分配内存，并不初始化分配内存空间，而</span><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >不仅分配内存，还负责初始化分配内存为</span><span style="font-family:Times New Roman;"  >0</span><span style="font-family:宋体;"  >。</span><span style="font-family:Times New Roman;"  >realloc </span><span style="font-family:宋体;"  >是以传入指针为基址，分配指定大小的内存区域。</span></span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >当读者阅读到此时的时候，可能觉得内存管理其实很简单，无非是分配内存释放内存而已。大家不妨看看如下一个程序： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void MyGetMemory(int iSize)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;char * szTemp=(char *)malloc(iSize);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("getstring failed!\n");<span style="color:red;"  >//</span></span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >应该在分配失败后也释放内存</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;...</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;free(szTemp);&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="color:red;"  ><span style="font-family:宋体;"  >相信大家能很快发现上面在</span><span style="font-family:Times New Roman;"  >GetString </span><span style="font-family:宋体;"  >函数返回失败的情况下，内存没有释放，将产生内存泄露。</span></span><span style="font-family:宋体;"  >如果我们再更改一下，可能这个错误稍微隐蔽一点。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >char * MyGetMemory(int iSize)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;char * szTemp=(char *)malloc(iSize);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("getstring failed!\n");</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return szTemp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void Test()</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;char * szMalloc=MyGetMemory(23);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("out : %s \n",szMalloc);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(szMalloc);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;szMalloc=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >这个程序的内存泄露同样是在</span><span style="font-family:Times New Roman;"  >GetString </span><span style="font-family:宋体;"  >失败的时候产生，我们单存分析</span><span style="font-family:Times New Roman;"  >Test </span><span style="font-family:宋体;"  >函</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >数是发现不了内存泄露的。在实际项目中，由于较为复杂，可能忘记释放内容了，也有可能释放内容后再次释放内容等等，这些错误要么是程序运行时间越久，所耗</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >内存越大，要么直接出现异常。如果分配了内存忘记释放，那样就产生了内存泄漏。为了防止内存泄漏，一些项目甚至要求对分配、释放内存进行跟踪，以避免内存</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >泄漏。<span style="color:red;"  >最简单的方法就是封装内存分配和释放函数，实际分配中并不直接调用</span></span><span style="font-family:Times New Roman;"  >alloca</span><span style="color:red;"  ><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >calloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >来分配内存，也不直接调用函数</span><span style="font-family:Times New Roman;"  >free</span><span style="font-family:宋体;"  >来释放内存。另外，在服务器上，由于程序需要长期执行，频繁的分配内存资源会导致内存碎片的增多，这样可以使用内存池来解决这些问题。</span></span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >既然内存管理错误这么频繁，后果这么严重，那么作为一个新手程序应该如何来避免这些问题呢？在下一节我们将详细介绍。 </span></p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-3</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >C语言内存使用要点及常见错误</span><span style="font-family:宋体;"  >     </span></span></strong></p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在介绍内存使用要点之前，我们先看看使用</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言内存管理中经常出现的错误，尤其是新手。 </span></span></p><p><span style="font-family:宋体;"  ><strong><span style="font-size:12pt;"  >label 8</span><span style="font-size:24pt;"  >     </span></strong></span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >内存分配后没有校验，使得内存未成功，却正常使用。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >内存分配成功后，没有初始化就使用。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >3</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >内存分配成功，也进行了初始化，可是使用内存时出现了越界（缓冲区溢出）。这种错误如果被黑客成功利用，最严重的后果就是整个操作系统被黑客完全控制。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >4</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >内存分配成功后，忘记释放内存，产生内存泄漏。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >5</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >内存分配成功后，也正常释放内存，可是在释放内存后又继续使用。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 23pt;"  ><span style="color:red;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >6</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >混淆指针和数组。</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >上面的这些问题，不仅仅是新手容易犯，一个工作多年的老程序员依然可能犯这样的错误。如果有一天，您发现您的程序在</span><span style="font-family:Times New Roman;"  >debug</span><span style="font-family:宋体;"  >下可以成功运行，可是在</span><span style="font-family:Times New Roman;"  >release</span><span style="font-family:宋体;"  >下却不能成功运行，一种可能就是您的数据没有被初始化。如果有一天，您的程序出现一个访问一个非常内存地址的错误，那么你应该检查一下是否产生了越界错误等等。总而言之，上面的任何一种错误出现了，就极有可能不好定位错误，尤其是访问越界、释放后继续使用的错误。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >内存分配后不校验直接使用主要是新手犯这种错误，由于没有意识到内存分配会不成功。这种问题的解决办法很简单，判断指针是否为空就可以了，在上节中的例子比比皆是，就不列举出来了。另外一种情况是函数的入参为空，可以使用</span><span style="font-family:Times New Roman;"  >assert(p!=NULL) </span><span style="font-family:宋体;"  >来简单检查，也可以使用</span><span style="font-family:Times New Roman;"  > </span><span style="font-family:宋体;"  >来判断。这类错误只要养成好习惯，是完全可以避免的。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >内存分配后没有初始化，这种情况也是属于粗心引起，也通常是新手犯的错误。从上节中我们知道，</span><span style="font-family:Times New Roman;"  >alloca</span><span style="font-family:宋体;"  >，</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >，</span><span style="font-family:Times New Roman;"  >realloc</span><span style="font-family:宋体;"  >是</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >只负责分配内存而不负责初始化内存的，完全可以想象，不初始化直接使用会导致不可预知的错误。其实，内存没有初始化是出现所有内存分配的情况下，可能是全</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >局的，也有可能出现在栈上，当然更多是出现在堆分配上。比如如下的例子就是一个堆分配后没有初始化出现的错误，其实在实际项目中，肯定没有这么明显，中途</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >隔了很多代码，所以往往不容易发现。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >int iTimes;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >for(iTimes=0;iTimes&lt;20;iTimes++)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >While(iTimes&gt;0)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >…</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >iTimes--;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >后来由于程序需要我们注释掉了那段</span><span style="font-family:Times New Roman;"  >for</span><span style="font-family:宋体;"  >循环，结果变成了 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >int iTimes;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >/*</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >for(iTimes=0;iTimes&lt;20;iTimes++)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >}*/</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >While(iTimes&gt;0)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >…</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >iTimes--;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >当然上面的错误实在是太明显了。实际上这种例子主要是修改了程序的某个逻辑后才出现的，尤其是删出逻辑后。比如在</span><span style="font-family:Times New Roman;"  >c++</span><span style="font-family:宋体;"  >类的构造删除中没有初始化成员指针变量，我们先前必须调用该类的某个函数来分配并初始化，可是后来我们去掉了这个函数，而我们在析构函数中还保留着该指针的释放，这样当然会导致错误。总之，不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >访问内存越界错误可以说是一类非常严重的错误，因为这种错误非常难找。黑客也通常利用这种漏洞来入侵系统。这种错误出现几率最常见的就是文件路径，我们可能想当然的认为文件名不会超过</span><span style="font-family:Times New Roman;"  >255</span><span style="font-family:宋体;"  >，因为是我们自己的文件名，认为完全可以控制，可是由于种种原因我们的文件名大于了</span><span style="font-family:Times New Roman;"  >255</span><span style="font-family:宋体;"  >，那么会产生什么样的错误呢？由于我们的文件名需要使用</span><span style="font-family:Times New Roman;"  >memcpy</span><span style="font-family:宋体;"  >复制内容，那么有可能我们的一部份代码数据可能被覆盖了，会出现什么错误只有天知道，尤其是每次的执行流程未知，产生的后果每次都不一样，这样的错误通常是很难定位的。鉴于此，微软在</span><span style="font-family:Times New Roman;"  >vc2005</span><span style="font-family:宋体;"  >中增加了一系列</span><span style="font-family:Times New Roman;"  >_l</span><span style="font-family:宋体;"  >的函数，例如</span><span style="font-family:Times New Roman;"  >_sprintf_l </span><span style="font-family:宋体;"  >增加了缓冲区长度，以减少这类问题。也就是说，对于程序员，无论是新手还是老手，在使用内存拷贝等情况下一定要考虑越界问题。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >常用解决办法是，<span style="color:red;"  >在使用内存之前检查指针是否为</span></span><span style="font-family:Times New Roman;"  >NULL</span><span style="color:red;"  ><span style="font-family:宋体;"  >。如果指针</span><span style="font-family:Times New Roman;"  >p</span><span style="font-family:宋体;"  >是函数的参数，那么在函数的入口处用</span><span style="font-family:Times New Roman;"  >assert(p!=NULL)</span><span style="font-family:宋体;"  >进行检查。如果是用</span><span style="font-family:Times New Roman;"  >malloc</span><span style="font-family:宋体;"  >或</span><span style="font-family:Times New Roman;"  >new</span><span style="font-family:宋体;"  >来申请内存，应该用</span><span style="font-family:Times New Roman;"  > </span><span style="font-family:宋体;"  >或</span><span style="font-family:Times New Roman;"  ></span><span style="font-family:宋体;"  >进行防错处理。</span></span><span style="font-family:宋体;"  >    </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >对于忘记释放内存的问题，也是一个比较热门的话题。出现这种情况的后果是，所占内存越来越大，系统越来越慢。尤其是对于服务器程序，由于需要长时间运行，所以内存泄漏就变得非常重要了。所以我们在程序设计时一定要保证</span><span style="font-family:Times New Roman;"  >malloc/free</span><span style="font-family:宋体;"  >、</span><span style="font-family:Times New Roman;"  >new/delete</span><span style="font-family:宋体;"  >成对使用。这类问题还有可能出现在函数中分配内存的场合。例子如下： </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void getpathname(char * szPath)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 11pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 11pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >    szPath=(char *)malloc(1024);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 11pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >memcpy(szPath,"mycopybuffer",11);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void callf()</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   char * szPath;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   szPath=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   getpathname (szPath);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 22pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >   Free(szPath);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 22pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >   szPath=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >对于上面这个例子，曾经有人还说过，我分配了，也释放了，可是就是有内存泄漏。不过更多的情况是发现数据不正确，还不知道怎么回事，其实就是对指针理解不够<span style="color:red;"  >。对于上面的例子，解决办法通常有三个，一是直接返回指针，二是传入</span></span><span style="font-family:Times New Roman;"  > char **</span><span style="color:red;"  ><span style="font-family:宋体;"  >，三是如果是</span><span style="font-family:Times New Roman;"  >c++</span><span style="font-family:宋体;"  >可以传入</span><span style="font-family:Times New Roman;"  > char * &amp;</span><span style="font-family:宋体;"  >。另外，需要避免数组或指针的下标越界，特别要当心发生"多</span><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >"或者"少</span><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >"操作。</span></span><span style="font-family:宋体;"  >    </span></span></p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >释放后继续使用内存指针的问题也是一个非常严重的问题，如果加上逻辑复杂，测试不能遍历所有路径的话，极有可能成为一个小</span><span style="font-family:Times New Roman;"  >BUG</span><span style="font-family:宋体;"  >。那么出现这种问题有哪些情况呢？ </span></span></p><p style="margin-left: 23pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >程序逻辑异常复杂，释放之后并没有将所有指向这块内存区域的指针清</span><span style="font-family:Times New Roman;"  >0</span><span style="font-family:宋体;"  >。 </span></span></p><p style="margin-left: 23pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >在函数中返回了栈内存的指针或引用。 </span></p><p style="margin-left: 23pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >3</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >使用</span><span style="font-family:Times New Roman;"  >free</span><span style="font-family:宋体;"  >或</span><span style="font-family:Times New Roman;"  >delete</span><span style="font-family:宋体;"  >释放了内存后，没有将指针设置为</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >，导致产生"野指针"。还有就是存在多个这向该内存的指针，释放时没有将所有指向该内存地址的指针设置为</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >程序逻辑异常的例子不太好找，但最容易理解。避免这类情况的方法就是尽量避免多个指针同时指向一个内存地址空间。如果的确不可避免，一定要在释放内存后，将所有指向该地址的指针都设置成</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。 </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-family:宋体; font-size:12pt;"  >函数种返回了栈内存地址或引用这个例子比较容易理解。如下： </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >char * GetTemp()</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >char szTemp[]="hello";</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >return szTemp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在上面的例子中，<span style="color:red;"  >由于</span></span><span style="font-family:Times New Roman;"  >szTemp</span><span style="color:red;"  ><span style="font-family:宋体;"  >属于栈内分配内存，在函数执行完成后，将自动释放</span><span style="font-family:Times New Roman;"  >szTemp</span><span style="font-family:宋体;"  >分配的栈内存，所以调用</span><span style="font-family:Times New Roman;"  >GetTemp </span><span style="font-family:宋体;"  >函数取得的指针指向内存地址是一个无效地址，该内存中存储内容是不可预见的。</span></span><span style="font-family:宋体;"  >    </span></span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><span style="font-family:宋体; font-size:12pt;"  >使用"野指针"的例子比较好理解。如下： </span></p><p style="margin-left: 5pt;"  >&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void test()</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >char * pTemp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >pTemp = (char *) malloc(256);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >strcpy(pTemp,"mytemp1");</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >printf("%s\n",pTemp);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >free(pTemp);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  ></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >         strcpy(pTemp,"mytemp2");</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >printf("%s\n",pTemp);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >上面的例子在</span><span style="font-family:Times New Roman;"  > strcpy(pTemp,"mytemp2"); </span><span style="font-family:宋体;"  >就会出错，因为此时内存已经释放了。我们上面的例子非常容易察觉这个问题。可是我们在实际工程项目中，由于代码量大，程序非常复杂，如果不养成一中良好的习惯，极有可能会出现上面的问题，而且还不太好定位。有人也许会说，我检查下</span><span style="font-family:Times New Roman;"  > free</span><span style="font-family:宋体;"  >函数不就可以了么。关键的问题是，那是您知道是没有将这个指针在释放时设置为</span><span style="font-family:Times New Roman;"  > NULL</span><span style="font-family:宋体;"  >。那么我们在实际项目中，如何杜绝"野指针"呢？</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、指针变量必须进行初始化。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >char *p = NULL;</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >char *str = (char *) malloc(100);</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、指针被释放以后，必须将所有指向该块内存区域的指针全部设置为</span><span style="font-family:Times New Roman;"  >NULL</span><span style="font-family:宋体;"  >。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >3</span><span style="font-family:宋体;"  >、指针指向的内容是栈分配的内存时，一定要注意作用域的问题。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void Test(void)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >　</span><span style="font-family:Courier New;"  > char * p;</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >   p=NULL;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >　</span><span style="font-family:Courier New;"  > {</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >　</span><span style="font-family:Courier New;"  >   char szTemp[] ="hello";</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >     p=szTemp; // </span><span style="font-family:宋体;"  >注意</span><span style="font-family:Courier New;"  > szTemp </span></span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >的生命期</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >　</span><span style="font-family:Courier New;"  >}</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:宋体;"  >　</span><span style="font-family:Courier New;"  >printf("%s\n", p); // p</span><span style="font-family:宋体;"  >是</span><span style="font-family:Courier New;"  >"</span><span style="font-family:宋体;"  >野指针</span><span style="font-family:Courier New;"  >"</span></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >另</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >外，由于指针和数组在很多情况下可以互换，导致混淆，容易犯一些小小的错误。其实，数组要么在静态存储区被创建，要么在栈上被创建。数组名对应着（而不是</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >指向）一块内存，其地址与容量在生命期内保持不变，只有内容可以改变。指针可以随时指向任意类型的内存块，它的特征是"可变"，所以我们常用指针来操作动</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >态内存。指针远比数组灵活，但也更危险。下面列举几种容易出错的例子。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >例</span><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >： </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >char arr[] = "demo";</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >arr[0] = 'W';</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >cout &lt;&lt; arr &lt;&lt; endl;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >char *pPointer = "microsoft"; // </span><span style="font-family:宋体;"  >注意</span><span style="font-family:Courier New;"  >pPointer</span></span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >指向常量字符串</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >pPointer[0] = 'w'; // </span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >编译器不能发现该错误</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >cout &lt;&lt; pPointer &lt;&lt; endl;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在上面的例子我们可以发现，数组内容是可以修改的，</span><span style="font-family:Times New Roman;"  >arr[0] = 'W'; </span><span style="font-family:宋体;"  >该句能够正常执行。而</span><span style="font-family:Times New Roman;"  >pPointer </span><span style="font-family:宋体;"  >指向的为一个常量字符串，内容是不可以修改的。</span><span style="font-family:Times New Roman;"  >pPointer[0] = 'w'; </span><span style="font-family:宋体;"  >这句在实际运行中则会导致运行错误，而编译时不能发现这个错误。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >例</span><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >： </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >char arr[] = "demodemo";</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >char *pointer = arr;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >cout&lt;&lt; sizeof(arr) &lt;&lt; endl; // </span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >8字节</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >cout&lt;&lt; sizeof(pointer) &lt;&lt; endl; // 4</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >字节</span><span style="font-size:12pt;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="color:red;"  ><span style="font-family:宋体;"  >从上面的例子中可以看出</span><span style="font-family:Times New Roman;"  >sizeof</span><span style="font-family:宋体;"  >可以计算出数组的容量（字节数），而不能计算出指针的容量，除非您在分配内存的时候记住它。</span></span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-4</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >在Windows 下如何跟踪内存泄露</span><span style="font-family:宋体;"  >     </span></span></strong></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >通过上面章节的学习，我们对内存泄露深恶痛绝，那么如何检查一个程序的内存泄露呢？先介绍一个最简单的方法就是使用</span><span style="font-family:Times New Roman;"  >VC </span><span style="font-family:宋体;"  >调式工具。首先我们来故意产生内存泄露。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、我们创建一个</span><span style="font-family:Times New Roman;"  >memleak</span><span style="font-family:宋体;"  >的支持</span><span style="font-family:Times New Roman;"  >MFC</span><span style="font-family:宋体;"  >的工程，工程类型为</span><span style="font-family:Times New Roman;"  > win32 Console Application</span><span style="font-family:宋体;"  >，如图所示，并单击"</span><span style="font-family:Times New Roman;"  >OK</span><span style="font-family:宋体;"  >"按钮。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、在接下来的项目中我们选择"</span><span style="font-family:Times New Roman;"  >An application that supports MFC.</span><span style="font-family:宋体;"  >"选择支持</span><span style="font-family:Times New Roman;"  >MFC</span><span style="font-family:宋体;"  >的控制台程序。并单击"</span><span style="font-family:Times New Roman;"  >Finish</span><span style="font-family:宋体;"  >"。 </span></span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >3</span><span style="font-family:宋体;"  >、在接下来的界面中单击"</span><span style="font-family:Times New Roman;"  >ok</span><span style="font-family:宋体;"  >"按钮完成工程创建。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >我们修改</span><span style="font-family:Times New Roman;"  >memleak.cpp</span><span style="font-family:宋体;"  >，程序如下： </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include "stdafx.h"</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include "memleak.h"</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _DEBUG</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#define new DEBUG_NEW</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#undef THIS_FILE</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >static char THIS_FILE[] = __FILE__;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >/////////////////////////////////////////////////////////////////////////////</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >// The one and only application object</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >CWinApp theApp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >using namespace std;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//</span><span style="font-family:宋体;"  >故意产生内存泄露的函数 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>void memleaktest()</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>{</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>&nbsp;&nbsp;&nbsp;&nbsp;char * szTemp= new char[1024];</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>&nbsp;&nbsp;&nbsp;&nbsp;szTemp=(char *)malloc(1024);</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>}</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >int _tmain(int argc, TCHAR* argv[], TCHAR* envp[])</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int nRetCode = 0;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;// initialize MFC and print and error on failure</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: change error code to suit your needs</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; _T("Fatal Error: MFC initialization failed") &lt;&lt; endl;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nRetCode = 1;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;else</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// TODO: code your application's behavior here.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CString strHello;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strHello.LoadString(IDS_HELLO);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; (LPCTSTR)strHello &lt;&lt; endl;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>     &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >    //</span><span style="font-family:宋体;"  >调用故意产生内存泄露的函数 </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    <strong>memleaktest();</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return nRetCode;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >此时，我们按</span><span style="font-family:Times New Roman;"  >F5</span><span style="font-family:宋体;"  >，系统会问是否需要编译，选择是以后，执行程序。我们需要注意程序调试输出部分。如果您的</span><span style="font-family:Times New Roman;"  >VC</span><span style="font-family:宋体;"  >没有输出，不仿在菜单栏上右键选择"</span><span style="font-family:Times New Roman;"  >output</span><span style="font-family:宋体;"  >"。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >读者已经从上面图中的输出部分看到： </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Detected memory leaks!</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Dumping objects -&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >F:\2008\07\prj\memleak\memleak.cpp(22) : {60} normal block at 0x00386F08, 1024 bytes long.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  > Data: &lt;                &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Object dump complete.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >我们发现了</span><span style="font-family:Times New Roman;"  >VC</span><span style="font-family:宋体;"  >探测出了内存泄露，此时我们点击行： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >F:\2008\07\prj\memleak\memleak.cpp(22) : {60} normal block at 0x00386F08</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >则出现我们产生内存泄露的详细地方。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >也许朋友会问，这是怎么实现的呢？我们不仿来分析以下代码，大家一定要注意如下代码 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _DEBUG</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#define new DEBUG_NEW</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#undef THIS_FILE</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >static char THIS_FILE[] = __FILE__;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在</span><span style="font-family:Times New Roman;"  >debug</span><span style="font-family:宋体;"  >状态下，我们使用</span><span style="font-family:Times New Roman;"  >new</span><span style="font-family:宋体;"  >分配内存的时候，实际上会调用</span><span style="font-family:Times New Roman;"  > DEBUG_NEW</span><span style="font-family:宋体;"  >，该宏是怎么定义的呢？在</span><span style="font-family:Times New Roman;"  > Afx.h</span><span style="font-family:宋体;"  >中我们找到了它的定义 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//Afx.h</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >// Memory tracking allocation</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>#define DEBUG_NEW new(THIS_FILE, __LINE__)</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#if _MSC_VER &gt;= 1200</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在</span><span style="font-family:Times New Roman;"  >Afxmem.cpp</span><span style="font-family:宋体;"  >中我们找到了函数定义，如下： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >//afxmem.cpp</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >{</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >&nbsp;&nbsp;&nbsp;&nbsp;return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >}</span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _DEBUG</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _AFX_NO_DEBUG_CRT</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;UNUSED_ALWAYS(nType);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;UNUSED_ALWAYS(lpszFileName);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;UNUSED_ALWAYS(nLine);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return ::operator new(nSize);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#else</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;void* pResult;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _AFXDLL</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;_PNH pfnNewHandler = _pfnUninitialized;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;for (;;)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pResult != NULL)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pResult;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifdef _AFXDLL</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pfnNewHandler == _pfnUninitialized)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfnNewHandler = pState-&gt;m_pfnNewHandler;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pfnNewHandler == NULL || (*pfnNewHandler)(nSize) == 0)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#else</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_afxNewHandler == NULL || (*_afxNewHandler)(nSize) == 0)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;return pResult;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif //_DEBUG</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >鉴于本章的主旨，我们不再继续分析下去，不过我们知道了</span><span style="font-family:Times New Roman;"  >VC6.0 </span><span style="font-family:宋体;"  >大抵是如何跟踪内存泄露的。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >上面分析内存泄露的方法是常见手段，一般程序员都必须掌握的。下面再介绍一种将内存泄露的信息输出到日志文件的办法，该方法非常简单，如果再加上定时器的，则可以定时分析系统运行到现在存在有哪些内存没有释放，如何实现呢？我们不妨还是使用刚才故意产生内存泄露的例子。 </span></p><p style="margin-left: 18pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >打开</span><span style="font-family:Times New Roman;"  > stdafx.h </span><span style="font-family:宋体;"  >添加后的代码如下（黑体部分是我们需要添加的代码）： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#if !defined(AFX_STDAFX_H__C6C9B115_8277_4302_914D_17F87E13978E__)</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#define AFX_STDAFX_H__C6C9B115_8277_4302_914D_17F87E13978E__</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#if _MSC_VER &gt; 1000</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#pragma once</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif // _MSC_VER &gt; 1000</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#define VC_EXTRALEAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exclude rarely-used stuff from Windows headers</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;afx.h&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;afxwin.h&gt;         // MFC core and standard components</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;afxext.h&gt;         // MFC extensions</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;afxdtctl.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// MFC support for Internet Explorer 4 Common Controls</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#ifndef _AFX_NO_AFXCMN_SUPPORT</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;afxcmn.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// MFC support for Windows Common Controls</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif // _AFX_NO_AFXCMN_SUPPORT</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#include &lt;iostream&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>#ifdef _DEBUG</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>//for memory leak check</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><strong><span style="font-family:Courier New;"  >#define _CRTDBG_MAP_ALLOC //</span><span style="font-family:宋体;"  >使生成的内存</span><span style="font-family:Courier New;"  >dump</span></strong></span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  ><strong>包含内存块分配的具体代码为止</strong></span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>#include&lt;stdlib.h&gt; </strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>#include&lt;crtdbg.h&gt; </strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  ><strong>#endif</strong></span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >#endif </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 18pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >在程序执行的开始，设置内存跟踪及设置输出文件 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >代码如下： </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Courier New; font-size:10pt;"  >HANDLE hLogFile;//</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >声明日志文件句柄</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >//</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >允许检查内存泄露</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >_CrtSetDbgFlag( _CRTDBG_REPORT_FLAG);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int nRetCode = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    //</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >创建日志文件</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;hLogFile = CreateFile("c:\\memleak.log", GENERIC_WRITE, </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 21pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >FILE_SHARE_WRITE|FILE_SHARE_READ,&nbsp;&nbsp;&nbsp;&nbsp;NULL,</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p style="margin-left: 21pt;"  ><span style="font-family:Courier New; font-size:10pt;"  >CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-size:10pt;"  ><span style="font-family:Courier New;"  >//</span><span style="font-family:宋体;"  >将</span><span style="font-family:Courier New;"  >warn</span><span style="font-family:宋体;"  >级别的内容都输出到文件（注意</span><span style="font-family:Courier New;"  >dump</span><span style="font-family:宋体;"  >的报告级别即为</span><span style="font-family:Courier New;"  >warning</span></span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >）</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >    //</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >将日志文件设置为告警的输出文件</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;_CrtSetReportFile(_CRT_WARN, hLogFile); </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 18pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >3</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >在程序执行结尾，我们输出内存泄露 </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >}</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >//Dump</span><span style="font-family:宋体;"  ><span style="font-size:10pt;"  >从程序开始运行到该时刻点，已分配而未释放的内存</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >_CrtDumpMemoryLeaks();</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >CloseHandle(hLogFile);</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >我们按</span><span style="font-family:Times New Roman;"  >ctrl-F5</span><span style="font-family:宋体;"  >执行程序，然后打开</span><span style="font-family:Times New Roman;"  >c:\ memleak.log</span><span style="font-family:宋体;"  >看到内容如下： </span></span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Detected memory leaks!</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Dumping objects -&gt;</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >F:\2008\07\prj\memleak\memleak.cpp(22) : {61} normal block at 0x00386EB8, 1024 bytes long.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  > Data: &lt;                &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{50} normal block at 0x00421CF0, 33 bytes long.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  > Data: &lt; C              &gt; 00 43 00 CD CD CD CD CD CD CD CD CD CD CD CD CD </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{49} normal block at 0x00421D40, 40 bytes long.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  > Data: &lt; |L             &gt; 14 7C 4C 10 16 00 00 00 00 00 00 00 00 00 00 00 </span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >{47} client block at 0x00421E50, subtype 0, 64 bytes long.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >a CDynLinkLibrary object at $00421E50, 64 bytes long</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:Courier New; font-size:10pt;"  >Object dump complete.</span><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >在实际项目中，尤其是我们看一个长期运行的服务程序的内存泄露情况，可使用定时器定时获取从程序开始执行到当前时刻，有多少内存没有释放，这可能就是使用单纯</span><span style="font-family:Times New Roman;"  >F5</span><span style="font-family:宋体;"  >调试内存泄露所不具有的手段。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >学会如何防止并检查内存泄漏，是一个合格的</span><span style="font-family:Times New Roman;"  >c/c++</span><span style="font-family:宋体;"  >程序员必须具备的能力。但是由于内存泄漏是程序运行并满足一定条件时才会发生，直接从代码中查出泄漏原因的难度较大。而且检查内存泄露的方法和工具很多，上面仅仅介绍了最简单也是最基础检查内存泄露的方法。希望感兴趣的读者一定要深入下去。 </span></span></p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-5</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >Windows 内存管理简述</span><span style="font-family:宋体;"  >     </span></span></strong></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >最后，在内存分配上，不同操作系统具有一些特定的</span><span style="font-family:Times New Roman;"  >API</span><span style="font-family:宋体;"  >函数，使用这些函数可使内存分配更高效、安全。例如在</span><span style="font-family:Times New Roman;"  >windows </span><span style="font-family:宋体;"  >系统上，具有一系列的函数负责内存分配、释放和管理。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>用于内存管理的函数</strong>   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >CopyMemory </span><span style="font-family:宋体;"  >将一块内存从位置拷贝到另外一个位置，该函数使用频率非常高。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >FillMemory </span><span style="font-family:宋体;"  >将指定内存块内容填充为指定数据</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GetWriteWatch </span><span style="font-family:宋体;"  >查找已经被写入虚拟内存区域的页面地址</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalMemoryStatus </span><span style="font-family:宋体;"  >获得关于系统当前对于物理内存和虚拟的内存的使用信息。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalMemoryStatusEx </span><span style="font-family:宋体;"  >获得关于系统当前对于物理内存和虚拟的内存的使用信息。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >IsBadCodePtr </span><span style="font-family:宋体;"  >决定调用进程是否拥有对指定地址内存的读操作权。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >IsBadReadPtr </span><span style="font-family:宋体;"  >检验调用进程是否拥有对指定内存范围的读操作权。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >IsBadStringPtr </span><span style="font-family:宋体;"  >检验调用进程是否拥有对指定字符串所在地址区域的读操作权。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >IsBadWritePtr </span><span style="font-family:宋体;"  >检验调用进程是否拥有对指定内存范围的写操作权。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >MoveMemory </span><span style="font-family:宋体;"  >将一块内存从一个位置移动到另外的位置。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >ResetWriteWatch </span><span style="font-family:宋体;"  >为某片虚拟内存区域重置写跟踪状态。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >ZeroMemory </span><span style="font-family:宋体;"  >用零值填充某片内存块，该函数也是一个经常使用的函数。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><strong><span style="font-family:Times New Roman;"  >AWE</span><span style="font-family:宋体;"  >（</span><span style="font-family:Times New Roman;"  >Address Windowing Extensions</span><span style="font-family:宋体;"  >）</span><span style="font-family:Times New Roman;"  >     </span></strong><span style="font-family:宋体;"  ><strong>函数</strong>    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >AllocateUserPhysicalPages </span><span style="font-family:宋体;"  >分配物理内存页面与进程的</span><span style="font-family:Times New Roman;"  >AWE</span><span style="font-family:宋体;"  >区域建立或取消映射</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >FreeUserPhysicalPages </span><span style="font-family:宋体;"  >释放先前由</span><span style="font-family:Times New Roman;"  >AllocateUserPhysicalPages</span><span style="font-family:宋体;"  >函数分配的物理内存页面。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >MapUserPhysicalPages </span><span style="font-family:宋体;"  >映射在</span><span style="font-family:Times New Roman;"  >AWE</span><span style="font-family:宋体;"  >区域内的指定地址分配的物理内存。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >MapUserPhysicalPagesScatter</span><span style="font-family:宋体;"  >映射在</span><span style="font-family:Times New Roman;"  >AWE</span><span style="font-family:宋体;"  >区域内的指定地址分配的物理内存。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><strong><span style="font-family:宋体;"  >全局函数（</span><span style="font-family:Verdana;"  >global functions</span></strong><span style="font-family:宋体;"  ><strong>）</strong>    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalAlloc </span><span style="font-family:宋体;"  >从堆中分配指定字节数量的内存。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalDiscard </span><span style="font-family:宋体;"  >丢弃指定的全局内存块。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalFlags </span><span style="font-family:宋体;"  >返回关于指定全局内存对象的信息</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalFree </span><span style="font-family:宋体;"  >释放指定的全局内存对象。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalHandle </span><span style="font-family:宋体;"  >返回指定全局内存块的指针的句柄。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalLock </span><span style="font-family:宋体;"  >锁定一个全局内存对象并且返回指向该内存块第一个字节的指针。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalReAlloc </span><span style="font-family:宋体;"  >改变指定全局内存对象的大小和属性。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalSize </span><span style="font-family:宋体;"  >得到指定内存对象的当前大小。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GlobalUnlock </span><span style="font-family:宋体;"  >减少对一个内存对象的锁定数量。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"  ><strong><span style="font-family:宋体;"  >本地</span><span style="font-family:Times New Roman;"  >(local)</span></strong><span style="font-family:宋体;"  ><strong>函数</strong>    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalAlloc </span><span style="font-family:宋体;"  >从堆中分配指定数量的内存。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalDiscard </span><span style="font-family:宋体;"  >丢弃指定的本地内存对象。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalFlags </span><span style="font-family:宋体;"  >返回关于指定本地内存对象的信息。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalFree </span><span style="font-family:宋体;"  >释放指定的本地内存对象。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalHandle </span><span style="font-family:宋体;"  >得到指向指定本地内存对象的指针的句柄。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalLock </span><span style="font-family:宋体;"  >锁定本地内存对象并且返回指向该内存对象的第一个字节的指针。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalReAlloc </span><span style="font-family:宋体;"  >改变指定本地内存对象的大小或者属性。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalSize </span><span style="font-family:宋体;"  >返回指定本地内存对象的当前大小。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >LocalUnlock </span><span style="font-family:宋体;"  >减少对某内存对象的锁定数量。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>堆函数族</strong>   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GetProcessHeap </span><span style="font-family:宋体;"  >获得调用进程的堆的一个句柄。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >GetProcessHeaps </span><span style="font-family:宋体;"  >获得调用进程所有有效的堆的句柄。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapAlloc </span><span style="font-family:宋体;"  >从堆中分配一块内存。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapCompact </span><span style="font-family:宋体;"  >尝试压紧指定的堆。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapCreate </span><span style="font-family:宋体;"  >创建一个堆对象。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapDestroy </span><span style="font-family:宋体;"  >销毁指定的堆对象。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapFree </span><span style="font-family:宋体;"  >释放一块从堆中分配的内存。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapLock </span><span style="font-family:宋体;"  >尝试获得与指定堆关联的锁定。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapQueryInformation </span><span style="font-family:宋体;"  >获得关于指定堆的资料。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapReAlloc </span><span style="font-family:宋体;"  >从堆中重新分配一块内存。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapSetInformation </span><span style="font-family:宋体;"  >为指定的堆设置堆信息。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapSize </span><span style="font-family:宋体;"  >获得一个在堆上的内存块的大小。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapUnlock </span><span style="font-family:宋体;"  >获得与指定堆相关联的一个锁定的所有者。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapValidate </span><span style="font-family:宋体;"  >尝试使指定的堆有效。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >HeapWalk </span><span style="font-family:宋体;"  >枚举指定堆上的内存块。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>虚拟内存函数</strong>   </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualAlloc </span><span style="font-family:宋体;"  >保留或提交调用进程虚拟地址空间的某一区域的页面。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualAllocEx </span><span style="font-family:宋体;"  >保留或提交调用进程虚拟地址空间的某一区域的页面。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualFree </span><span style="font-family:宋体;"  >释放或取消提交调用进程虚拟地址空间的某一区域的页面。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualFreeEx </span><span style="font-family:宋体;"  >释放或取消提交调用进程虚拟地址空间的某一区域的页面。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualLock </span><span style="font-family:宋体;"  >锁定指定的进程虚拟地址空间的指定块到物理内存中。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualProtect </span><span style="font-family:宋体;"  >改变调用进程虚拟地址空间已提交页面区域的访问限制级。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualProtectEx </span><span style="font-family:宋体;"  >改变调用进程虚拟地址空间已提交页面区域的访问限制级。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualQuery </span><span style="font-family:宋体;"  >提供关于调用进程虚拟地址空间页面区域的资料。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualQueryEx </span><span style="font-family:宋体;"  >提供关于调用进程虚拟地址空间页面区域的资料。 </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >VirtualUnlock </span><span style="font-family:宋体;"  >对某进程虚拟地址空间的某区域的页面解锁。</span><span style="font-family:Times New Roman;"  >    </span><span style="font-family:宋体;"  >    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >限于本章主旨，上面函数系列不再深入介绍，感兴趣的读者可以去深入了解。 </span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 5pt;"  ><strong><span style="font-family:Batang; font-size:18pt;"  >1-6</span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp;&nbsp; </span><span style="font-size:18pt;"  ><span style="font-family:Batang;"  >总结和建议读者的练习</span><span style="font-family:宋体;"  >     </span></span></strong></p><p style="margin-left: 18pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >1</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >使用</span><span style="font-family:Times New Roman;"  > OLLYDBG </span><span style="font-family:宋体;"  >反汇编分析</span><span style="font-family:Times New Roman;"  >C</span><span style="font-family:宋体;"  >语言内存管理。 </span></span></p><p style="margin-left: 18pt;"  ><span style="font-size:12pt;"  ><span style="font-family:Times New Roman;"  >2</span><span style="font-family:宋体;"  >、</span></span><span style="font-family:Times New Roman; font-size:7pt;"  >&nbsp; </span><span style="font-family:宋体; font-size:12pt;"  >包装内存分配和释放的函数，以探测内存泄露。 </span></p>
</body></html>