<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：【转】使用WinDBG观察启用PAE后的分页机制</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>【转】使用WinDBG观察启用PAE后的分页机制</h2>
<p align="right">发布时间：2012-5-26 10:48
<br>分类名称：Debug_Crack</p><br>
<p>  </p><p style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;"  ><span style="font-size:12.0pt;font-family:宋体;mso-bidi-font-family:宋体;"  lang="EN-US"  >From</span><span style="font-size:12.0pt;font-family:宋体;mso-bidi-font-family:宋体;"  >：<span lang="EN-US"  >http://advdbg.org/blogs/advdbg_system/articles/627.aspx</span></span></p>  <p><span style="font-family:宋体; font-size:12pt;"  >我在《软件调试》一书的2.7节介绍了CPU的分页机制，因为这属于这本书的支持性内容，考虑篇幅限制， 没有介绍启用PAE的情况。书出版后，很多读者对这一内容很感兴趣，也有读者遇到了启用PAE的情况。因此决定写这篇短文来介绍一下PAE的概况，以及如 何在启用PAE后的系统中做2.7.5节的试验。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >PAE是Physical Address Extension的缩写，即物理地址扩展。简单来说，就是把IA-32处理器的寻址能力从原来的4GB扩展到64GB。寻址4GB空间，要求物理地址的 宽度为32位。类似的，要寻址64GB空间，那么物理地址的宽度就是36位。因为这个原因，PAE又被称为PAE-36bit。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >如果从CPU的引脚来讲，那么支持PAE的CPU原则上应该有36根地址线，但因为IA-32 CPU的前端总线是64位宽，每次可同时传递8个字节数据。因此实际上省略了低三位地址线。以奔腾4 CPU为例，它的地址线是A[35:3]#。也就是说，CPU在访问内存时，它总是向前端总线给出一个低3位为0的地址，这实际上也起到了将地址按8字节 对齐的功效。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >PAE功能是P6处理器的第一代产品，Pentium Pro所引入的（参见《软件调试》35页），此后的IA-32 CPU都支持这一特征。系统软件可以使用CPUID指令检测当前运行的CPU是否支持PAE。控制寄存器CR4的第5位（CR4[5]）用来启用 PAE（参见《软件调试》44页）。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >因为当IA-32 CPU工作在32位模式时，软件中使用的是32位宽的虚拟地址和线性地址，因此便产生了一个问题，如何将32位宽的线性地址翻译为36位宽的物理地址？答 案是将原来的二级映射扩展为三级映射，也就是在原来的页目录和页表基础上再增加一级，称为页目录指针表。根据单个内存页的大小不同（4KB或者2MB）又 分为两种情况。 </span></p><p><img title="使用WinDBG观察启用PAE后的分页机制 - Howie - Dspace"  src="pic/img8.ph.126.net_KJF-8KaOlmC75GnuoZC9rA==_2560014913200970548.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >图1 启用PAE时将线性地址翻译为物理地址（4KB内存页）（摘自IA-32手册卷3A） </span></p><p><span style="font-family:宋体; font-size:12pt;"  >上图中画出的是4KB内存页的情况。其中的PDPTR是Page Directory Pointer Table Register的缩写，它是启用PAE后CR3寄存器的别名。此时，32位线性地址被分割为如下三个部分： </span></p><ul><li><span style="font-family:宋体; font-size:12pt;"  >2位（位30和位31）的页目录指针表索引，用来索引本地址在页目录指针表中的对应表项。  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >9位（位21-29）的页目录表索引，用来索引本地址在页目录表中的对应表项。  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >9位（位12-20）的页表索引，用来索引本地址在页表中的对应表项。  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >12位（位0-11）的页内偏移，这与以前是相同的。 </span></li></ul><p><span style="font-family:宋体; font-size:12pt;"  >与没有启用PAE的4KB情况（参见《软件调试》2.7.4节）相比，有以下不同： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >表的数量由原来的两张变为三张。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >因为表中的地址都是物理地址，所以三张表的每个表项都有原来的32位变为64位，具体格式如下图所示。 </span></p><p><img title="使用WinDBG观察启用PAE后的分页机制 - Howie - Dspace"  src="pic/img9.ph.126.net_1ImUn3XIXIVFwg5e90kydg==_111182615818260699.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >图2 启用PAE时的地址转换表项格式（4KB内存页）（摘自IA-32手册卷3A） </span></p><p><span style="font-family:宋体; font-size:12pt;"  >也就是说，每个64位的表项中有24位是用来代表基地址的，这24位对应的是物理地址的高24位，低12位为0。这意味着，页目录表、页表和每个页的基地址都是按4KB对齐的。 </span></p><p><img title="使用WinDBG观察启用PAE后的分页机制 - Howie - Dspace"  src="pic/img8.ph.126.net_ZOaYfRAeZBNPWitykVTzWg==_2600265834870589958.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >图3 启用PAE时将线性地址翻译为物理地址（2MB内存页）（摘自IA-32手册卷3A） </span></p><p><span style="font-family:宋体; font-size:12pt;"  >图3所示的是2MB内存页的情形。与未启用PAE的情况一样，不再需要页表。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >有了以上基础后，下面我们来在一个启用了PAE的Windows XP SP2系统上做2.7.5节中的试验。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >根据步骤1-4，找到gpszNum变量的地址为000ab048，其内容如下：  </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Courier New;"  >0:002&gt; db 000ab048 <br>000ab048&nbsp; 31 00 32 00 33 00 34 00-35 00 36 00 37 00 38 00&nbsp; 1.2.3.4.5.6.7.8.<br>000ab058&nbsp; 39 00 2e 00 00 00 00 00-00 00 00 00 00 00 00 00&nbsp; 9...............<br>000ab068&nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 1e 68 72 28&nbsp; .............hr(<br>000ab078&nbsp; 02 00 07 00 3e 01 08 00-90 b0 0a 00 00 b0 0a 00&nbsp; ....&gt;...........<br>000ab088&nbsp; 04 00 02 00 20 01 0c 00-01 00 00 00 01 00 00 00&nbsp; .... ...........<br>000ab098&nbsp; 00 00 00 00 00 00 00 00-00 00 00 00 57 00 53 00&nbsp; ............W.S.<br>000ab0a8&nbsp; 02 00 04 00 24 01 0c 00-30 00 00 00 78 01 0a 00&nbsp; ....$...0...x...<br>000ab0b8&nbsp; 02 00 02 00 26 01 08 00-d0 b0 0a 00 f0 b0 0a 00&nbsp; ....&amp;...........</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >启动一个本地内核调试会话，观察calc进程的概况： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >lkd&gt; !process 0 0 calc.exe<br>PROCESS 896acb08&nbsp; SessionId: 0&nbsp; Cid: 1020&nbsp;&nbsp;&nbsp; Peb: 7ffd5000&nbsp; ParentCid: 0fc8<br>&nbsp;&nbsp;&nbsp; DirBase: 1b1c0aa0&nbsp; ObjectTable: e3265fb8&nbsp; HandleCount:&nbsp; 48.<br>&nbsp;&nbsp;&nbsp; Image: calc.exe </span></p><p><span style="font-family:宋体; font-size:12pt;"  >上面的DirBase便是CR3寄存器的值，即PDPTR的内容，其格式如下： </span></p><p><img title="使用WinDBG观察启用PAE后的分页机制 - Howie - Dspace"  src="pic/img1.ph.126.net_rhiRALIqmH4nep8Kpb8BQw==_625155923291919411.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >将要转换的线性地址000ab048 显示为二进制： </span></p><p><span style="font-family:宋体; font-size:12pt;"  >lkd&gt; .formats 000ab048 <br>Evaluate expression:<br>&nbsp; Hex:&nbsp;&nbsp;&nbsp;&nbsp; 000ab048<br>&nbsp; Binary:&nbsp; 00000000 00001010 10110000 01001000 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >根据图1，分解为如下4个部分： </span></p><ul><li><span style="font-family:宋体; font-size:12pt;"  >最高两位为0，是页目录指针表的索引。  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >接下来的9位（000000 000）为页目录索引，即0。  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >再接下来的9位（01010 1011）为页目录索引，即0xab。lkd&gt; ? 0y010101011<br>Evaluate expression: 171 = 000000ab  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >最后的12位（0000 01001000）是页内偏移，即0x48。 </span></li></ul><p><span style="font-family:宋体; font-size:12pt;"  >因为CR3值（1b1c0aa0）&nbsp;的低5位都是0，所以可以知道计算器进程的页目录指针表的基地址就是0x1b1c0aa0。观察这一地址附近的内容： </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Courier New;"  >lkd&gt; !dd 0x1b1c0aa0<br>#1b1c0aa0 6408b001 00000000 34bcc001 00000000<br>#1b1c0ab0 3d00d001 00000000 4430a001 00000000<br>#1b1c0ac0 5ae85001 00000000 12a46001 00000000<br>#1b1c0ad0 41807001 00000000 5e284001 00000000<br>#1b1c0ae0 35377001 00000000 3bcb8001 00000000</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >每个页目录指针表共有4个表项，每个表项是8字节（64位），因此，可以知道上面的前两行内容是计算器进程的页目录指针表。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >根据上面的分解，1b1c0aa0对应的是0号表项，即00000000`6408b001。根据图2，位12到位35是页目录表基地址的高24位，因此，可以知道对应的页目录表基地址是0x6408b000，观察它的0号表项： </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Courier New;"  >lkd&gt; !dq 0x6408b000<br>#6408b000 00000000`42d20067 00000000`3c5b6067<br>#6408b010 00000000`3f11b067 00000000`1e551067<br>#6408b020 00000000`0e824067 00000000`2cecc067<br>#6408b030 00000000`39d4e067 00000000`00000000<br>#6408b040 00000000`0b6db067 00000000`00000000<br>#6408b050 00000000`00000000 00000000`00000000<br>#6408b060 00000000`00000000 00000000`00000000<br>#6408b070 00000000`00000000 00000000`00000000</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >可见，我们要翻译的线性地址对应的页目录表项是00000000`42d20067，其中位12到位35是页表基地址的高24位，因此可以知道我们要寻找的页表基地址是42d20000，观察它的0xab号表项： </span></p><p><span style="font-size:12pt;"  ><span style="font-family:Courier New;"  >lkd&gt; !dq 42d20000+0xab*8<br>#42d20558 80000000`46852067 80000000`2a3db067<br>#42d20568 80000000`4009c067 80000000`43263067<br>#42d20578 80000000`444e4067 80000000`7b165067<br>#42d20588 80000000`0b92e067 80000000`3d12f067<br>#42d20598 80000000`283b0067 80000000`79871067<br>#42d205a8 80000000`348ba067 80000000`72cbb067<br>#42d205b8 80000000`421fd067 80000000`7223e067<br>#42d205c8 00000000`00000080 00000000`00000000</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:宋体;"  >这样便得到页表表项：</span><span style="font-family:Courier New;"  >80000000`46852067(</span><span style="font-family:宋体;"  >此处在</span><span style="font-family:Courier New;"  >2008</span><span style="font-family:宋体;"  >年</span><span style="font-family:Courier New;"  >10</span><span style="font-family:宋体;"  >月</span><span style="font-family:Courier New;"  >14</span><span style="font-family:宋体;"  >日有更新，多谢</span><span style="font-family:Courier New;"  >llx</span><span style="font-family:宋体;"  >的提醒</span><span style="font-family:Courier New;"  >)</span><span style="font-family:宋体;"  >， 它的位12到位35是内存页基地址的高24位，即线性地址000ab048所对应的内存页基地址是46852000，加上页内偏移0x48便得到最终的物理地址，即0x46852048，显示其内容： </span></span></p><p><span style="font-size:12pt;"  ><span style="font-family:Courier New;"  >lkd&gt; !db 46852048<br>#46852048 31 00 32 00 33 00 34 00-35 00 36 00 37 00 38 00 1.2.3.4.5.6.7.8.<br>#46852058 39 00 2e 00 00 00 00 00-00 00 00 00 00 00 00 00 9...............<br>#46852068 00 00 00 00 00 00 00 00-00 00 00 00 1e 68 72 28 .............hr(<br>#46852078 02 00 07 00 3e 01 08 00-90 b0 0a 00 00 b0 0a 00 ....&gt;...........<br>#46852088 04 00 02 00 20 01 0c 00-01 00 00 00 01 00 00 00 .... ...........<br>#46852098 00 00 00 00 00 00 00 00-00 00 00 00 57 00 53 00 ............W.S.<br>#468520a8 02 00 04 00 24 01 0c 00-30 00 00 00 78 01 0a 00 ....$...0...x...<br>#468520b8 02 00 02 00 26 01 08 00-d0 b0 0a 00 f0 b0 0a 00 ....&amp;...........</span><span style="font-family:宋体;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >可见，其内容与前面使用用户态调试器观察的内容是一致的。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >posted on 2008年6月26日 18:47 由 <a rel="nofollow" href="http://advdbg.org/user/Profile.aspx?UserID=2122"  ><span style="color:blue; text-decoration:underline;"  >Raymond</span></a>   </span></p><p><a title="permalink" rel="nofollow" href="http://advdbg.org/blogs/advdbg_system/articles/627.aspx"  ><span style="color:blue; font-family:宋体; font-size:12pt; text-decoration:underline;"  ><strong>#</strong></span></a><span style="font-family:宋体; font-size:12pt;"  ><strong> re: 使用WinDBG观察启用PAE后的分页机制 @ 2008年7月1日 22:17  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >这样便得到页表表项：80000000`421fd067， 它的位12到位35是内存页基地址的高24位，即线性地址000ab048所对应的内存页基地址是421fd000，加上页内偏移0x48便得到最终的物理地址，即0x421fd048 <br>张老师，这里地址明显打错了，书上也有多处这样的错误。是不是排版的问题呢？  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >llx571030  </span></p><p><a title="permalink" rel="nofollow" href="http://advdbg.org/blogs/advdbg_system/articles/627.aspx"  ><span style="color:blue; font-family:宋体; font-size:12pt; text-decoration:underline;"  ><strong>#</strong></span></a><span style="font-family:宋体; font-size:12pt;"  ><strong> re: 使用WinDBG观察启用PAE后的分页机制 @ 2008年10月15日 9:11  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >llx，你提的问题刚刚看到，已经更正了，多谢。关于《软件调试》书中的类似错误，请通过以下链接查看勘误列表（<a target="_new" rel="nofollow" href="http://advdbg.org/books/swdbg/errata.aspx"  ><span style="color:blue; text-decoration:underline;"  >http://advdbg.org/books/swdbg/errata.aspx</span></a>）。如果还没有包含在勘误中，那么请发给我，多谢。  </span></p>
</body></html>