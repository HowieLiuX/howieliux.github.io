<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] 扫盲贴，HOOK SSDT 短文一篇</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] 扫盲贴，HOOK SSDT 短文一篇</h2>
<p align="right">发布时间：2014-2-19 16:03
<br>分类名称：Debug_Crack</p><br>
<p><span style="color:#333333;"   ><span style="font-family:宋体;"   ><span style="font-size:9pt;"   >标 题:<span style="color:black;"   > 【原创】扫盲贴，HOOK SSDT 短文一篇。<span style="color:#666666;"   ><br><span style="color:#333333;"   >作 者:<span style="color:#666666;"   >
<span style="color:black;"   >梧桐<span style="color:#666666;"   ><br><span style="color:#333333;"   >时 间:<span style="color:#666666;"   > 2008-12-06,23:01:35<br><span style="color:#333333;"   >链 接:<span style="color:#666666;"   > http://bbs.pediy.com/showthread.php?t=78218<br><span style="color:#13253c;"   ><br>//author:梧桐<br>//转载请注明出处<br><br>------------------------很不华丽的分割线------------------------------------------------------<br><br>本文章仅供那些在驱动开发门外徘徊的程序爱好者参考和学习，大牛就绕过吧，<br>如有错误的地方，还请多多指出，不胜感激。<br><br>------------------------很不华丽的分割线------------------------------------------------------<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Driver&nbsp;一词儿，我想大家都不陌生，它是工作在ring0下的，正是因为如此，它不不能够快速上手的，更多的时候你要熟悉它的技术资料和接口，还要熟悉底层工作的原理，一不小心搞个BSOD，那是会非常郁闷的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;好了，现在让我们步入正题，首先确认你已经安装好了DDK（学习驱动开发，推荐WINXP&nbsp;DDK&nbsp;2600、&nbsp;Windows&nbsp;XP,&nbsp;&nbsp;VS2003），配置好了你的开发环境（DDK&nbsp;Wizard），在VS20003里添加WINDDK路径。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;打开VS2003，Tools选项，选取&nbsp;Options（如下图）：<br><br><img title="[转] 扫盲贴，HOOK SSDT 短文一篇 - Howie - Dspace"   src="pic/img2.ph.126.net_iuXj1Y_U5Gm0m1R7Fkl5Qw==_786159610052982557.jpg"   alt=""   /><br><br>&nbsp;&nbsp;&nbsp;&nbsp;然后，我们找到&nbsp;Projects（工程），选取VC++&nbsp;Directories，添加WINDDK路径：<br><img title="[转] 扫盲贴，HOOK SSDT 短文一篇 - Howie - Dspace"   src="pic/img2.ph.126.net_fSBSCegFaadhsBM8lntMjw==_1625517990604462970.jpg"   alt=""   /><br><br>&nbsp;&nbsp;&nbsp;&nbsp;配置好这些环境以后，我们开始与驱动的亲密接触吧。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;先来建立一个驱动的工程：<br><br><img title="[转] 扫盲贴，HOOK SSDT 短文一篇 - Howie - Dspace"   src="pic/img1.ph.126.net_UVXSIRkbrn6an_ATsKSwwA==_4852065648638526433.jpg"   alt=""   /><br><br>&nbsp;&nbsp;&nbsp;&nbsp;那些默认的选项，全部取消掉：<br><br><img title="[转] 扫盲贴，HOOK SSDT 短文一篇 - Howie - Dspace"   src="pic/img2.ph.126.net_yS20DxJ7sD_b-Pjef2mTCg==_6608180331654895220.jpg"   alt=""   /><br><br>&nbsp;&nbsp;&nbsp;&nbsp;接着点&nbsp;Finish&nbsp;，删除&nbsp;Header&nbsp;Files、Resource&nbsp;Files，此时，DDK&nbsp;Wizard&nbsp;已经为我们建立了一套Driver模板了，但细看，是不是感觉非常非常的乱？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;OK，我们把它K掉，现在我们自己来打造一个简单的入口点。<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-size:12pt;"   >#include&nbsp;"ntddk.h"<span style="color:#13253c;"   ><br><br>//Unload<br>VOID&nbsp;UnLoad(IN&nbsp;PDRIVER_OBJECT&nbsp;DriverObject)<br>{<br>&nbsp;&nbsp;&nbsp;DbgPrint("UnLoad&nbsp;Driver.\n");<br>}<br><br>//EntryPoint.<br>NTSTATUS&nbsp;DriverEntry(IN&nbsp;PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br>{<br>&nbsp;&nbsp;DriverObject-&gt;DriverUnload&nbsp;=&nbsp;UnLoad;<br>&nbsp;&nbsp;//TODO<br>&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;<br>}<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >在&nbsp;DriverName.WXP上点Build，看看objchk\i386目录下产生的Sys文件，OK，Cool吧，当然，我们这个驱动连任何功能都没有的，Cool是很Cool，就是Cool得没内涵了，那么我们来实现点什么功能呢，好吧，让我们来对SSDT挂钩一下吧。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;要挂钩SSDT，就必须先要由内核到处一个KeServiceDescriptorTable，那么我们还要先定义一个KeServiceDescriptorTable类型的的结构体：<br>代码:<br></span></span><span style="font-size:12pt;"   >typedef&nbsp;struct&nbsp;ServiceDescriptorEntry<span style="color:#13253c;"   ><br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;*ServiceTableBase;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;*ServiceCounterTableBase;&nbsp;//Used&nbsp;only&nbsp;in&nbsp;checked&nbsp;build<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;NumberOfServices;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*ParamTableBase;<br>}&nbsp;SSDTEntry;<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >定义了KSDT的结构，那么我们想想要HOOK那个函数呢，好吧，就以ZwTerminateProcess为例，我们开动，首先定义一个ZwTerminateProcess函数结构，函数原型：<br>代码:<br></span></span><span style="font-size:12pt;"   >ZwTerminateProcess(<span style="color:#13253c;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;<br></span></span><span style="font-size:9pt;"   >结构定义：<span style="color:#13253c;"   ><br>代码:<br></span></span><span style="font-size:12pt;"   >typedef&nbsp;NTSTATUS(*_ZwTerminateProcess)(<span style="color:#13253c;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >我们要HOOK&nbsp;ZwTerminateProcess，那么我们是不是要先找出它在KSDT中的位置呢，没错，那么我们来定义一个通过SSDT服务号得到函数地址的宏以达到我们的目的：<br>代码:<br></span></span><span style="font-size:12pt;"   >#define&nbsp;&nbsp;GetSystemFunc(FuncName)&nbsp;KeServiceDescriptorTable.ServiceTableBase[*(PULONG)((PUCHAR<span style="color:#13253c;"   >)FuncName+1)];&nbsp;<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >想要达到改写SSDT的目的，那么首先要解决的是内存保护机制的问题，众所周知，Windows的某些版本对内存区域启用了写保护的功能，在XP和2003中更为常见，SSDT是只读的，那怎么办呢？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;有的网友此刻估计已经明白了。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;没错，就是&nbsp;Memory&nbsp;Descriptor&nbsp;List，简称&nbsp;MDL。有的同学可能会问了，MDL究竟是个什么东西呢？从字面意思看，不难理解，内存描述符列表。MDL包含了内存区域的起始、拥有者proc、字节数、标记等。OK，我们需要先定义一个MDL的指针。<br>代码:<br></span></span><span style="font-size:12pt;"   >PMDL&nbsp;MDLSystemCall;<span style="color:#13253c;"   ><br></span></span><span style="font-size:9pt;"   ><br><span style="color:#13253c;"   >&nbsp;&nbsp;&nbsp;&nbsp;定义了MDL的指针以后，我们要通过MAPPED系列的参数来使内存拥有可写性，然后锁定内存中的MDL，那么我们就要定义一个PVOID的指针，来供MmMap操作。<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span><span style="font-size:12pt;"   >PVOID&nbsp;*MappedSCT;<span style="color:#13253c;"   ><br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >代码片段：<br>代码:<br></span></span><span style="font-size:12pt;"   >MDLSystemCall&nbsp;=&nbsp;MmCreateMdl(NULL,&nbsp;KeServiceDescriptorTable.ServiceTableBase,&nbsp;KeServiceDescriptorTable.NumberOfServices*4);<span style="color:#13253c;"   ><br><br>&nbsp;&nbsp;return&nbsp;STATUS_UNSUCCESSFUL;<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >那么，建立了MDL，是不是该填充一下页数组啊？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;对的，没错。<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span><span style="font-size:12pt;"   >MmBuildMdlForNonPagedPool(MDLSyst<span style="color:#13253c;"   >emCall);<br>MDLSystemCall-&gt;MdlFlags&nbsp;=&nbsp;MDLSystemCall-&gt;MdlFlags&nbsp;|&nbsp;MDL_MAPPED_TO_SYSTEM_VA;&nbsp;//可写<br>MappedSCT&nbsp;=&nbsp;MmMapLockedPages(MDLSystemCall,&nbsp;KernelMode);<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >我们转入HOOK话题，继续。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;刚才我们已经定义了&nbsp;ZwTerminateProcess&nbsp;的结构。<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span><span style="font-size:12pt;"   >Old_ZwTerminateProcess&nbsp;=&nbsp;(_ZwTerminateP<span style="color:#13253c;"   >rocess)(GetSystemFunc(ZwTerminateProcess));<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >获取没被HOOK之前的ZwTerminateProcess在KSDT中的索引，保存。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;那么下一步呢，就是干掉他了，替换为我们的函数，那么我们是不是要构造一个自己的函数过程呢，恩，没错。<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span><span style="font-size:12pt;"   >NTSTATUS&nbsp;NewZwTerminateProcess(<span style="color:#13253c;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;//TODO<br>&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;<br>}<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >在过程里要怎么玩，全看你自己了。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;下面就是替换函数了，修改SSDT中函数地址指向的位置，下面是宏定义：<br>代码:<br></span></span><span style="font-size:12pt;"   >#define&nbsp;GetIndex(_foo)&nbsp;*(PULONG)((PUCHAR)_foo+1)<span style="color:#13253c;"   ><br>#define&nbsp;HookOn(_Old,_New)&nbsp;InterlockedExchange((PLONG)&amp;MappedSCT[GetIndex(_Old)]&nbsp;,(LONG)_New)<br></span></span><span style="font-size:9pt;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#13253c;"   >代码片段：<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <br>代码:<br></span></span><span style="font-size:12pt;"   >MDLSystemCall&nbsp;=&nbsp;MmCreateMdl(NULL,&nbsp;KeServiceDescriptorTable.ServiceTableBase,&nbsp;KeServiceDescriptorTable.NumberOfServices*4);<span style="color:#13253c;"   ><br><br>&nbsp;&nbsp;return&nbsp;STATUS_UNSUCCESSFUL;<br>MmBuildMdlForNonPagedPool(MDLSystemCall);<br>MDLSystemCall-&gt;MdlFlags&nbsp;=&nbsp;MDLSystemCall-&gt;MdlFlags&nbsp;|&nbsp;MDL_MAPPED_TO_SYSTEM_VA;&nbsp;//可写<br>MappedSCT&nbsp;=&nbsp;MmMapLockedPages(MDLSystemCall,&nbsp;KernelMode);<br>HookOn(ZwTerminateProcess,&nbsp;NewZwTerminateProcess);<br>return&nbsp;STATUS_SUCCESS;<br></span></span><span style="font-size:9pt;"   >完整代码：<span style="color:#13253c;"   ><br>代码:<br></span></span><span style="font-size:12pt;"   >///////////////////////////////////////////////////////////////////////////////<span style="color:#13253c;"   ><br>///<br>///&nbsp;Copyright&nbsp;(c)&nbsp;2008&nbsp;-&nbsp;&lt;company&nbsp;name&nbsp;here&gt;<br>///<br>///&nbsp;Original&nbsp;filename:&nbsp;NtHook.c<br>///&nbsp;Project&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;NtHook<br>///&nbsp;Date&nbsp;of&nbsp;creation&nbsp;:&nbsp;2008-11-20<br>///&nbsp;Author(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;梧桐<br>///<br>///&nbsp;Purpose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&lt;description&gt;<br>///<br>///&nbsp;Revisions:<br>///&nbsp;&nbsp;0000&nbsp;[2008-11-20]&nbsp;Initial&nbsp;revision.<br>///<br>///////////////////////////////////////////////////////////////////////////////<br>#include&nbsp;"ntddk.h"<br><br>#pragma&nbsp;pack(1)<br>typedef&nbsp;struct&nbsp;ServiceDescriptorEntry<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;*ServiceTableBase;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;*ServiceCounterTableBase;&nbsp;//Used&nbsp;only&nbsp;in&nbsp;checked&nbsp;build<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;NumberOfServices;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*ParamTableBase;<br>}&nbsp;SSDTEntry;<br>__declspec(dllimport)&nbsp;&nbsp;SSDTEntry&nbsp;KeServiceDescriptorTable;<br><br>#pragma&nbsp;pack()<br><br>NTKERNELAPI&nbsp;NTSTATUS&nbsp;ZwTerminateProcess(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);&nbsp;<br><br><br>typedef&nbsp;NTSTATUS(*_ZwTerminateProcess)(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>_ZwTerminateProcess&nbsp;Old_ZwTerminateProcess;<br><br><br>#define&nbsp;GetSystemFunc(FuncName)&nbsp;KeServiceDescriptorTable.ServiceTableBase[*(PULONG)((PUCHAR)FuncName+1)]<br>PMDL&nbsp;&nbsp;MDSystemCall;<br>PVOID&nbsp;*MappedSCT;<br><br>#define&nbsp;GetIndex(_Function)&nbsp;*(PULONG)((PUCHAR)_Function+1)<br><br>#define&nbsp;HookOn(_Old,&nbsp;_New)&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PVOID)&nbsp;InterlockedExchange(&nbsp;(PLONG)&nbsp;&amp;MappedSCT[GetIndex(_Old)],&nbsp;(LONG)&nbsp;_New)<br><br>#define&nbsp;UnHook(_Old,&nbsp;_New)&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterlockedExchange(&nbsp;(PLONG)&nbsp;&amp;MappedSCT[GetIndex(_Old)],&nbsp;(LONG)&nbsp;_New)<br><br><br>NTSTATUS&nbsp;NewZwTerminateProcess(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;HANDLE&nbsp;ProcessHandle&nbsp;OPTIONAL,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;NTSTATUS&nbsp;ExitStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>{<br>&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;<br>}<br><br><br>//Unload<br>VOID&nbsp;UnLoad(IN&nbsp;PDRIVER_OBJECT&nbsp;DriverObject)<br>{<br>&nbsp;&nbsp;&nbsp;DbgPrint("UnLoad&nbsp;Driver.\n");<br>&nbsp;&nbsp;&nbsp;//卸载Hook<br>&nbsp;&nbsp;&nbsp;UnHook(&nbsp;ZwTerminateProcess,&nbsp;Old_ZwTerminateProcess);<br><br>&nbsp;&nbsp;&nbsp;//解锁、释放MDL<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MmUnmapLockedPages(MappedSCT,&nbsp;MDSystemCall);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IoFreeMdl(MDSystemCall);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>//EntryPoint.<br>NTSTATUS&nbsp;DriverEntry(IN&nbsp;PDRIVER_OBJECT&nbsp;DriverObject,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;PUNICODE_STRING&nbsp;RegistryPath)<br>{<br>&nbsp;&nbsp;DriverObject-&gt;DriverUnload&nbsp;=&nbsp;UnLoad;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//找出旧函数地址并保存<br>&nbsp;&nbsp;Old_ZwTerminateProcess&nbsp;=(_ZwTerminateProcess)(GetSystemFunc(ZwTerminateProcess));<br><br>&nbsp;&nbsp;MDSystemCall&nbsp;=&nbsp;MmCreateMdl(NULL,&nbsp;KeServiceDescriptorTable.ServiceTableBase,&nbsp;KeServiceDescriptorTable.NumberOfServices*4);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;STATUS_UNSUCCESSFUL;<br>&nbsp;&nbsp;MmBuildMdlForNonPagedPool(MDSystemCall);<br>&nbsp;&nbsp;MDSystemCall-&gt;MdlFlags&nbsp;=&nbsp;MDSystemCall-&gt;MdlFlags&nbsp;|&nbsp;MDL_MAPPED_TO_SYSTEM_VA;<br>&nbsp;&nbsp;MappedSCT&nbsp;=&nbsp;MmMapLockedPages(MDSystemCall,&nbsp;KernelMode);<br><br>&nbsp;&nbsp;//安装HOOK<br>&nbsp;&nbsp;HookOn(&nbsp;ZwTerminateProcess,&nbsp;NewZwTerminateProcess);<br>&nbsp;&nbsp;return&nbsp;STATUS_SUCCESS;</span></span></span><br></span>}
</p>
</body></html>