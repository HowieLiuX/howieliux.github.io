<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：【转载】智能指针</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>【转载】智能指针</h2>
<p align="right">发布时间：2012-8-24 13:43
<br>分类名称：Boost</p><br>
<p style="TEXT-INDENT: 2em;"  >1. 为什么需要智能指针？</p>  <p style="TEXT-INDENT: 2em;"  >简单的说，智能指针是为了实现类似于Java中的垃圾回收机制。Java的垃圾回收机制使程序员从繁杂的内存管理任务中彻底的解脱出来，在申请使用一块内存区域之后，无需去关注应该何时何地释放内存，Java将会自动帮助回收。但是出于效率和其他原因（可能C++设计者不屑于这种傻瓜氏的编程方式），C++本身并没有这样的功能，其繁杂且易出错的内存管理也一直为广大程序员所诟病。</p>  <p style="TEXT-INDENT: 2em;"  >更进一步地说，智能指针的出现是为了满足管理类中指针成员的需要。包含指针成员的类需要特别注意复制控制和赋值操作，原因是复制指针时只复制指针中的地址，而不会复制指针指向的对象。当类的实例在析构的时候，可能会导致垂悬指针问题。</p>  <p style="TEXT-INDENT: 2em;"  >管理类中指针成员的方法一般有两种方式：一种是采用值型类，这种类是给指针成员提供值语义（value semantics），当复制该值型对象时，会得到一个不同的新副本。这种方式典型的应用是string类。另外一种方式就是智能指针，实现这种方式的指针所指向的对象是共享的。</p>  <p style="TEXT-INDENT: 2em;"  >2. 智能指针的实现概述</p>  <p style="TEXT-INDENT: 2em;"  >智能指针(smart pointer)的一种通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</p>  <p style="TEXT-INDENT: 2em;"  >每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p>  <p style="TEXT-INDENT: 2em;"  >实现智能指针有两种经典策略：一是引入辅助类，二是使用句柄类。</p>  <p style="TEXT-INDENT: 2em;"  >3. 实现方式1：引入辅助类</p>  <p style="TEXT-INDENT: 2em;"  >这种方式定义一个单独的具体类（RefPtr）来封装指针和相应的引用计数。</p>  <p style="TEXT-INDENT: 2em;"  >class Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //基础对象类<br>{<br>public:<br>&nbsp;Point(int xVal = 0, int yVal = 0):x(xVal),y(yVal) { }<br>&nbsp;int getX() const { return x; }<br>&nbsp;int getY() const { return y; }<br>&nbsp;void setX(int xVal) { x = xVal; }<br>&nbsp;void setY(int yVal) { y = yVal; }<br>&nbsp;<br>private:<br>&nbsp;int x,y;<br>};</p>  <p style="TEXT-INDENT: 2em;"  >class RefPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//辅助类<br>{//该类成员访问权限全部为private，因为不想让用户直接使用该类<br>&nbsp;friend class SmartPtr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//定义智能指针类为友元，因为智能指针类需要直接操纵辅助类<br>&nbsp;RefPtr(Point *ptr):p(ptr), count(1) { }<br>&nbsp;~RefPtr() { delete p; }</p>  <p style="TEXT-INDENT: 2em;"  >&nbsp;int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //引用计数<br>&nbsp;Point *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//基础对象指针<br>};</p>  <p style="TEXT-INDENT: 2em;"  >class SmartPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //智能指针类<br>{<br>public:<br>&nbsp;SmartPtr(Point *ptr):rp(new RefPtr(ptr)) { }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//构造函数<br>&nbsp;SmartPtr(const SmartPtr &amp;sp):rp(sp.rp) { ++rp-&gt;count; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //复制构造函数<br>&nbsp;SmartPtr&amp; operator=(const SmartPtr&amp; rhs) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//重载赋值操作符<br>&nbsp;&nbsp;++rhs.rp-&gt;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //首先将右操作数引用计数加1，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//然后将引用计数减1，可以应对自赋值<br>&nbsp;&nbsp;&nbsp;delete rp;<br>&nbsp;&nbsp;rp = rhs.rp;<br>&nbsp;&nbsp;return *this;<br>&nbsp;}<br>&nbsp;~SmartPtr() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//析构函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象<br>&nbsp;&nbsp;&nbsp;delete rp;<br>&nbsp;}</p>  <p style="TEXT-INDENT: 2em;"  >private:<br>&nbsp;RefPtr *rp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//辅助类对象指针<br>};</p>  <p style="TEXT-INDENT: 2em;"  >int main()<br>{<br>&nbsp;Point *p1 = new Point(10, 8);<br>&nbsp;SmartPtr sp1(p1);<br>&nbsp;SmartPtr sp2(sp1);<br>&nbsp;Point *p2 = new Point(5, 5);<br>&nbsp;SmartPtr sp3(p2);<br>&nbsp;sp3 = sp1;</p>  <p style="TEXT-INDENT: 2em;"  >&nbsp;return 0;<br>}</p>  <p style="TEXT-INDENT: 2em;"  >使用该方式的内存结构图如下：</p>  <div><img title="智能指针 - 玉宝的爱 - 07118332 的博客"  alt="智能指针 - 玉宝的爱 - 07118332 的博客"  style="MARGIN: 0px 10px 0px 0px;"  src="pic/img4.ph.126.net__l7PhsdB__mp4_7ajXF0Aw==_2590977160638830144.jpg"  ></div>  <p style="TEXT-INDENT: 2em;"  >&nbsp;</p>  <p style="TEXT-INDENT: 2em;"  >4. 实现方式2：使用句柄类</p>  <p style="TEXT-INDENT: 2em;"  >为了避免上面方案中每个使用指针的类自己去控制引用计数，可以用一个类把指针封装起来。封装好后，这个类对象可以出现在用户类使用指针的任何地方，表现为一个指针的行为。我们可以像指针一样使用它，而不用担心普通成员指针所带来的问题，我们把这样的类叫句柄类。在封装句柄类时，需要申请一个动态分配的引用计数空间，指针与引用计数分开存储。实现示例如下：</p>  <p style="TEXT-INDENT: 2em;"  >class Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//基础对象类<br>{<br>public:<br>&nbsp;Point(int xVal = 0, int yVal = 0):x(xVal),y(yVal) { }<br>&nbsp;int getX() const { return x; }<br>&nbsp;int getY() const { return y; }<br>&nbsp;void setX(int xVal) { x = xVal; }<br>&nbsp;void setY(int yVal) { y = yVal; }</p>  <p style="TEXT-INDENT: 2em;"  >public:<br>&nbsp;virtual Point* clone() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//虚函数，为了实现让句柄类在不知道对象的确切类型的情况下分配已知对象的新副本<br>&nbsp;&nbsp;return new Point(*this);<br>&nbsp;}<br>&nbsp;<br>private:<br>&nbsp;int x,y;<br>};</p>  <p style="TEXT-INDENT: 2em;"  >class D3Point : public Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//派生类<br>{<br>public:<br>&nbsp;D3Point(int xVal, int yVal, int zVal):Point(xVal, yVal), z(zVal) { }<br>&nbsp;int getZ() const { return z; }<br>&nbsp;void setZ(int zVal) { z = zVal; }</p>  <p style="TEXT-INDENT: 2em;"  >public:<br>&nbsp;D3Point* clone() const {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //虚函数，为了实现让句柄类在不知道对象的确切类型的情况下分配已知对象的新副本<br>&nbsp;&nbsp;return new D3Point(*this);<br>&nbsp;}</p>  <p style="TEXT-INDENT: 2em;"  >private:<br>&nbsp;int z;<br>};</p>  <p style="TEXT-INDENT: 2em;"  >class SmartPtr<br>{<br>public:<br>&nbsp;SmartPtr(Point *ptr = 0):p(ptr), count(new int(1)) { }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造函数<br>&nbsp;SmartPtr(Point &amp;point):p(point.clone()), count(new int(1)) { }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造函数<br>&nbsp;SmartPtr(const SmartPtr &amp;sp):p(sp.p), count(sp.count) { ++*count; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //复制构造函数<br>&nbsp;SmartPtr&amp; operator=(const SmartPtr &amp;sp) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//重载赋值操作符<br>&nbsp;&nbsp;++*sp.count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//首先将右操作数引用计数加1，<br>&nbsp;&nbsp;decr_use();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;//然后将引用计数减1，可以应对自赋值<br>&nbsp;&nbsp;p = sp.p;<br>&nbsp;&nbsp;count = sp.count;<br>&nbsp;&nbsp;return *this;<br>&nbsp;}<br>&nbsp;~SmartPtr() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//析构函数<br>&nbsp;&nbsp;decr_use();<br>&nbsp;}</p>  <p style="TEXT-INDENT: 2em;"  >public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//一般情况下不会实现这两个操作符，因为我们不希望用户直接操纵基础对象指针<br>&nbsp;const Point* operator-&gt;() const {<br>&nbsp;&nbsp;&nbsp;return p;<br>&nbsp;&nbsp;else&nbsp;throw logic_error("Unbound Point");<br>&nbsp;}<br>&nbsp;const Point&amp; operator*() const {<br>&nbsp;&nbsp;&nbsp;return *p;<br>&nbsp;&nbsp;else&nbsp;throw logic_error("Unbound Point");<br>&nbsp;}</p>  <p style="TEXT-INDENT: 2em;"  >private:<br>&nbsp;void decr_use() {<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;delete p;<br>&nbsp;&nbsp;&nbsp;delete count;<br>&nbsp;&nbsp;}<br>&nbsp;}</p>  <p style="TEXT-INDENT: 2em;"  >private:<br>&nbsp;Point *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //基础对象指针<br>&nbsp;int *count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向引用计数的指针<br>};</p>  <p style="TEXT-INDENT: 2em;"  >int main()<br>{<br>&nbsp;Point *p1 = new Point(10, 8);<br>&nbsp;SmartPtr sp1(p1);<br>&nbsp;SmartPtr sp2(sp1);<br>&nbsp;D3Point *p2 = new D3Point(5, 5, 0);<br>&nbsp;SmartPtr sp3(p2);</p>  <p style="TEXT-INDENT: 2em;"  >&nbsp;return 0;<br>}</p>  <p style="TEXT-INDENT: 2em;"  >使用该方式的内存结构图如下：</p>  <div><img title="智能指针 - 玉宝的爱 - 07118332 的博客"  alt="智能指针 - 玉宝的爱 - 07118332 的博客"  style="MARGIN: 0px 10px 0px 0px;"  src="pic/img3.ph.126.net_7da09DGWzg3GiEt9S2kRwA==_1322369440603904723.jpg"  ></div>  <p style="TEXT-INDENT: 2em;"  >&nbsp;</p><br><wbr>
</body></html>