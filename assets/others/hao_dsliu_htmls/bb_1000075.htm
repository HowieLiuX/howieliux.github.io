<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Spin Locks</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Spin Locks</h2>
<p align="right">发布时间：2013-8-20 15:53
<br>分类名称：Driver</p><br>
<p><span style="font-family:Segoe UI; font-size:12pt;"   >From:&lt;</span>
<span style="font-family:Segoe UI; font-size:12pt;"   >Programming the Microsoft Windows Driver Model, 2nd Ed&gt;
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >To help you synchronize access to shared data in the symmetric multiprocessing world of Windows XP, the kernel lets you define any number of <em>spin lock</em> objects. To acquire a spin lock, code on one CPU executes an atomic operation that tests and then sets a memory variable in such a way that no other CPU can access the variable until the operation completes. If the test indicates that the lock was previously free, the program continues. If the test indicates that the lock was previously held, the program repeats the test-and-set in a tight loop: it "spins." Eventually the owner releases the lock by resetting the variable, whereupon one of the waiting CPUs' test-and-set operations will report the lock as free.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Figure 4-3 illustrates the concept of using a spin lock. Suppose we have some "resource" that might be used simultaneously on two different CPUs. To make the example concrete, imagine that the resource is the <em>LIST_ENTRY</em> cell that anchors a linked list of IRPs. The list might be accessed by one or more dispatch routines, a cancel routine, a DPC routine, and perhaps others as well. Any number of these routines might be executing simultaneously on different CPUs and trying to modify the list anchor. To prevent chaos, we associate a spin lock with this "resource."
</span></p><p><img title="Spin Locks - Howie - Dspace"   src="pic/img2.ph.126.net_5bFsttfVPGIDZMKnCBvz4A==_6597277574355400808.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p><span style="font-family:宋体; font-size:12pt;"   ><strong>Figure 4-3.</strong>
<em>Using a spin lock to guard a shared resource.</em>
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Suppose now that code executing on CPU A wants to access the shared resource at time <em>t1</em>. It acquires the spin lock and begins its access. Shortly afterward, at time <em>t2</em>, code executing on CPU B also wants to access the same resource. The CPU-B program tries to acquire the spin lock. Since CPU A currently owns the spin lock, CPU B spins in a tight loop, continually checking and rechecking the spin lock to see whether it has become free. When CPU A releases the lock at time <em>t3</em>, CPU B finds the lock free and claims it. Then CPU B has unfettered access to the resource. Finally, at time <em>t4</em>, CPU B finishes its access and releases the lock.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >I want to be very clear about how a spin lock and a shared resource come to be associated. <em>We</em> make the association when we design the driver. <em>We</em> decide that we will access the resource only while owning the spin lock. The operating system isn't aware of our decision. Furthermore, we can define as many spin locks as we want, to guard as many shared resources as we want.
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >Some Facts About Spin Locks 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >You need to know several important facts about spin locks. First of all, if a CPU already owns a spin lock and tries to obtain it a second time, the CPU will deadlock. No usage counter or owner identifier is associated with a spin lock; somebody either owns the lock or not. If you try to acquire the lock when it's owned, you'll wait until the owner releases it. If your CPU happens to already be the owner, the code that would release the lock can never execute because you're spinning in a tight loop testing and setting the lock variable.
</span></p><p style="background: #99ccff;"   ><span style="font-family:Segoe UI; font-size:12pt;"   ><strong>CAUTION</strong>
<br>You can certainly avoid the deadlock that occurs when a CPU tries to acquire a spin lock it already owns by following this rule: make sure that the subroutine that claims the lock releases it and never tries to claim it twice, and then don't call any other subroutine while you own the lock. There's no policeman in the operating system to ensure you don't call other subroutines—it's just an engineering rule of thumb that will help you avoid an inadvertent mistake. The danger you're guarding against is that you (or some maintenance programmer who follows in your footsteps) might forget that you've already claimed a certain spin lock. I'll tell you about an ugly exception to this salutary rule in Chapter 5, when I discuss IRP cancel routines.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >In addition, acquiring a spin lock raises the IRQL to <em>DISPATCH_LEVEL</em> automatically. Consequently, code that acquires a lock must be in nonpaged memory and must not block the thread in which it runs. (There is an exception in Windows XP and later systems. <em>KeAcquireInterruptSpinLock</em> raises the IRQL to the DIRQL for an interrupt and claims the spin lock associated with the interrupt.)
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >As an obvious corollary of the previous fact, you can request a spin lock only when you're running at or below <em>DISPATCH_LEVEL</em>. Internally, the kernel is able to acquire spin locks at an IRQL higher than <em>DISPATCH_LEVEL</em>, but you and I are unable to accomplish that feat.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Another fact about spin locks is that very little useful work occurs on a CPU that's waiting for a spin lock. The spinning happens at <em>DISPATCH_LEVEL</em> with interrupts enabled, so a CPU that's waiting for a spin lock can service hardware interrupts. But to avoid harming performance, you need to minimize the amount of work you do while holding a spin lock that some other CPU is likely to want.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Two CPUs can simultaneously hold two different spin locks, by the way. This arrangement makes sense: you associate a spin lock with a certain shared resource, or some collection of shared resources. There's no reason to hold up processing related to different resources protected by different spin locks.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >As it happens, there are separate uniprocessor and multiprocessor kernels. The Windows XP setup program decides which kernel to install after inspecting the computer. The multiprocessor kernel implements spin locks as I've just described. The uniprocessor kernel realizes, however, that another CPU can't be in the picture, so it implements spin locks a bit more simply. On a uniprocessor system, acquiring a spin lock raises the IRQL to <em>DISPATCH_LEVELand does nothing else</em>. Do you see how you still get the synchronization benefit from claiming the so-called lock in this case? For some piece of code to attempt to claim the same spin lock (or any other spin lock, actually, but that's not the point here), it would have to be running at or below <em>DISPATCH_LEVEL—</em>you can request a lock starting at or below <em>DISPATCH_LEVEL</em> only. But we already know that's impossible because, once you're above <em>PASSIVE_LEVEL</em>, you can't be interrupted by any other activity that would run at the same or a lower IRQL. Q., as we used to say in my high school geometry class, E.D.
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >Working with Spin Locks 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >To use a spin lock explicitly, allocate storage for a <em>KSPIN_LOCK</em> object in nonpaged memory. Then call <em>KeInitializeSpinLock</em> to initialize the object. Later, while running at or below <em>DISPATCH_LEVEL</em>, acquire the lock, perform the work that needs to be protected from interference, and then release the lock. For example, suppose your device extension contains a spin lock named <em>QLock</em> that you use for guarding access to a special IRP queue you've set up. You'll initialize this lock in your <em>AddDevice</em> function:
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >typedef&nbsp;struct&nbsp;_DEVICE_EXTENSION&nbsp;{
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;KSPIN_LOCK&nbsp;QLock;
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;}&nbsp;DEVICE_EXTENSION,&nbsp;*PDEVICE_EXTENSION;
</span></p><p style="background: #eeeeee;"   >
&nbsp;</p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   >
&nbsp;</p><p style="background: #eeeeee;"   >
&nbsp;</p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >NTSTATUS&nbsp;AddDevice(...)
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;{
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;PDEVICE_EXTENSION&nbsp;pdx&nbsp;=&nbsp;...;
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;KeInitializeSpinLock(&amp;pdx-&gt;QLock);
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;}
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Elsewhere in your driver, say in the dispatch function for some type of IRP, you can claim (and quickly release) the lock around some queue manipulation that you need to perform. Note that this function must be in nonpaged memory because it executes for a period of time at an elevated IRQL.
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >NTSTATUS&nbsp;DispatchSomething(...)
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;{
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;KIRQL&nbsp;oldirql;
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;PDEVICE_EXTENSION&nbsp;pdx&nbsp;=&nbsp;...;
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_o4xZqAEMBOlx3ioSmM3vXg==_6597594233704706412.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;KeAcquireSpinLock(&amp;pdx-&gt;QLock,&nbsp;&amp;oldirql);
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img2.ph.126.net__EBI9_cMmbgnY324V8ey_Q==_3370099896256938302.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;KeReleaseSpinLock(&amp;pdx-&gt;QLock,&nbsp;oldirql);
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >&nbsp;&nbsp;}
</span></p><ol><li><span style="font-family:Segoe UI; font-size:12pt;"   >When <em>KeAcquireSpinLock</em> acquires the spin lock, it also raises IRQL to <em>DISPATCH_LEVEL</em> and returns the current (that is, preacquisition) level in the variable to which the second argument points.
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >When <em>KeReleaseSpinLock</em> releases the spin lock, it also lowers IRQL back to the value specified in the second argument.
</span></li></ol><p><span style="font-family:Segoe UI; font-size:12pt;"   >If you know you're already executing at <em>DISPATCH_LEVEL</em>, you can save a little time by calling two special routines. This technique is appropriate, for example, in DPC, <em>StartIo</em>, and other driver routines that execute at <em>DISPATCH_LEVEL</em>:
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeAcquireSpinLockAtDpcLevel(&amp;pdx-&gt;QLock);
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeReleaseSpinLockFromDpcLevel(&amp;pdx-&gt;QLock);
</span></p><p><span style="color:black; font-family:Segoe UI; font-size:15pt;"   >Queued Spin Locks 
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Windows XP introduces a new type of spin lock, called an <em>in-stack queued spin lock</em>, that has a more efficient implementation than a regular spin lock. The mechanics of using this new kind of lock are a bit different from what I just described. You still allocate a <em>KSPIN_LOCK</em> object in nonpaged memory to which all relevant parts of your driver have access, and you still initialize it by calling <em>KeAcquireSpinLock</em>. To acquire and release the lock, however, you use code like the following:
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_o4xZqAEMBOlx3ioSmM3vXg==_6597594233704706412.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KLOCK_QUEUE_HANDLE&nbsp;qh;
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img2.ph.126.net__EBI9_cMmbgnY324V8ey_Q==_3370099896256938302.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeAcquireInStackQueuedSpinLock(&amp;pdx-&gt;QLock,&nbsp;&amp;qh);
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img0.ph.126.net_2rxg4pn8bTIOWe2rmS-syA==_2155816846727030967.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><img title="Spin Locks - Howie - Dspace"   src="pic/img2.ph.126.net_H7N_pPzdlfvxITOzl3BlKg==_2155816846727030966.jpg"   alt=""   /><span style="font-family:宋体; font-size:12pt;"   >
</span></p><p style="background: #eeeeee;"   ><span style="font-family:宋体; font-size:12pt;"   >KeReleaseInStackQueuedSpinLock(&amp;qh);
</span></p><ol><li><span style="font-family:Segoe UI; font-size:12pt;"   >The <em>KLOCK_QUEUE_HANDLE</em> structure is opaque—you're not supposed to know what it contains, but you do have to reserve storage for it. The best way to do that is to define an automatic variable (hence the <em>in-stack</em> part of the name).
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >Call <em>KeAcquireInStackQueuedSpinLock</em> instead of <em>KeAcquireSpinLock</em> to acquire the lock, and supply the address of the <em>KLOCK_QUEUE_HANDLE</em> object as the second argument.
</span></li><li><span style="font-family:Segoe UI; font-size:12pt;"   >Call <em>KeReleaseInStackQueuedSpinLock</em> instead of <em>KeReleaseSpinLock</em> to release the lock.
</span></li></ol><p><span style="font-family:Segoe UI; font-size:12pt;"   >The reason an in-stack queued spin lock is more efficient relates to the performance impact of a standard spin lock. With a standard spin lock, each CPU that is contending for ownership constantly modifies the same memory location. Each modification requires every contending CPU to reload the same dirty cache line. A queued spin lock, introduced for internal use in Windows 2000, avoids this adverse effect by cleverly using interlocked exchange and compare-exchange operations to track users and waiters for a lock. A waiting CPU continually reads (but does not write) a unique memory location. A CPU that releases a lock alters the memory variable on which the next waiter is spinning.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >Internal queued spin locks can't be directly used by driver code because they rely on a fixed-size table of lock pointers to which drivers don't have access. Windows XP added the <em>in-stack</em> queued spin lock, which relies on an automatic variable instead of the fixed-size table.
</span></p><p><span style="font-family:Segoe UI; font-size:12pt;"   >In addition to the two routines I showed you for acquiring and releasing this new kind of spin lock, you can also use two other routines if you know you're already executing at <em>DISPATCH_LEVEL</em>: <em>KeAcquireInStackQueuedSpinLockAtDpcLevel</em> and <em>KeReleaseInStackQueuedSpinLockFromDpcLevel</em>. (Try spelling <em>those</em> names three times fast!)
</span></p><p style="background: #99ccff;"   ><span style="font-family:Segoe UI; font-size:12pt;"   ><strong>NOTE</strong>
<br>Because Windows versions earlier than XP don't support the in-stack queued spin lock or interrupt spin lock routines, you can't directly call them in a driver intended to be binary portable between versions. The SPINLOCK sample driver shows how to make a run-time decision to use the newer spin locks under XP and the old spin locks otherwise.</span></p>
</body></html>