<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：模板相关知识总结</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>模板相关知识总结</h2>
<p align="right">发布时间：2014-5-30 16:20
<br>分类名称：Boost</p><br>
<p><span style="font-family:宋体; font-size:10pt;"   ><strong>注意</strong>
<br>这篇文章很多是由自己总结，甚至有的可能是凭空想象，可能有很多错误和不严谨的地方，读者需要带着怀疑和批判的眼光来读本文。 
</span></p><h1><span style="font-family:宋体; font-size:10pt;"   >定义一个模板
</span></h1><p><span style="font-family:宋体; font-size:10pt;"   ><strong><em>template&lt; parameter1, parameter2, …&gt;<br>functions / class definition
</em></strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >Parameter 一般有三种类型: 
</span></p><ol><li><span style="font-family:宋体; font-size:10pt;"   ><strong>type parameter（类型参数）</strong> : typename T. T可以是系统固有的类型如int，long，也可以是用户自定义类型。 
</span></li><li><span style="font-family:宋体; font-size:10pt;"   ><strong>Nontype parameter （非类型参数）</strong>: const value。表示方法如int n，char const *szStr，诸如此类的表示。有点像一个函数参数，但是又有限制，模板实例化时，只能传入const value。为何不能为变量？因为变量是运行时确定的，而模板是在编译时确定的。Const类型可以在编译时确定下来。
</span></li><li><span style="font-family:宋体; font-size:10pt;"   ><strong>template type parameter（模板类型的参数）</strong>：将一个类模板作为模板参数。
</span></li></ol><p><span style="font-family:宋体; font-size:10pt;"   >所以模板的定义可以细化如下： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong><em>template&lt;[type parameters， …], [Nontype parameters， …], [template type parameters,…] …&gt;<br>functions / class definition
</em></strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >[] 代表Option，可选。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >下面举例说明： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>只有type parameters的情况</strong><br>template &lt;class Type&gt;<br>class QueueItem;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;typename Type&gt;<br>inline Type min( Array&lt;Type&gt;, int );
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>type parameters 和 Nontype parameters共存的情况</strong><br>template &lt;typename Type, int size&gt;<br>Type min( Type (&amp;r_array)[size] );
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type, int size&gt;<br>class Buffer;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>只有Nontype parameters 的情况</strong><br>template&lt;CK_ULONG u&gt; struct type_trait;<br>template&lt;CK_ULONG&gt; struct type_trait;&nbsp;&nbsp;&nbsp;&nbsp;// u可以被省略，就如同函数参数在声明的时候可以被省略一样，但真正用的时候，不能省略。
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>有template type parameter的情况</strong><br>template &lt;class Type, template&lt;class&gt; class seq&gt;&nbsp;&nbsp;&nbsp;&nbsp;// U参数被省略<br>class Buffer;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type, template&lt;class U&gt; class seq&gt; // 两个参数都未被省略<br>class Buffer;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type, template&lt;class, size_t&gt; class seq&gt; // 两个参数都被省略<br>class Buffer2;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type, template&lt;class U, size_t nSize&gt; class seq&gt; // 两个参数都未被省略<br>class Buffer2;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>注释：声明一个template时候，和声明一个函数一样，Parameter可以被省略，只保留类型，如：</strong>
<br>template &lt;typename , unsigned long &gt;  // Type 和 n被省略。<br>class QueueItem;<br>&nbsp;<br>template &lt;class Type, unsigned long n&gt;<br>class QueueItem {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem( const Type &amp; i);<br>&nbsp;<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;Type item;<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem *next;<br>};<br>&nbsp;<br>template &lt;class Type, unsigned long n&gt;<br>QueueItem&lt;Type, n&gt;::QueueItem(const Type &amp; i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;item = i;<br>}<br>当然，模板也可以有默认参数： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type = int, int size = 30&gt;<br>class Buffer;
</span></p><h1><span style="font-family:宋体; font-size:10pt;"   >Template 基础知识点
</span></h1><p><span style="font-family:宋体; font-size:10pt;"   >下面是总结自C++ Primer： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>常见错误
</strong></span></p><p><span style="color:#8000ff;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > Type<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br>Type min1<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Type a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > Type b <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// C++ Primer : </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >错误</span></span><span style="color:green;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   >, </span><span style="font-family:宋体; background-color:white;"   >重新声明模板参数</span><span style="font-family:Courier New; background-color:white;"   > Type<br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// </span></span></span><span style="font-family:宋体; background-color:white;"   >但是我使用</span><span style="font-family:Courier New; background-color:white;"   >VS2010</span><span style="font-family:宋体; background-color:white;"   >编译通过，只是给出了一个警告</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >double<span style="color:black;"   > Type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;Type tmp <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   > a <span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>?</strong><span style="color:black;"   > a <span style="color:navy;"   ><strong>:</strong><span style="color:black;"   > b<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   > tmp<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// Type </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >重复使用。</span><span style="font-family:Courier New; background-color:white;"   >
</span><span style="font-family:宋体; background-color:white;"   >就如同参数名不能一样。一样了编译器就无法识别了。</span><span style="font-family:Courier New; background-color:white;"   ><br>// </span><span style="font-family:宋体; background-color:white;"   >所以判断一个语法是否正确的通法是：是否能够造成编译器无法分析</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > Type<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >class<span style="color:black;"   > Type<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br>Type min2<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Type a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > Type b<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// typename or class </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >关键字不能省略。</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >typename<span style="color:black;"   > T<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > U<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br>T sum<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > T<span style="color:navy;"   ><strong>*,</strong><span style="color:black;"   > U <span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >有时，编译器无法区分出是类型以及不是类型的表达式</span><span style="font-family:Courier New; background-color:white;"   ><br>// </span><span style="font-family:宋体; background-color:white;"   >如果编译器在模板定义中遇到表达式</span><span style="font-family:Courier New; background-color:white;"   >Parm::name </span><span style="font-family:宋体; background-color:white;"   >且</span><span style="font-family:Courier New; background-color:white;"   >Parm </span><span style="font-family:宋体; background-color:white;"   >这个模板类型参数代表了一个类</span><span style="font-family:Courier New; background-color:white;"   >, <br>// </span><span style="font-family:宋体; background-color:white;"   >那么</span><span style="font-family:Courier New; background-color:white;"   >name</span><span style="font-family:宋体; background-color:white;"   >引用的是</span><span style="font-family:Courier New; background-color:white;"   >Parm</span><span style="font-family:宋体; background-color:white;"   >的一个类型成员吗</span><span style="font-family:Courier New; background-color:white;"   >?<br>// </span><span style="font-family:宋体; background-color:white;"   >编译器不知道</span><span style="font-family:Courier New; background-color:white;"   >name</span><span style="font-family:宋体; background-color:white;"   >是否为一个类型</span><span style="font-family:Courier New; background-color:white;"   >, </span><span style="font-family:宋体; background-color:white;"   >因为它只有在模板被实例化之后才能找到</span><span style="font-family:Courier New; background-color:white;"   >Parm<br>// </span><span style="font-family:宋体; background-color:white;"   >表示的类的定义</span><span style="font-family:Courier New; background-color:white;"   >. </span><span style="font-family:宋体; background-color:white;"   >为了让编译器不为之混淆，你必须显示的告诉编译器它是否是个类型表达式，</span><span style="font-family:Courier New; background-color:white;"   ><br>// </span><span style="font-family:宋体; background-color:white;"   >使用</span><span style="font-family:Courier New; background-color:white;"   >typename</span><span style="font-family:宋体; background-color:white;"   >可以做到，所以在我转的另一篇的</span><span style="font-family:Courier New; background-color:white;"   >typename</span><span style="font-family:宋体; background-color:white;"   >的用法中提到，</span><span style="font-family:Courier New; background-color:white;"   >typename</span><span style="font-family:宋体; background-color:white;"   >用在模板中，目的是为了帮助编译器区分它是个类型，</span><span style="font-family:Courier New; background-color:white;"   ><br>//  </span><span style="font-family:宋体; background-color:white;"   >否则编译器默认将其看做一个成员对待。</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > Parm<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >class<span style="color:black;"   > U<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br>Parm minus<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Parm<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > array<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > U value <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;Parm<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >name <span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > p<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >这是一个指针声明还是乘法乘法？</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8000ff;"   >typename<span style="color:black;"   > Parm<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >name <span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > p<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// ok: </span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >指针声明</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// ok: </span></span></span></span><span style="font-family:宋体; background-color:white;"   >关键字跟在模板参数表之后</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >typename<span style="color:black;"   > Type<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >inline<span style="color:black;"   ><br>Type min<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Type<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > Type <span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >错误</span><span style="font-family:Courier New; background-color:white;"   >: inline </span><span style="font-family:宋体; background-color:white;"   >指示符放置的位置错误</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >inline<span style="color:black;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >typename<span style="color:black;"   > Type<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br>Type min<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Array<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >Type<span style="color:navy;"   ><strong>&gt;,</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >int<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >正确</span><span style="font-family:Courier New; background-color:white;"   >: inline </span><span style="font-family:宋体; background-color:white;"   >指示符放置的位置</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >typename<span style="color:black;"   > Type<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >inline<span style="color:black;"   > Type min<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > Array<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >Type<span style="color:navy;"   ><strong>&gt;,</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >int<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; font-size:10pt;"   >
</span></span></span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>函数模板实例化<br></strong>如果没有显示指定模板参数，这个过程是编译器隐式发生的，它可以被看作是函数模板调用或取函数模板的地址的<strong>副作用</strong>。 <br>在下面的程序中min()被实例化两次：一次是针对5 个int 的数组类型，另一次是针对6 个double 的数组类型。 <br>template &lt;typename Type, int size&gt;<br>Type min( Type (&amp;r_array)[size] )；<br>&nbsp;<br>// size 没有指定——ok<br>// size = 初始化表中的值的个数<br>int ia[] = { 10, 7, 14, 3, 25 };<br>double da[6] = { 10.2, 7.1, 14.5, 3.2, 25.0, 16.8 };<br>&nbsp;<br>// 为5 个int 的数组实例化min()<br>// Type =&gt; int, size =&gt; 5<br>int i = min( ia );<br>&nbsp;<br>// 为 6 个 double 的数组实例化 min()<br>// Type =&gt; double, size =&gt; 6<br>double d = min( da );<strong>
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>函数模板实参推演
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >为了判断用作模板实参的实际类型和值编译器需要检查函数调用中提供的函数实参的类型。在我们的例子中ia 的类型（即5 个int 的数组）和da 的类型（即6 个double 的数组）被用来决定每个实例的模板实参。用函数实参的类型来决定模板实参的类型和值的过程被称为<strong>模板实参推演</strong>（template argument deduction）。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >我们也可以不依赖模板实参推演过程，而是显式地指定模板实参。（需要调用者来明确） 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>函数模板在它被调用或取其地址时被实例化。</strong>在下面的例子中指针pf 被函数模板实例的地址初始化，编译器通过检查pf 指向的函数的参数类型来决定模板实例的实参。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;typename Type, int size&gt;<br>Type min( Type (&amp;p_array)[size] ) { /* ... */ }<br>&nbsp;<br>// pf 指向 int min( int (&amp;)[10] )<br>int (*pf)(int (&amp;)[10]) = &amp;min;<br>Type 的模板实参为int， size 的模板实参为10。 被实例化的函数是min(int(&amp;)[10])，指针pf 指向这个模板实例。 <br>在取函数模板实例的地址时，必须能够通过上下文环境为一个模板实参决定一个惟一的类型或值。如果不能决定出这个惟一的类型或值，就会产生编译时刻错误,例如： <br>template &lt;typename Type, int size&gt;<br>Type min( Type (&amp;r_array)[size] ) { /* ... */ }<br>&nbsp;<br>typedef int (&amp;rai)[10];<br>typedef double (&amp;rad)[20];<br>void func( int (*)(rai) );<br>void func( double (*)(rad) );<br>&nbsp;<br>int main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// 错误: 哪一个 min() 的实例?<br>&nbsp;&nbsp;&nbsp;&nbsp;func( &amp;min );<br>}
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >因为函数func()被重载了，所以编译器不可能通过查看func()的参数类型，来为模板参数Type 决定惟一的类型，以及为size 的模板实参决定一个惟一值。这种情况，可以使用显示调用: func&lt;int, 10&gt;(&amp;min)这种方式。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >C++ Primer讲述了模板实参推演的过程，我不建议去记忆和学习。因为曾经看过。看过多少遍，基本上就忘过多少遍。本人比较笨，希望能理解。呵呵。因为你知道了其原理和不知道其原理其实没有多大区别 ，在实际运用当中，很少需要你去了解那么深刻。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>显式指定（explicitly specify）函数模板实参
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >不依靠编译器，显式的实例化模板 <br>// min5( unsigned int, unsigned int ) 被实例化<br>min5&lt; unsigned int &gt;( ui, 1024 );<br>&nbsp;<br>// T1 不出现在函数模板参数表中<br>// 问题：T1 的模板实参不能从函数实参中被推演出来<br>template &lt;class T1, class T2, class T3&gt;<br>T1 sum( T2, T3 );<br>&nbsp;<br>// 错误: T1 不能被推演出来<br>ui_type loc1 = sum( ch, ui );<br>&nbsp;<br>// ok: 模板实参被显式指定<br>// T1 和 T3 是unsigned int, T2 是 char<br>ui_type loc2 = sum&lt; ui_type, char, ui_type &gt;( ch, ui );<br>在显式特化（explicit specification）中，我们只需列出不能被隐式推演的模板实参，如同缺省实参一样，我们只能省略尾部的实参例,例如： <br>// ok: T3 是 unsigned int<br>// T3 从 ui 的类型中推演出来<br>ui_type loc3 = sum&lt; ui_type, char &gt;( ch, ui );<br>&nbsp;<br>// ok: T2 是 char, T3 是 unsigned int<br>// T2 和 T3 从 pf 的类型中推演出来<br>ui_type (*pf)( char, ui_type ) = &amp;sum&lt; ui_type &gt;;<br>&nbsp;<br>// 错误: 只能省略尾部的实参<br>ui_type loc4 = sum&lt; ui_type, , ui_type &gt;( ch, ui );
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>类模板
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>声明<br></strong>template &lt;class T&gt;<br>class QueueItem;<br>&nbsp;<br>template &lt;class Type, int size&gt;<br>class Buffer;<br>&nbsp;<br>// 模板实例没有指定size的大小时，默认为1024<br>template &lt;class Type, int size=1024&gt;<br>class Buffer;<br><strong>定义<br></strong>template &lt;class Type&gt;<br>class QueueItem {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem( const Type &amp; );<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;Type item;<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem *next;<br>};<br>在类模板定义中吗，类模板的名字（QueueItem）相当于是（QueueItem&lt;Type&gt;）的缩写。这种简写形式只能被用在类模板QueueItem 自己的定义中, 以及在类模板定义之外出现的成员定义中。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>类模板实例化
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >从通用的类模板定义中生成类的过程被称为模板实例化（template instantiation）。类模板定义指定了怎样根据一个或多个实际的类型或值的集合来构造单独的类。Queue的类模板定义被用作"Queue类的特定类型的实例"的自动生成模板。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >Queue&lt;int&gt; qi;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >一个针对int 型对象的Queue 类就被从通用类模板定义中创建出来。所以，是实例的类型越多，被编译器实例化出来的类就越多，你的程序也就越庞大。所以，<strong>程序大小有要求的，最好不要用模板。</strong>
<br>与函数模板实例的模板实参不同的是，根据类模板实例被使用的上下文环境，编译器无法推断出类模板实例的模板实参 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >Queue qs; // 错误: 哪一个模板实例?
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>只有当代码中使用了类模板的一个实例的名字，并且上下文环境要求必须存在类的定义时，这个类模板才被实例化。并不是每次使用一个类都要求知道该类的定义。</strong> 如： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >class Matrix;<br>Matrix *pm; // ok: 不需要类 Matrix 的定义<br>void inverse( Matrix &amp; ); // ok 也不需要<br>&nbsp;<br>// Queue&lt;int&gt; 没有为其在 foo() 中的使用实例化<br>void foo( Queue&lt;int&gt; &amp;qi )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;int&gt; *pqi = &amp;qi;<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>}
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >所以<strong>声明一个类模板实例的指针和引用不会引起类模板被实例化</strong>。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >定义一个类的对象时需要该类的定义。例如在下面的例子中，obj1 的定义就是错的。这个对象的定义要求让编译器知道Matrix 的大小，以便为obj1 分配正确的内存数 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >class Matrix;<br>Matrix obj1; // 错误: Matrix 没有被定义<br>&nbsp;<br>class Matrix { ... };<br>Matrix obj2; // ok
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>如果一个对象的类型是一个类模板的实例，那么当对象被定义时，类模板也被实例化</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >Queue&lt;int&gt; qi;  // Queue&lt;int&gt; 被实例化
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>如果一个指针或引用指向一个类模板实例，那么只有当检查这个指针或引用所指的那个对象时，类模板才会被实例化。</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >void foo( Queue&lt;int&gt; &amp;qi )<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;int&gt; *pqi = &amp;qi;<br>&nbsp;&nbsp;&nbsp;&nbsp;// 因为成员函数被调用, 所以 Queue&lt;int&gt; 被实例化<br>&nbsp;&nbsp;&nbsp;&nbsp;pqi-&gt;add( 255 );<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>}
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>非类型参数的模板实参
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>绑定给非类型参数的表达式必须是一个常量表达式，也就是在编译时刻能够被计算出来。</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >// 这么定义是没问题的<br>template &lt;int *ptr&gt; class BufPtr { ... };<br>&nbsp;<br>// 但是如果这么实例化就是不对的，因为模板实参不能在编译时刻被计算出来<br>BufPtr&lt; new int[24] &gt; bp;<br>template &lt;int size&gt; Buf{ ... };<br>template &lt;int *ptr&gt; class BufPtr { ... };<br>&nbsp;<br>int size_val = 1024;<br>const int c_size_val = 1024;<br>Buf&lt; 1024 &gt; buf0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ok<br>Buf&lt; c_size_val &gt; buf1; &nbsp;&nbsp;&nbsp;&nbsp;// ok<br>Buf&lt; sizeof(size_val) &gt; buf2; &nbsp;&nbsp;&nbsp;&nbsp;// ok: sizeof(int)<br>BufPtr&lt; &amp;size_val &gt; bp0; &nbsp;&nbsp;&nbsp;&nbsp;// ok<br>&nbsp;<br>// 错误：不能在编译时刻计算出来。<br>Buf&lt; size_val &gt; buf3;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>类模板的成员函数</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >// 内部定义<br>template &lt;class Type&gt;<br>class Queue {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;// inline 构造成员函数<br>&nbsp;&nbsp;&nbsp;&nbsp;Queue() : front( 0 ), back ( 0 ) { }<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>};<br>&nbsp;<br>// 外部定义<br>template &lt;class Type&gt;<br>class Queue {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Queue( );<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>};<br>template &lt;class Type&gt;<br>inline Queue&lt;Type&gt;::<br>&nbsp;&nbsp;&nbsp;&nbsp;Queue( ) { front = back = 0; }
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >类模板的成员函数本身也是一个模板。<strong>标准C++要求这样的成员函数只有在被调用或者取地址时，才被实例化（标准C++之前的有些编译器在实例化类模板时，就实例化类模板的成员函数。）</strong>用来实例化成员函数的类型就是其成员函数要调用的那个类对象的类型。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >Queue&lt;string&gt; qs;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >对象qs 的类型是Queue&lt;string&gt; 。当初始化这个类对象时，Queue&lt;string&gt;类的构造函数被调用，在这种情况下用来实例化构造函数的模板实参是string。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>常见错误
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >// 错误: 必须是 &lt;typename T, class U&gt; 或 &lt;typename T, typename U&gt;<br>template &lt;typename T, U&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;class collection;<br>在下面的例子中，item 的类型不是double，它的类型是模板参数的类型： <br>typedef double Type;<br>template &lt;class Type&gt;<br>class QueueItem {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;// item 不是 double 类型<br>&nbsp;&nbsp;&nbsp;&nbsp;Type item;<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem *next;<br>};<br>&nbsp;<br>// 错误: 重复使用名为Type 的模板参数<br>template &lt;class Type, class Type&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;class container;<br>&nbsp;<br>template &lt;class Type&gt;<br>class Queue {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>private:<br>// 错误: QueueItem 不是一个已知类型<br>// 应该为QueueItem&lt;Type&gt;, 或者确定类型: QueueItem&lt;int&gt;之类的<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem *front;<br>};
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>书和编译器的一些分歧
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class Type&gt;<br>class QueueItem {<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>private:<br>// C++ Primer：错误: 成员名不能与模板参数 Type 同名<br>// 但我使用VS2008，VS2010，VS2012都可以编译通过，而且没有任何警告。<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef double Type;<br>&nbsp;&nbsp;&nbsp;&nbsp;Type item;<br>&nbsp;&nbsp;&nbsp;&nbsp;QueueItem *next;<br>};<br>&nbsp;<br>// C++ Primer: ok: 考虑两个声明中的缺省实参<br>// 但我使用VS2008，VS2010，VS2012无法编译通过，编译器要求size也得需要默认值。<br>template &lt;class Type = string , int size&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;class Buffer;
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>模板特化
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >模板特化是C++语言中，很奇特的一种技术。以它为理论基础，出现了元模板编程，大量运用在Boost模板库中。<br>关于为什么模板需要特化模板，这里不做详细说明，可以自行百度。特化从某种程度上说，是为了控制编译器实例化模板，让其更加精确的实例化出对应的模板。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >如果将模板看成所有可能性，那模板特化就是部分可能性。特化限定了所有可能性的一部分特性，模板特化相当于整个模板的一个子集。 编译器实例化模板的过程，也属于模板特化的一种。而我们这里说的是由程序员显式的控制模板的特化。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >模板特化分为<strong>全特化</strong>和<strong>半特化（或叫偏特化）</strong>。 <strong>类模板和函数模板都能全特化，而函数模板无法半特化，只有类模板可以半特化。</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>模板全特化
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >全特化的格式为： <br>template&lt;&gt;<br>function/class classname&lt;parameter instances…&gt;<br>例如： <br>// 定义Compare模板<br>template&lt;class T&gt;<br>class Compare<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;static bool IsEqual(const T&amp; lh, const T&amp; rh)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return lh == rh;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br>&nbsp;<br>// 特化模板为： float<br>template&lt;&gt;<br>class Compare&lt;float&gt;<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;static bool IsEqual(const float&amp; lh, const float&amp; rh)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return abs(lh - rh) &lt; 10e-3;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br>&nbsp;<br>// 特化模板为： double<br>template&lt;&gt;<br>class Compare&lt;double&gt;<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;static bool IsEqual(const double&amp; lh, const double&amp; rh)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return abs(lh - rh) &lt; 10e-6;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong>模板半特化
</strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >半特化的格式为： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   ><strong><em>template&lt;parameters...&gt;<br>function/class classname&lt;parameters..., parameter instances…&gt;
</em></strong></span></p><p><span style="font-family:宋体; font-size:10pt;"   >半特化，就是没有完全特化，只特化了部分模板参数，如： 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >template &lt;class T, class Allocator&gt;<br>class vector { // … // };<br>&nbsp;<br>//将class T，特化为bool,而Allocator没有被特化。注意半特化格式的写法<br>template &lt;class Allocator&gt;<br>class vector&lt;bool, Allocator&gt; { //…//};<br>半特化同样要在函数或者类名后面同样要加上&lt;&gt;, 里面填入特化的参数，但没有特化的的参数，仍然使用原参数，但template的&lt;&gt;中的参数不为空，其中留下不特化的参数。 
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >全特化，半特化和模板定义外观类似，不容易区分，容易使人混淆。这里有个区分<strong>技巧</strong>：<br><strong>是不是模板特化不是看template&lt;&gt;，而是看函数，或者类名后面是是否有'&lt;实例参数&gt;'，如果有，那就是说明这个定义正在特例化。</strong>
</span></p><p><span style="font-family:宋体; font-size:10pt;"   >上面的例子，将模板特化为实际的类型，（class T，特化为bool），还能特化"半成品"，这个半成品主要就是指针和引用，如： 
</span></p><p><span style="color:#8000ff;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >struct<span style="color:black;"   > iterator_traits <span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >typename<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >iterator_category iterator_category<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >typename<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >value_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >typename<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >difference_type&nbsp;&nbsp;&nbsp;&nbsp; difference_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >typename<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >typename<span style="color:black;"   > _Iterator<span style="color:navy;"   ><strong>::</strong><span style="color:black;"   >reference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reference<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// specialize for _Tp*, </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >特化为一个指针</span></span><span style="color:green;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >struct<span style="color:black;"   > iterator_traits<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >_Tp<span style="color:navy;"   ><strong>*&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > random_access_iterator_tag iterator_category<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > _Tp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > ptrdiff_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; difference_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reference<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >// specialize for const _Tp*</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >，特化为一个</span><span style="font-family:Courier New; background-color:white;"   >const </span><span style="font-family:宋体; background-color:white;"   >指针。</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >struct<span style="color:black;"   > iterator_traits<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >const<span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>*&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > random_access_iterator_tag iterator_category<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > _Tp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   > ptrdiff_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; difference_type<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >const<span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>typedef</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >const<span style="color:black;"   > _Tp<span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reference<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >一个完整的特化例子</span></span><span style="color:black;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   >
<br><span style="color:#804000;"   >#include &lt;iostream&gt;<br><span style="color:blue;"   ><strong>using</strong><span style="color:black;"   >
<span style="color:blue;"   ><strong>namespace</strong><span style="color:black;"   > std<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:#804000;"   >#include &lt;string&gt;<br>#include &lt;vector&gt;<br><span style="color:black;"   >
<br><span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >一个简<span style="color:green;"   >单的加法模板</span></span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:#8000ff;"   >template<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >class<span style="color:black;"   > Addition<br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >public<span style="color:navy;"   ><strong>:</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;T fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > T a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > T b <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > a <span style="color:navy;"   ><strong>+</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >/*<br>** </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >特化</span></span><span style="color:green;"   ><span style="font-size:10pt;"   ><span style="font-family:Courier New; background-color:white;"   >1<br>** </span><span style="font-family:宋体; background-color:white;"   >类模板特化（</span><span style="font-family:Courier New; background-color:white;"   >specialization</span><span style="font-family:宋体; background-color:white;"   >）</span><span style="font-family:Courier New; background-color:white;"   ><br>** </span><span style="font-family:宋体; background-color:white;"   >特化之前需要有类模板的声明</span><span style="font-family:Courier New; background-color:white;"   ><br>*/<span style="color:black;"   ><br><span style="color:#8000ff;"   >template<span style="color:navy;"   ><strong>&lt;&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >class<span style="color:black;"   > Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >char<span style="color:black;"   >
<span style="color:navy;"   ><strong>*&gt;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >public<span style="color:navy;"   ><strong>:</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >/*<br>&nbsp;&nbsp;&nbsp;&nbsp;** </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >对每个函数和变量进行特化</span><span style="font-family:Courier New; background-color:white;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;** </span><span style="font-family:宋体; background-color:white;"   >当然这里只有一个函数，哈</span><span style="font-family:Courier New; background-color:white;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;*/<span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8000ff;"   >char<span style="color:black;"   >
<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >char<span style="color:black;"   >
<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >char<span style="color:black;"   >
<span style="color:navy;"   ><strong>*</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >/*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** OMG</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >，正式的代码可不能这样写</span><span style="font-family:Courier New; background-color:white;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** </span><span style="font-family:宋体; background-color:white;"   >这儿只是个例子，将就，将就</span><span style="font-family:Courier New; background-color:white;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat_s<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >11<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >/*<br>** </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >特化</span><span style="font-family:Courier New; background-color:white;"   >2<br>** </span><span style="font-family:宋体; background-color:white;"   >特化为引用，指针类型</span><span style="font-family:Courier New; background-color:white;"   ><br>** </span><span style="font-family:宋体; background-color:white;"   >这样的特化其实是一种</span><span style="font-family:Courier New; background-color:white;"   >"</span><span style="font-family:宋体; background-color:white;"   >偏特化</span><span style="font-family:Courier New; background-color:white;"   >"<br>** </span><span style="font-family:宋体; background-color:white;"   >偏特化，半特化，局部特化，部分特化</span><span style="font-family:Courier New; background-color:white;"   >……</span><span style="font-family:宋体; background-color:white;"   >翻译五花八门</span><span style="font-family:Courier New; background-color:white;"   ><br>** </span><span style="font-family:宋体; background-color:white;"   >还是记住英文比较好：</span><span style="font-family:Courier New; background-color:white;"   >partial specialization<br>** </span><span style="font-family:宋体; background-color:white;"   >在编码时，总纠结着是指针好呢，还是引用好呢，要加</span><span style="font-family:Courier New; background-color:white;"   >const</span><span style="font-family:宋体; background-color:white;"   >乎？</span><span style="font-family:Courier New; background-color:white;"   ><br>** </span><span style="font-family:宋体; background-color:white;"   >有了这样的特化，确实方便甚多。</span><span style="font-family:Courier New; background-color:white;"   ><br>*/<span style="color:black;"   ><br><span style="color:#8000ff;"   >template<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >class<span style="color:black;"   > Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >T <span style="color:navy;"   ><strong>&amp;&gt;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >public<span style="color:navy;"   ><strong>:</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;T <span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > T <span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > T <span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   > a <span style="color:navy;"   ><strong>+</strong><span style="color:black;"   > b<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:green;"   >/*<br>** </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >特化</span><span style="font-family:Courier New; background-color:white;"   >3<br>** </span><span style="font-family:宋体; background-color:white;"   >还可以这样特化</span><span style="font-family:Courier New; background-color:white;"   ><br>*/<span style="color:black;"   ><br><span style="color:#8000ff;"   >template<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >class<span style="color:black;"   > T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >class<span style="color:black;"   > Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   > vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br><span style="color:#8000ff;"   >public<span style="color:navy;"   ><strong>:</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >T<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&amp;</strong><span style="color:black;"   > b <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >/*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >假想着两个</span><span style="font-family:Courier New; background-color:white;"   >vector</span><span style="font-family:宋体; background-color:white;"   >大小一样</span><span style="font-family:Courier New; background-color:white;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>for</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >int<span style="color:black;"   > i <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >0<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   > i <span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>(</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>)</strong><span style="color:black;"   >a<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >size<span style="color:navy;"   ><strong>();</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>++</strong><span style="color:black;"   >i <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<span style="color:navy;"   ><strong>[</strong><span style="color:black;"   >i<span style="color:navy;"   ><strong>]</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>+=</strong><span style="color:black;"   > b<span style="color:navy;"   ><strong>[</strong><span style="color:black;"   >i<span style="color:navy;"   ><strong>];</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   > a<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>};</strong><span style="color:black;"   ><br>
<br><span style="color:#8000ff;"   >int<span style="color:black;"   > main<span style="color:navy;"   ><strong>()</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   > A<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > A<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >10<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >20<span style="color:black;"   >
<span style="color:navy;"   ><strong>)</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > endl<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >将特化</span><span style="font-family:Courier New; background-color:white;"   >1</span><span style="font-family:宋体; background-color:white;"   >的代码注释会怎么样？</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8000ff;"   >char<span style="color:black;"   > str1<span style="color:navy;"   ><strong>[</strong><span style="color:#ff8000;"   >11<span style="color:navy;"   ><strong>]</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:gray;"   >"aaaaa"<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8000ff;"   >char<span style="color:black;"   > str2<span style="color:navy;"   ><strong>[]</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:gray;"   >"BBBBB"<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >char<span style="color:black;"   >
<span style="color:navy;"   ><strong>*&gt;</strong><span style="color:black;"   > B<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > B<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > str1<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > str2 <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > endl<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >将特化</span><span style="font-family:Courier New; background-color:white;"   >2</span><span style="font-family:宋体; background-color:white;"   >的代码注释会怎么样？</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;string cs1 <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:gray;"   >"sssss"<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;string cs2 <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:gray;"   >"ddddd"<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >string <span style="color:navy;"   ><strong>&amp;&gt;</strong><span style="color:black;"   > C<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > C<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > cs1<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > cs2 <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > endl<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"   >// </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; background-color:white;"   >特化</span><span style="font-family:Courier New; background-color:white;"   >3</span><span style="font-family:宋体; background-color:white;"   >的例子</span><span style="font-family:Courier New; background-color:white;"   ><br><span style="color:black;"   >&nbsp;&nbsp;&nbsp;&nbsp;vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   > v1<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;v1<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >push_back<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >10<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;v1<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >push_back<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >20<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   > v2<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;v2<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >push_back<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >100<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;v2<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >push_back<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >200<span style="color:black;"   >
<span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;Addition<span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   > vector<span style="color:navy;"   ><strong>&lt;</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&gt;</strong><span style="color:black;"   > D<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;D<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >fun<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   > v1<span style="color:navy;"   ><strong>,</strong><span style="color:black;"   > v2 <span style="color:navy;"   ><strong>);</strong><span style="color:black;"   ><br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>for</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>(</strong><span style="color:black;"   >
<span style="color:#8000ff;"   >int<span style="color:black;"   > i <span style="color:navy;"   ><strong>=</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >0<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   > i <span style="color:navy;"   ><strong>&lt;</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>(</strong><span style="color:#8000ff;"   >int<span style="color:navy;"   ><strong>)</strong><span style="color:black;"   >v1<span style="color:navy;"   ><strong>.</strong><span style="color:black;"   >size<span style="color:navy;"   ><strong>();</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>++</strong><span style="color:black;"   >i <span style="color:navy;"   ><strong>)</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>{</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > v1<span style="color:navy;"   ><strong>[</strong><span style="color:black;"   >i<span style="color:navy;"   ><strong>]</strong><span style="color:black;"   >
<span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   >
<span style="color:gray;"   >" "<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"   ><strong>}</strong><span style="color:black;"   ><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:navy;"   ><strong>&lt;&lt;</strong><span style="color:black;"   > endl<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"   ><strong>return</strong><span style="color:black;"   >
<span style="color:#ff8000;"   >0<span style="color:navy;"   ><strong>;</strong><span style="color:black;"   ><br><span style="color:navy;"   ><strong>}</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family:宋体; font-size:10pt;"   ><br></span></span><span style="font-family:宋体; font-size:10pt;"   >特化的目的是为了让编译器精确匹配。每种特化的结构体里的</span></span><span style="font-family:宋体; font-size:10pt;"   >typedef</span></span><span style="font-family:宋体; font-size:10pt;"   >都可能不一样。这样，在编译器这一层面上，就能实现一种多态的效果</span></span><span style="font-family:宋体; font-size:10pt;"   >,这种编程叫做模板元编程,可以参考《Boost 程序库探秘》第一章。</span></p>
</body></html>