<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More</h2>
<p align="right">发布时间：2012-8-31 13:38
<br>分类名称：C++</p><br>
<p><span style="font-family:宋体; font-size:13pt;"  ><strong>UNREFERENCED_PARAMETER  </strong></span></p><p><span style="font-family:宋体;"  ><span style="font-size:13pt;"  >作用：告诉编译器，已经使用了该变量，不必检测警告！</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:宋体;"  ><span style="font-size:13pt;"  >在VC编译器下，如果您用最高级别进行编译，编译器就会很苛刻地指出您的非常细小的警告。当你生命了一个变量，而没有使用时，编译器就会报警告：</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:宋体;"  ><span style="font-size:13pt;"  >"warning C4100: ''ＸＸＸＸ'' : unreferenced formal parameter."&nbsp;</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:宋体;"  ><span style="font-size:13pt;"  >所以，为了让编译器不必检测你的警告，就使用UNREFERENCED_PARAMETER语句。比如：</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:宋体;"  ><span style="font-size:13pt;"  >int SomeFunction(int arg1, int arg2)<br>{<br>&nbsp; UNREFERENCED_PARAMETER(arg2)<br>&nbsp; ...<br>}</span><span style="font-size:12pt;"  >    </span></span></p><p><span style="font-family:宋体; font-size:12pt;"  >=======================================================================================================<br>From: http://msdn.microsoft.com/en-us/magazine/cc163805.aspx<br>Paul DiLascia<br><br>Code download available at: <a rel="nofollow" href="http://download.microsoft.com/download/2/e/9/2e9bde04-3af1-4814-9f1e-733f732369a3/CAtWork0505.exe"  ><span style="color:blue; text-decoration:underline;"  >CAtWork0505.exe</span></a> (171 KB) <br><a rel="nofollow" href="http://msdn.microsoft.com/en-us/magazine/cc164688.aspx"  ><span style="color:blue; text-decoration:underline;"  >Browse the Code Online</span></a>    <br><br>Q I've seen C++ code that uses UNREFERENCED_PARAMETER for parameters that aren't used. For example: <br><strong>int SomeFunction(int arg1, int arg2)<br>{<br>  UNREFERENCED_PARAMETER(arg2)<br>  ...<br>}<br></strong>But I also see code like this <br><strong>int SomeFunction(int arg1, int /* arg2 */)<br>{<br>  ...<br>}<br></strong>Can you explain what the difference is and which is better?<br>Q I've seen C++ code that uses UNREFERENCED_PARAMETER for parameters that aren't used. For example: <br><strong>int SomeFunction(int arg1, int arg2)<br>{<br>  UNREFERENCED_PARAMETER(arg2)<br>  ...<br>}<br></strong>But I also see code like this <br><strong>int SomeFunction(int arg1, int /* arg2 */)<br>{<br>  ...<br>}<br></strong>Can you explain what the difference is and which is better?<br><em>Judy McGeough</em>    <br><br>A Why surely. Let's start with UNREFERENCED_PARAMETER. This macro is defined in winnt.h, like so: <br><strong>#define UNREFERENCED_PARAMETER(P) (P)<br></strong>In other words, UNREFERENCED_PARAMETER expands to the parameter or expression passed. Its purpose is to avoid compiler warnings about unreferenced parameters. Many programmers, including yours truly, like to compile with the highest warning level, Level 4 (/W4). Level 4 warnings fall into the category of "things that can be safely ignored." Little infelicities that won't break your code, though they might make you look bad. For example, you might have some line of code in your program like this <br><strong>int x=1;<br></strong>but you never use x. Perhaps this line is left over from a time when you did use x, but then you removed the code and forgot to remove the variable. Warning Level 4 can find these minor mishaps. So why not let the compiler help you achieve the highest level of professionalism possible? Compiling with Level 4 is a way to show pride in your work. Level 4 is de rigueur if you're writing a library for public consumption. You don't want to force your developers to use a lower level to compile their code cleanly.<br>A Why surely. Let's start with UNREFERENCED_PARAMETER. This macro is defined in winnt.h, like so: <br><strong>#define UNREFERENCED_PARAMETER(P) (P)<br></strong>In other words, UNREFERENCED_PARAMETER expands to the parameter or expression passed. Its purpose is to avoid compiler warnings about unreferenced parameters. Many programmers, including yours truly, like to compile with the highest warning level, Level 4 (/W4). Level 4 warnings fall into the category of "things that can be safely ignored." Little infelicities that won't break your code, though they might make you look bad. For example, you might have some line of code in your program like this <br><strong>int x=1;<br></strong>but you never use x. Perhaps this line is left over from a time when you did use x, but then you removed the code and forgot to remove the variable. Warning Level 4 can find these minor mishaps. So why not let the compiler help you achieve the highest level of professionalism possible? Compiling with Level 4 is a way to show pride in your work. Level 4 is de rigueur if you're writing a library for public consumption. You don't want to force your developers to use a lower level to compile their code cleanly.<br>The problem is, Level 4 is really fussy. At Level 4, the compiler complains about such harmless things as—well, unreferenced parameters (unless, of course, you really did mean to use the parameter, in which case it's not so harmless). Say you have a function with two arguments, but you only use one: <br><strong>int SomeFunction(int arg1, int arg2)<br>{<br>  return arg1+5;<br>}<br></strong>With /W4, the compiler complains: "warning C4100: 'arg2' : unreferenced formal parameter." To fool the compiler, you can add UNREFERENCED_PARAMETER(arg2). Now your function references arg2 so the compiler will shut up. And since the statement <br><strong>arg2;<br></strong>doesn't actually do anything, the compiler doesn't generate any code for it, so there's no loss of either space or efficiency.<br>Sharp minds might wonder: if you don't use arg2, why declare it in the first place? Usually it's because you're implementing a function to meet some API signature ordained from the heavens. For example, MFC's OnSize handler must have the following signature: <br><strong>void OnSize(UINT nType, int cx, int cy);<br></strong>Here cx/cy are the window's new width/height and nType is a code like SIZE_MAXIMIZED if the window is being maximized or SIZE_RESTORED for normal sizing. Usually you don't care about nType; you only care about cx and cy. So you need UNREFERENCED_PARAMETER(nType) if you want to compile with /W4. OnSize is just one function among thousands in MFC and Windows?. It's hardly possible to write a Windows-based program without unreferenced parameters.<br>So much for UNREFERENCED_PARAMETER. As Judy notes in her question, another trick C++ programmers often use to achieve the same result is to comment the parameter name out of the function signature: <br><strong>void CMyWnd::OnSize(UINT /* nType */, <br>  int cx, int cy)<br>{<br>}<br></strong>Now nType is an unnamed parameter, the same as if you'd typed OnSize(UINT, int cx, int cy). So now the $64,000 question is: which method should you use—unnamed parameters or UNREFERENCED_PARAMETER?<br>Most of the time it makes no difference, it's purely a style thing. (Do you like your java black or with cream?) But I can think of at least one situation where UNREFERENCED_PARAMETER is required. Suppose you've decided to disallow maximizing your window. You disable the Maximize button, remove Maximize from the system menu, and block every other place the user could maximize. Because you're paranoid (and most good programmers are paranoid), you add an ASSERT to ensure that your code is working as you intended: <br><strong>void CMyWnd::OnSize(UINT nType, int cx, int cy)<br>{<br>  ASSERT(nType != SIZE_MAXIMIZE);<br>  ...   // use cx, cy<br>}<br></strong>The QA team runs your program 87 ways and the ASSERT never bombs, so you figure it's safe to compile a Release build. But now without _DEBUG defined, ASSERT(nType != SIZE_MAXIMIZE) expands to ((void)0) and suddenly nType becomes an unreferenced parameter! There goes your clean compile. You can't comment nType out of the parameter list because you need it for the ASSERT. So in this situation—where the only place you use a parameter is within an ASSERT or other _DEBUG-conditional code—only UNREFERENCED_PARAMETER will keep the compiler happy in both Debug and Release builds. Got it?<br>Before closing, I'd be remiss not to mention that you can suppress individual compiler warnings using a pragma like so: <br><strong>#pragma warning( disable : 4100 )<br></strong>4100 is the error code for unreferenced parameter. The pragma suppresses the warning for the rest of the file/module. You can reenable the warning like so: <br><strong>#pragma warning( default : 4100 )<br></strong>However, a better approach is to store all of the warning states before disabling the specific warning, and then go back to that configuration when you're done. That way, you get back to the state you were at previously and not just the compiler default.<br>So you could suppress unreferenced parameter warnings for a single function by surrounding it with pragmas like this: <br><strong>#pragma warning( push ) <br>#pragma warning( disable : 4100 )<br>void SomeFunction(...)<br>{<br>}<br>#pragma warning( pop )<br></strong>Of course, that's way too verbose for unreferenced parameters, but possibly necessary for other kinds of warnings. Library builders use #pragma warning all the time to block warnings so their code can compile cleanly with /W4. MFC is full of such pragmas. There're even more #pragma warning options I haven't mentioned. Check 'em out in the documentation.<br><br>Q I've noticed that some apps have special commands when you right-click on their minimized button in the task bar. For example, WinAmp (a popular media player program) has an added "WinAmp" menu item with WinAmp commands. How can I add my own items to my app's task bar button?<br>Q I've noticed that some apps have special commands when you right-click on their minimized button in the task bar. For example, WinAmp (a popular media player program) has an added "WinAmp" menu item with WinAmp commands. How can I add my own items to my app's task bar button?<br><em>Jirair Osygian</em>    <br><br>Q I've created a simple MFC single document interface (SDI) application with a form view to display a counter. I want to be able to start and stop the counter by right-clicking on the minimized application down on the task bar. The start and stop functions work fine as buttons on my form, and I was able to add the start/stop commands to the system menu. But when I click on them in the system menu, nothing happens. How can I handle these messages from my modified system menu?<br>Q I've created a simple MFC single document interface (SDI) application with a form view to display a counter. I want to be able to start and stop the counter by right-clicking on the minimized application down on the task bar. The start and stop functions work fine as buttons on my form, and I was able to add the start/stop commands to the system menu. But when I click on them in the system menu, nothing happens. How can I handle these messages from my modified system menu?<br><em>Monicque Sharman</em>    <br><br>A I'll answer both questions in one fell swoop. The answer to Jirair's question is simple: the menu the user sees when you right-click on an application's minimized task bar button is the same as the menu displayed if she clicks on the application icon in the top-left corner of the caption bar or presses Alt+Space. <strong>Figure 1</strong> shows what I mean. This menu is called the system menu and has commands like Restore, Minimize, Maximize, and Close.<br>A I'll answer both questions in one fell swoop. The answer to Jirair's question is simple: the menu the user sees when you right-click on an application's minimized task bar button is the same as the menu displayed if she clicks on the application icon in the top-left corner of the caption bar or presses Alt+Space. <strong>Figure 1</strong> shows what I mean. This menu is called the system menu and has commands like Restore, Minimize, Maximize, and Close.<br><img title="Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More - Howie - Dspace"  src="pic/img0.ph.126.net_WA5NCKHgTX_FgjoJtavhrg==_2797298318568199720.jpg"  alt=""  /><br>Figure 1<strong>&nbsp;Sys Menu&nbsp;</strong><br>You can call ::GetSystemMenu to get the system menu, then modify it by adding, deleting, or changing items. You can even suppress the system menu entirely by turning off the WS_SYSMENU style in your window creation flags or virtual PreCreateWindow function. But whatever you do, the system menu is also the one that's displayed when users right-click on your application's minimized button in the task bar.Origins of Ctrl+Alt+Del<br>In my January column, I asked if anyone knew the origins of Ctrl+Alt+Del. Apparently several readers know how to use Google, because they sent me links to the same <em>USA Today</em> article I discovered before posing my challenge (see <a rel="nofollow" href="http://www.usatoday.com/tech/news/techinnovations/2003-09-29-cntl-alt-del_x.htm"  ><span style="color:blue; text-decoration:underline;"  >Thank this guy for 'control-alt-delete'</span></a>). Ctrl+Alt+Del was invented by a man named David J. Bradley who worked at IBM.<br>IBM decided it would be good to have a way to reset their new PC without turning off the power. And why those particular keys, Ctrl+Alt+Del? For technical reasons, David needed to use two modifier keys. He also wanted a combination no one was likely to type by accident. So he chose Ctrl+Alt as the modifier keys (less common than Shift) and Delete, which is on the other side of the keyboard, so typing Ctrl+Alt+Del required two hands. At least it did in the old days.<br>Modern keyboards now have Ctrl and Alt on the right side as well. The reset feature was originally intended to be a secret escape hatch for IBMers, but inevitably the cat got out of the bag. Once developers learned about it, they started telling customers to use it as a last resort when their machines were hung. The rest is history. Ctrl+Alt+Del is affectionately known as the "three finger salute," and survives in Windows even today, where it invokes the Task Manager so you can kill hung tasks or shut your system down (you can learn more about Secure Attention Sequences like Ctrl+Alt+Del in this month's <a rel="nofollow" href="http://msdn.microsoft.com/msdnmag/issues/05/05/SecurityBriefs/"  ><span style="color:blue; text-decoration:underline;"  >Security Briefs</span></a> column). And what if Ctrl+Alt+Del fails? Why, just hold the power button down for five seconds, please.<br>David Bradley was one of the original 12 engineers who built the IBM Personal Computer. He wrote the ROM BIOS. For a brief bio on David, see <a rel="nofollow" href="http://engineering.purdue.edu/ECE/Alumni/OECE/1997/bradley.whtml"  ><span style="color:blue; text-decoration:underline;"  >David J. Bradley</span></a>.<br><br>Which leads to Monicque's question: if you add your own commands to the system menu, how do you handle them in MFC? If you do the normal thing—write an ON_COMMAND handler somewhere and add it to one of your message maps, you'll discover your handler never gets called. How come?<br>It's because Windows and MFC handle system commands differently from ordinary menu commands. When the user invokes a normal menu command or button in your form, Windows sends your main window a WM_COMMAND message. If you're using MFC, MFC's command-routing mechanism catches this message and routes it through the system to any object in the command route that has an ON_COMMAND handler for that command. (For details on MFC command routing, see my article "<a rel="nofollow" href="http://isapi/gomscom.asp?TARGET=/msj/0795/dilascia/dilascia.aspx"  ><span style="color:blue; text-decoration:underline;"  >Meandering Through the Maze of MFC Message and Command Routing</span></a>" in the July 1995 <em>MSJ</em>.)<br>But system commands don't come via WM_COMMAND. They come via a different message called—what else?—WM_SYSCOMMAND. This is true whether the command ID is one of the true system commands like SC_MINIMIZE and SC_CLOSE, or some other command ID you've added. To handle system menu commands, you have to handle WM_SYSCOMMAND explicitly and check for your own command IDs. This requires adding ON_WM_SYSCOMMAND to your main window's message map, with a handler function like this: <br><strong>CMainFrame::OnSysCommand(UINT nID, LPARAM lp)<br>{<br>  if (nID==ID_MY_COMMAND) {<br>    ... // handle it<br>    return 0;<br>  }<br>  // pass to base class: important!<br>  return CFrameWnd::OnSysCommand(nID, lp);<br>}<br></strong>If the command isn't yours, don't forget to pass it to your base class—which is typically CFrameWnd or CMDIFrameWnd. Otherwise, Windows won't get the message and you'll break the built-in commands.<br>Handling WM_SYSCOMMAND in your main frame certainly works, but it feels kludgy. Why use a special mechanism to handle commands just because they come via the system menu? What if you want to handle a system command in some other object like your view or document? One common command to put in your system menu is About (ID_APP_ABOUT), and most MFC programs handle ID_APP_ABOUT in the application object: <br><strong>void CMyApp::OnAppAbout()<br>{<br>   static CAboutDialog dlg;<br>   dlg.DoModal(); <br>}<br></strong>One of the really cool features of MFC is its command-routing system, which lets non-window objects like CMyApp handle menu commands. Many programmers don't even realize how out of the ordinary this is. If you already handle ID_APP_ABOUT in your application object, why should you have to implement a separate mechanism if you add ID_APP_ABOUT to your system menu?<br>A better and more MFC-like way to handle add-on system commands would be to pass them through the normal command-routing mechanism. Then you could handle system commands the normal MFC way, by writing ON_COMMAND handlers. You could even use ON_UPDATE_COMMAND_UI to update your system menu items, for example to disable an item or display a checkmark next to it.<br><strong>Figure 2</strong> shows a little class I wrote, CSysCmdRouter, that turns system commands into ordinary commands. To use it, all you have to do is instantiate CSysCmdRouter in your main frame and call its Init method from OnCreate: <br><strong>int CMainFrame::OnCreate(...)<br>{<br>  // Add my items to system menu<br>  CMenu* pMenu = GetSystemMenu(FALSE);<br>  pMenu-&gt;AppendMenu(..ID_MYCMD1..);<br>  pMenu-&gt;AppendMenu(..ID_MYCMD2..);<br>  // Route sys commands through MFC<br>  m_sysCmdHook.Init(this);<br>  return 0;<br>}<br><img title="Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More - Howie - Dspace"  src="pic/img1.ph.126.net_xxpmIm6Vm7A8viMQ-OtwWw==_632474272669154411.jpg"  alt=""  /></strong>&nbsp;Figure&nbsp;2&nbsp;CSysCmdRouter <br><strong>////////////////////////////////////////////////////////////////<br>// MSDN Magazine May 2005<br>// If this program works, it was written by Paul DiLascia.<br>// If not, I don't know who wrote it.<br>//<br>#include "Subclass.h"<br><br>//////////////////<br>// Class to route user-defined WM_SYSCOMMAND messages through the normal <br>// MFC command routing system, so you can handle them the normal MFC way <br>// with ON_COMMAND and ON_UPDATE_COMMAND_UI handlers. The simplest way to <br>// achieve this is to translate the system commands to ordinary WM_COMMAND <br>// messages.<br>//<br>// To use: instantiate in your CMainFrame and call Init from OnCreate.<br>//<br>// You must also link Subclass.cpp in your app.<br>//<br>class CSysCmdRouter : public CSubclassWnd {<br>protected:<br>    CWnd* m_pMainWnd;    // main window hooked<br>public:<br>    CSysCmdRouter() { }<br>    virtual ~CSysCmdRouter() { }<br><br>    // Initialize: hook the main window<br>    BOOL Init(CWnd* pMainWnd) {<br>        ASSERT(pMainWnd);<br>        m_pMainWnd = pMainWnd;<br>        return HookWindow(pMainWnd);<br>    }<br><br>    // Terminate: unhook. No need to call unless you want to stop hooking <br>    // for some reason; CSubclassWnd will automatically unhook itself when <br>    // the hooked window is destroyed.<br>    void Term() {<br>        Unhook();<br>    }<br><br>protected:<br><br>    // virtual WndProc handler: convert WM_SYSCOMMAND to WM_COMMAND if the <br>    // command is not a system command: That is, if the command ID is less <br>    // than SC_SIZE = 0xFFFF.<br>    //<br>    virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp)<br>    {<br>        if (msg==WM_SYSCOMMAND &amp;&amp; wp&lt;SC_SIZE) {<br>            return m_pMainWnd-&gt;SendMessage(WM_COMMAND, wp, NULL);<br>        } else if (msg==WM_INITMENUPOPUP) {<br>          // Hide system menu flag (= HIWORD(lp)) so even system menu can <br>          // be initialized through MFC. This is somewhat dangerous <br>          // because you lose the ability to distinguish between the <br>          // system menu and other menus—but if you're adding your own <br>          // commands it shouldn't matter which menu(s) they come from! <br>          // Just make sure your command IDs don't conflict with the <br>          // built-in commands like SC_SIZE,and so on, which start at<br>          // 0xF000. By default, MFC command IDs start at 0x8000 so you'll <br>          // be safe if you follow MFC.<br>            lp = LOWORD(lp);<br>        }<br>        return CSubclassWnd::WindowProc(msg, wp, lp); // pass along<br>                                                      //-important!<br>    }<br>};<br></strong>Once you call CSysCmdRouter::Init, you can process ID_MYCMD1 and ID_MYCMD2 the normal way, by writing ON_COMMAND handlers for any object in the MFC command-routing superhighway—view, document, frame, app, or any other command target you've added by overriding OnCmdMsg. CSysCmdRouter also lets you update your system menu using ON_UPDATE_COMMAND_UI handlers. The only caveat is to make sure your command IDs don't conflict with any other menu commands (unless they truly represent the same command) or any of the built-in system commands, which begin at SC_SIZE = 0xF000. Visual Studio? .NET assigns command IDs starting at 0x8000 = 32768, so if you let Visual Studio assign the IDs, you'll be OK as long as you don't have more than 0xF000-0x8000 = 0x7000 commands. That's 28,672 in base 10. If your app has more than 28,000 commands, you need to consult a programming psychiatrist.<br>How does CSysCmdRouter perform its magic? Simple: it uses the ubiquitous CSubclassWnd from my previous columns. CSubclassWnd lets you subclass MFC window objects without deriving from them. CSysCmdRouter derives from CSubclassWnd and uses it to subclass the main frame. Specifically, it intercepts WM_SYSCOMMAND messages sent to the frame. If the command ID is in the system command range (greater than SC_SIZE = 0xF000), CSysCmdRouter passes it along to Windows; otherwise it eats the WM_SYSCOMMAND and resends it as a WM_COMMAND, whereupon MFC follows its normal routing procedures, calling your ON_COMMAND handlers. Pretty clever, eh?<br>And what about ON_UPDATE_COMMAND_UI handlers? How does CSysCmdRouter make them work for system menu commands? Simple. Just before Windows displays a menu, it sends your main window a WM_INITMENUPOPUP message. This is your big chance to update the menu items—enable or disable them, add checkmarks, and so on. MFC catches WM_INITMENUPOPUP in CFrameWnd::OnInitMenuPopup and performs its UI-update magic. MFC creates a CCmdUI object for each menu item and passes it to the appropriate ON_UPDATE_COMMAND_UI handlers in your message maps. The MFC function that takes care of this is CFrameWnd::OnInitMenuPopup, which begins like so: <br><strong>void CFrameWnd::OnInitMenuPopup(CMenu* pMenu, <br>  UINT nIndex, BOOL bSysMenu)<br>{<br>  if (bSysMenu)<br>    return; // don't support system menu<br>  ...<br>}<br></strong>MFC doesn't do anything to initialize the system menu. Why not? Why should it care? What if somehow you could make bSysMenu FALSE, even for the system menu? That's exactly what CSysCmdRouter does. It intercepts WM_INITMENUPOPUP and clears the bSysMenu flag, which is the HIWORD of LPARAM: <br><strong>if (msg==WM_INITMENUPOPUP) {<br>   lp = LOWORD(lp); // (set HIWORD = 0)<br>}<br></strong>Now when MFC gets WM_INITMENUPOPUP, it thinks the menu is a normal menu. This all works fine as long as your command IDs don't conflict with true system commands. The only thing you lose is the ability to distinguish the system menu from the main window menu if you override OnInitMenuPopup. Hey, you can't have everything! You can always handle WM_INITMENUPOPUP by overriding CWnd::WindowProc, or compare HMENUs if you need to distinguish. But really, you shouldn't care where the command came from.<br><img title="Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More - Howie - Dspace"  src="pic/img6.ph.126.net_S0GkFrX_AdlcI_F-n5Qryw==_2797298318568199726.jpg"  alt=""  /><br>Figure 3<strong>&nbsp;Task Bar Menu&nbsp;</strong><br>To show how all this works in practice, I wrote a little test program called TBMenu. <strong>Figure 3</strong> shows the menu displayed when you right-click on TBMenu's minimized button in the task bar. You can see the two extra commands at the bottom of the menu. <strong>Figure 4</strong> shows the code for TBMenu's CMainFrame. You can see where it adds the commands in OnCreate and handles them with ON_COMMAND and ON_UPDATE_COMMAND_UI handlers in CMainFrame's message map. TBMenu handles ID_APP_ABOUT within its application class (not shown). CSysCmdRouter makes system commands work like any other commands. Speaking of commands, see the fascinating sidebar "Origins of Ctrl+Alt+Del".<br><img title="Unreferenced Parameters(UNREFERENCED_PARAMETER Macro in winnt.h), Adding Task Bar Commands, and More - Howie - Dspace"  src="pic/img1.ph.126.net_xxpmIm6Vm7A8viMQ-OtwWw==_632474272669154411.jpg"  alt=""  />&nbsp;Figure&nbsp;4&nbsp;MinFrm.cpp <br><strong>// MSDN Magazine May 2005  <br>// If this program works, it was written by Paul DiLascia.<br>// If not, I don't know who wrote it.<br>//<br>#include "StdAfx.h"<br>#include "TbMenu.h"<br>#include "MainFrm.h"<br>...<br>IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)<br>BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)<br>    ON_WM_CREATE()<br>    ON_COMMAND(ID_CHECKME, OnCheckMe)<br>    ON_UPDATE_COMMAND_UI(ID_CHECKME, OnUpdateCheckMe)<br>END_MESSAGE_MAP()<br><br>CMainFrame::CMainFrame() : m_bChecked(0)<br>{<br>}<br><br>CMainFrame::~CMainFrame()<br>{<br>}<br><br>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)<br>{<br>    ... // normal MFC stuff: call base class OnCreate,<br>    ... // create toolbar and status bar (not shown here)<br><br>    // Append my own items to the system menu<br>    CMenu* pMenu = GetSystemMenu(FALSE);<br>    ASSERT(pMenu!=NULL);<br>    pMenu-&gt;AppendMenu(MF_BYPOSITION|MF_SEPARATOR);<br>    pMenu-&gt;AppendMenu(MF_STRING,(UINT_PTR)ID_CHECKME, _T("Chec&amp;k Me"));<br>    pMenu-&gt;AppendMenu(MF_STRING,(UINT_PTR)ID_APP_ABOUT, <br>        _T("&amp;About TBMenu"));<br><br>    // Hook system commands so they're routed through MFC <br>    // command routing to ON_COMMAND handlers.<br>    m_sysCmdHook.Init(this);<br><br>    return 0;<br>}<br><br>//////////////////<br>// Handle "Check Me" command<br>//<br>void CMainFrame::OnCheckMe()<br>{<br>    m_bChecked = !m_bChecked;<br>    MessageBox(m_bChecked ? _T("Checked") : _T("Unchecked"), _T("TBMenu"));<br>}<br><br>//////////////////<br>// Set checkmark next to "Check Me" command (or not)<br>//<br>void CMainFrame::OnUpdateCheckMe(CCmdUI* pCmdUI)<br>{<br>    pCmdUI-&gt;SetCheck(m_bChecked);<br>}<br></strong>Happy programming!<br><br>Send your questions and comments for Paul to &nbsp;<a rel="nofollow" href="mailto:cppqa@microsoft.com"  ><span style="color:blue; text-decoration:underline;"  >cppqa@microsoft.com</span></a>. <br><br><strong>Paul DiLascia</strong> is a freelance writer, consultant, and Web/UI designer-at-large. He is the author of <em>Windows</em>++: <em>Writing Reusable Windows Code in C</em>++ (Addison-Wesley, 1992). Paul can be reached at <a rel="nofollow" href="http://www.dilascia.com"  ><span style="color:blue; text-decoration:underline;"  >www.dilascia.com</span></a>.</span></p>
</body></html>