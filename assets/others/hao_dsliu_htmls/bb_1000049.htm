<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Queuing I/O Requests</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Queuing I/O Requests</h2>
<p align="right">发布时间：2014-5-16 13:58
<br>分类名称：Driver</p><br>
<p><span style="font-family:宋体;"   >下面是IoStartPacket，IoStartNextPacket, IoCancelIrp, 及用户实现的StartIo, CancelIo例程。
</span></p><p><span style="font-family:宋体;"   >VOID<br>IoStartPacket(<br>    IN PDEVICE_OBJECT DeviceObject,<br>    IN PIRP Irp,<br>    IN PULONG Key OPTIONAL,<br>    IN PDRIVER_CANCEL CancelFunction OPTIONAL<br>    )<br><br>/*++<br><br>Routine Description:<br><br>    This routine attempts to start the specified packet request (IRP) on the<br>    specified device.  If the device is already busy, then the packet is<br>    simply queued to the device queue. If a non-NULL CancelFunction is<br>    supplied, it will be put in the IRP.  If the IRP has been canceled, the<br>    CancelFunction will be called after the IRP has been inserted into the<br>    queue or made the current packet.<br><br>Arguments:<br><br>    DeviceObject - Pointer to device object itself.<br><br>    Irp - I/O Request Packet which should be started on the device.<br><br>    Key - Key to be used in inserting packet into device queue;  optional<br>        (if not specified, then packet is inserted at the tail).<br><br>    CancelFunction - Pointer to an optional cancel routine.<br><br>Return Value:<br><br>    None.<br><br>--*/<br><br>{<br>    KIRQL oldIrql;<br>    KIRQL cancelIrql = PASSIVE_LEVEL;<br>    BOOLEAN i;<br><br>    //<br>    // Raise the IRQL of the processor to dispatch level for synchronization.<br>    //<br>    // 在DISPATCH_LEVEL下运行<br>    KeRaiseIrql( DISPATCH_LEVEL, &amp;oldIrql );<br><br>    //<br>    // If the driver has indicated that packets are cancelable, then acquire<br>    // the cancel spinlock and set the address of the cancel function to<br>    // indicate that the packet is not only cancelable, but indicates what<br>    // routine to invoke should it be cancelled.<br>    //<br><br>    if (CancelFunction) {<br>        IoAcquireCancelSpinLock( &amp;cancelIrql );<br>        Irp-&gt;CancelRoutine = CancelFunction;<br>    }<br><br>    //<br>    // If a key parameter was specified, then insert the request into the<br>    // work queue according to the key;  otherwise, simply insert it at the<br>    // tail.<br>    //<br><br>    if (Key) {<br>        i = KeInsertByKeyDeviceQueue( &amp;DeviceObject-&gt;DeviceQueue,<br>                                      &amp;Irp-&gt;Tail.Overlay.DeviceQueueEntry,<br>                                      *Key );<br>    } else {<br>        i = KeInsertDeviceQueue( &amp;DeviceObject-&gt;DeviceQueue,<br>                                 &amp;Irp-&gt;Tail.Overlay.DeviceQueueEntry );<br>    }<br><br>    //<br>    // If the packet was not inserted into the queue, then this request is<br>    // now the current packet for this device.  Indicate so by storing its<br>    // address in the current IRP field, and begin processing the request.<br>    //<br>    // 如果没有Insert，说明当前IRP链中是空的，可以执行。<br>    // 如果Inserted，说明目前有正在处理的IRP，只是简单的将IRP进行排队。<br>    if (!i) {<br>        // 设置当前的IRP<br>        DeviceObject-&gt;CurrentIrp = Irp;<br><br>        if (CancelFunction) {<br><br>            //<br>            // If the driver does not want the IRP in the cancelable state<br>            // then set the routine to NULL<br>            //<br><br>            if (DeviceObject-&gt;DeviceObjectExtension-&gt;StartIoFlags &amp; DOE_STARTIO_NO_CANCEL) {<br>                Irp-&gt;CancelRoutine = NULL;<br>            }<br><br>            IoReleaseCancelSpinLock( cancelIrql );<br>        }<br><br>        //<br>        // Invoke the driver's start I/O routine to get the request going on the device.<br>        // The StartIo routine should handle the cancellation.<br>        //<br><br>        DeviceObject-&gt;DriverObject-&gt;DriverStartIo( DeviceObject, Irp );<br><br>    } else {<br><br>        //<br>        // The packet was successfully inserted into the device's work queue.<br>        // Make one last check to determine whether or not the packet has<br>        // already been marked cancelled.  If it has, then invoke the<br>        // driver's cancel routine now.  Note that because the cancel<br>        // spinlock is currently being held, an attempt to cancel the request<br>        // from another processor at this point will simply wait until this<br>        // routine is finished, and then get it cancelled.<br>        //<br><br>        if (CancelFunction) {<br>            if (Irp-&gt;Cancel) {<br>                Irp-&gt;CancelIrql = cancelIrql;<br>                Irp-&gt;CancelRoutine = (PDRIVER_CANCEL) NULL;<br>                CancelFunction( DeviceObject, Irp );<br>            } else {<br>                IoReleaseCancelSpinLock( cancelIrql );<br>            }<br>        }<br>    }<br><br>    //<br>    // Restore the IRQL back to its value upon entry to this function before<br>    // returning to the caller.<br>    //<br><br>    KeLowerIrql( oldIrql );<br>}<br><br>VOID<br>IopStartNextPacket(<br>    IN PDEVICE_OBJECT DeviceObject,<br>    IN LOGICAL Cancelable<br>    )<br><br>/*++<br><br>Routine Description:<br><br>    This routine is invoked to dequeue the next packet (IRP) from the<br>    specified device work queue and invoke the device driver's start I/O<br>    routine for it.  If the Cancelable parameter is TRUE, then the update of<br>    current IRP is synchronized using the cancel spinlock.<br><br>Arguments:<br><br>    DeviceObject - Pointer to device object itself.<br><br>    Cancelable - Indicates that IRPs in the device queue may be cancelable.<br><br>Return Value:<br><br>    None.<br><br>--*/<br><br>{<br>    KIRQL cancelIrql = PASSIVE_LEVEL;<br>    PIRP irp;<br>    PKDEVICE_QUEUE_ENTRY packet;<br><br>    //<br>    // Begin by checking to see whether or not this driver's requests are<br>    // to be considered cancelable.  If so, then acquire the cancel spinlock.<br>    //<br><br>    if (Cancelable) {<br>        IoAcquireCancelSpinLock( &amp;cancelIrql );<br>    }<br><br>    //<br>    // Clear the current IRP field before starting another request.<br>    //<br><br>    DeviceObject-&gt;CurrentIrp = (PIRP) NULL;<br><br>    //<br>    // Remove the next packet from the head of the queue.  If a packet was<br>    // found, then process it.<br>    //<br><br>    packet = KeRemoveDeviceQueue( &amp;DeviceObject-&gt;DeviceQueue );<br><br>    if (packet) {<br>        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );<br><br>        //<br>        // A packet was located so make it the current packet for this<br>        // device.<br>        //<br><br>        DeviceObject-&gt;CurrentIrp = irp;<br>        if (Cancelable) {<br><br>            //<br>            // If the driver does not want the IRP in the cancelable state<br>            // then set the routine to NULL<br>            //<br><br>            if (DeviceObject-&gt;DeviceObjectExtension-&gt;StartIoFlags &amp; DOE_STARTIO_NO_CANCEL) {<br>                irp-&gt;CancelRoutine = NULL;<br>            }<br><br>           IoReleaseCancelSpinLock( cancelIrql );<br>        }<br><br>        //<br>        // Invoke the driver's start I/O routine for this packet.<br>        //<br><br>        DeviceObject-&gt;DriverObject-&gt;DriverStartIo( DeviceObject, irp );<br>    } else {<br><br>        //<br>        // No packet was found, so simply release the cancel spinlock if<br>        // it was acquired.<br>        //<br><br>        if (Cancelable) {<br>           IoReleaseCancelSpinLock( cancelIrql );<br>        }<br>    }<br>}<br><br>BOOLEAN<br>KeInsertDeviceQueue (<br>    __inout PKDEVICE_QUEUE DeviceQueue,<br>    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry<br>    )<br><br>/*++<br><br>Routine Description:<br><br>    This function inserts a device queue entry at the tail of the specified<br>    device queue. If the device is not busy, then it is set busy and the entry<br>    is not placed in the device queue. Otherwise the specified entry is placed<br>    at the end of the device queue.<br><br>Arguments:<br><br>    DeviceQueue - Supplies a pointer to a control object of type device queue.<br><br>    DeviceQueueEntry - Supplies a pointer to a device queue entry.<br><br>Return Value:<br><br>    If the device is not busy, then a value of FALSE is returned. Otherwise a<br>    value of TRUE is returned.<br><br>--*/<br><br>{<br><br>    BOOLEAN Busy;<br>    BOOLEAN Inserted;<br>    KLOCK_QUEUE_HANDLE LockHandle;<br><br>    ASSERT_DEVICE_QUEUE(DeviceQueue);<br><br>    //<br>    // Set inserted to FALSE and lock specified device queue.<br>    //<br>    // DeviceQueue是在IoCreateDevice中调用KeInitializeDeviceQueue来初始化的<br>    Inserted = FALSE;<br>    KiAcquireInStackQueuedSpinLockForDpc(&amp;DeviceQueue-&gt;Lock, &amp;LockHandle);<br><br>    //<br>    // Insert the specified device queue entry at the end of the device queue<br>    // if the device queue is busy. Otherwise set the device queue busy and<br>    // don't insert the device queue entry.<br>    //<br><br>    Busy = DeviceQueue-&gt;Busy;<br>    DeviceQueue-&gt;Busy = TRUE;<br>    if (Busy == TRUE) {<br>        InsertTailList(&amp;DeviceQueue-&gt;DeviceListHead,<br>                       &amp;DeviceQueueEntry-&gt;DeviceListEntry);<br><br>        Inserted = TRUE;<br>    }<br><br>    DeviceQueueEntry-&gt;Inserted = Inserted;<br><br>    //<br>    // Unlock specified device queue.<br>    //<br><br>    KiReleaseInStackQueuedSpinLockForDpc(&amp;LockHandle);<br>    return Inserted;<br>}<br><br>BOOLEAN<br>IoCancelIrp(<br>    IN PIRP Irp<br>    )<br><br>/*++<br><br>Routine Description:<br><br>    This routine is invoked to cancel an individual I/O Request Packet.<br>    It acquires the cancel spin lock, sets the cancel flag in the IRP, and<br>    then invokes the cancel routine specified by the appropriate field in<br>    the IRP, if a routine was specified.  It is expected that the cancel<br>    routine will release the cancel spinlock.  If there is no cancel routine,<br>    then the cancel spin lock is released.<br><br>Arguments:<br><br>    Irp - Supplies a pointer to the IRP to be cancelled.<br><br>Return Value:<br><br>    The function value is TRUE if the IRP was in a cancelable state (it<br>    had a cancel routine), else FALSE is returned.<br><br>Notes:<br><br>    It is assumed that the caller has taken the necessary action to ensure<br>    that the packet cannot be fully completed before invoking this routine.<br><br>--*/<br><br>{<br>    PDRIVER_CANCEL cancelRoutine;<br>    KIRQL irql;<br>    BOOLEAN returnValue;<br><br><br>    ASSERT( Irp-&gt;Type == IO_TYPE_IRP );<br><br>    if (IopVerifierOn) {<br>        if (IOV_CANCEL_IRP(Irp, &amp;returnValue)) {<br>            return returnValue;<br>        }<br>    }<br><br>    //<br>    // Acquire the cancel spin lock.<br>    //<br><br>    IoAcquireCancelSpinLock( &amp;irql );<br><br>    //<br>    // Set the cancel flag in the IRP.<br>    //<br><br>    Irp-&gt;Cancel = TRUE;<br><br>    //<br>    // Obtain the address of the cancel routine, and if one was specified,<br>    // invoke it.<br>    //<br><br>    cancelRoutine = (PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( (PVOID *) &amp;Irp-&gt;CancelRoutine,<br>                                                                 NULL );<br><br>    if (cancelRoutine) {<br>        if (Irp-&gt;CurrentLocation &gt; (CCHAR) (Irp-&gt;StackCount + 1)) {<br>            KeBugCheckEx( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) Irp, (ULONG_PTR) cancelRoutine, 0, 0 );<br>        }<br>        Irp-&gt;CancelIrql = irql;<br><br>        cancelRoutine( Irp-&gt;Tail.Overlay.CurrentStackLocation-&gt;DeviceObject,<br>                       Irp );<br>        //<br>        // The cancel spinlock should have been released by the cancel routine.<br>        //<br><br>        return(TRUE);<br><br>    } else {<br><br>        //<br>        // There was no cancel routine, so release the cancel spinlock and<br>        // return indicating the Irp was not currently cancelable.<br>        //<br><br>        IoReleaseCancelSpinLock( irql );<br><br>        return(FALSE);<br>    }<br>}<br><br>// 用户提供的StartIo<br>VOID StartIo(PDEVICE_OBJECT fdo, PIRP Irp)<br>{<br>  KIRQL oldirql;<br>  // 处理Irp被Cancel的情况。在IoStartPacket或IoStartNextPacket调用此函数StartIo前，<br>  // 会先解锁IoAcquireCancelSpinLock。（微软防止StartIo占用过多时间，导致系统响应缓慢）<br>  // 这样调用到IoAcquireCancelSpinLock之前，IRP可能会被IoCancelIrp取消，取消会调用OnCancel函数，fdo-&gt;CurrentIrp == Irp，<br>  // 会释放IoReleaseCancelSpinLock(DISPATCH_LEVEL)，释放后就有两种情况：<br>  // 1. 线程切换回来，上锁IoAcquireCancelSpinLock，此时Irp == fdo-&gt;CurrentIrp 但Irp-&gt;Cancel已经被设置为TRUE。<br>  // 2. 线程仍然未切换回来，在OnCancel中继续运行调用了IoStartNextPacket，使得Irp != fdo-&gt;CurrentIrp，Irp-&gt;Cancel为TRUE。<br>  // 这两种情况都说明IRP已经被取消，不应该继续执行。<br>  IoAcquireCancelSpinLock(&amp;oldirql);<br>  if (Irp != fdo-&gt;CurrentIrp || Irp-&gt;Cancel)<br>  {<br>    IoReleaseCancelSpinLock(oldirql);<br>    return;<br>  }<br>  else<br>  {<br>    IoSetCancelRoutine(Irp, NULL);<br>    IoReleaseCancelSpinLock(oldirql);<br>  }<br>  ...<br>}<br><br>// 用户提供的Cancel函数<br>VOID OnCancel(PDEVICE_OBJECT fdo, PIRP Irp)<br>{<br>  // 如果正好执行到StartIo，但还没有上锁前的情况<br>  if (fdo-&gt;CurrentIrp == Irp)<br>  {<br>    KIRQL oldirql = Irp-&gt;CancelIrql;<br>    IoReleaseCancelSpinLock(DISPATCH_LEVEL);<br>    IoStartNextPacket(fdo, TRUE);<br>    KeLowerIrql(oldirql);<br>  }<br>  else // 如果取消的是一个正在排队的IRP，直接从链中Remove。<br>  {<br>    KeRemoveEntryDeviceQueue(&amp;fdo-&gt;DeviceQueue, &amp;Irp-&gt;Tail.Overlay.DeviceQueueEntry);<br>    IoReleaseCancelSpinLock(Irp-&gt;CancelIrql);<br>  }<br>  CompleteRequest(Irp, STATUS_CANCELLED, 0);<br>}<br></span></p>
</body></html>