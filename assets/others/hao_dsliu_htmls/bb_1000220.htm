<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] boost源码剖析之：泛型函数指针类boost::function</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] boost源码剖析之：泛型函数指针类boost::function</h2>
<p align="right">发布时间：2011-5-31 11:13
<br>分类名称：Boost</p><br>
<p><span style="font-size:12pt;"><span style="color:black;"><em><span style="font-family:Verdana;">Note: </span><span style="font-family:宋体;">并非新作，</span><span style="font-family:Verdana;">03</span><span style="font-family:宋体;">年曾放在</span><span style="font-family:Verdana;">blog</span><span style="font-family:宋体;">上，现在这个版本应该是修改后的最终版本。</span></em></span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体;"><span style="font-size:15pt;"><strong>前奏</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">如你所知，</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">库是个特性完备，且具备工业强度的库，众多</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">权威的参与使其达到了登峰造极的程度。尤其泛型的强大威力在其中被发挥得淋漓尽致，令人瞠目结舌。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">然而弱水三千，我们只取一瓢饮。下面，我试图从最单纯的世界开始，一步一步带领你进入源码的世界，去探究</span><span style="font-family:Verdana;"><strong>boost::function(</strong></span><span style="font-family:宋体;">下文简称</span><span style="font-family:Verdana;"><strong>function)</strong></span><span style="font-family:宋体;">内部的精微结构。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">通常</span><span style="font-family:Verdana;">    </span><span style="font-family:宋体;">，在单纯的情况下，对函数的调用简单而且直观，像这样： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New; font-size:12pt;">int fun(int someVal); </span></p><p style="text-align: justify;"><span style="font-family:Courier New; font-size:12pt;">int main(){ </span></p><p style="text-align: justify;"><span style="font-family:Courier New; font-size:12pt;">fun(10); </span></p><p style="text-align: justify;"><span style="font-family:Courier New; font-size:12pt;">} </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">然而你可能需要在某个时刻将函数指针保存下来，并在以后的另一个时刻调用它，像这样： </span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">  int fun(int);</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">  typedef int (*func_handle)(int);</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">  int main(){</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">    func_handle fh=fun;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">    ...  //do something</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">    fh(10);</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">  }</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">但是，如果</span><span style="font-family:Verdana;">fun</span><span style="font-family:宋体;">形式为</span><span style="font-family:Verdana;">void fun(int)</span><span style="font-family:宋体;">呢？如你所见，</span><span style="font-family:Verdana;">fun</span><span style="font-family:宋体;">可能有无数种形式，如果对</span><span style="font-family:Verdana;">fun</span><span style="font-family:宋体;">的每一个形式都</span><span style="font-family:Verdana;">typedef</span><span style="font-family:宋体;">一个对应的</span><span style="font-family:Verdana;">func_handle</span><span style="font-family:宋体;">，则程序员会焦头烂额，不胜其扰，代码也可能变得臃肿和丑陋不堪，甚至如果</span><span style="font-family:Verdana;">fun</span><span style="font-family:宋体;">是仿函数呢？ </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">幸运的是</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">泛型可以使代码变得优雅精致，面对无数种的可能，泛型是最好的选择。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">因此，你只是需要一个能够保存函数指针的泛型模板类</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">对应于</span><span style="font-family:Verdana;">Command</span><span style="font-family:宋体;">模式</span><span style="font-family:Verdana;">)</span><span style="font-family:宋体;">，因为泛型编程有一个先天性的优势</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">可以借助编译器的力量在编译期根据用户提供的类型信息化身千万</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">实例化</span><span style="font-family:Verdana;">)</span><span style="font-family:宋体;">，所以一个泛型的类可以有无限个实例，也就是说可以保存无限多种可能类型的函数或类似函数的东西</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">如仿函数</span><span style="font-family:Verdana;">)</span><span style="font-family:宋体;">。这个类</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">在</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">库中的类名为</span><span style="font-family:Verdana;">function)</span><span style="font-family:宋体;">与函数指针相比应该有以下一些优势： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">1. </span><span style="font-family:宋体;">同一个</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">对象应能够接受与它形式<strong>兼容</strong>的所有函数和<strong>仿函数</strong></span><span style="font-family:Verdana;">,</span><span style="font-family:宋体;">例如： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">int f1(int); // </span><span style="font-family:宋体;">这是个函数，形式为</span><span style="font-family:Courier New;"> int(int)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">short f2(double); // </span><span style="font-family:宋体;">这个函数形式为</span><span style="font-family:Courier New;"> short(double)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  struct functor // </span><span style="font-family:宋体;">这是个仿函数类，形式为</span><span style="font-family:Courier New;">int(int)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  {</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">    int operator()(int){}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  };</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">functor f3; //</span><span style="font-family:宋体;">创建仿函数对象 </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">boost::function&lt;int(int)&gt; func; // </span><span style="font-family:宋体;">能接受</span><span style="font-family:Courier New;">int(int)</span><span style="font-family:宋体;">型的函数或仿函数 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func = f1;  // </span><span style="font-family:宋体;">接受</span><span style="font-family:Courier New;">f1</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func(10); // </span><span style="font-family:宋体;">调用</span><span style="font-family:Courier New;">f1(10)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func = f2;  // </span><span style="font-family:宋体;">也能接受</span><span style="font-family:Courier New;">short(double)</span><span style="font-family:宋体;">型的</span><span style="font-family:Courier New;">f2</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func(10); // </span><span style="font-family:宋体;">调用</span><span style="font-family:Courier New;">f2(10)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func = f3;  // </span><span style="font-family:宋体;">也能接受仿函数</span><span style="font-family:Courier New;">f3</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">func(10); // </span><span style="font-family:宋体;">调用</span><span style="font-family:Courier New;">f3(10)</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">2. function</span><span style="font-family:宋体;">应能够和参数绑定以及其它</span><span style="font-family:Verdana;">function-construction</span><span style="font-family:宋体;">库协同工作。例如，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">应该也能够接受</span><span style="font-family:Verdana;"><em>std::bind1st</em></span><span style="font-family:宋体;">返回的仿函数。这一点其实由第一点已经有所保证。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">3. </span><span style="font-family:宋体;">当接受的一个空的仿函数对象被调用的时候</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">应该有可预期的行为。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">显然，第一点是我们的重点，所谓形式<strong>兼容</strong>，就是说，对于： </span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">R1 (T0,T1,T2,...,TN) =&gt; FunctionType1</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">R2 (P0,P1,P2,...,PN) =&gt; FunctionType2</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">两种类型的函数（广义），只要满足： </span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">R2</span><span style="font-family:宋体;">能够<strong>隐式</strong>转换为</span><span style="font-family:Verdana;">R1</span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:宋体;">所有</span><span style="font-family:Verdana;">Ti</span><span style="font-family:宋体;">都能够<strong>隐式</strong>转换为</span><span style="font-family:Verdana;">Pi (i</span><span style="font-family:宋体;">取</span><span style="font-family:Verdana;">0,1,2,...)</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">那么就说，</span><span style="font-family:Verdana;"><strong>boost::function</strong>&lt;<strong>FunctionType1&gt;</strong></span><span style="font-family:宋体;">可以接受</span><span style="font-family:Verdana;"><strong>FunctionType2</strong></span><span style="font-family:宋体;">类型的函数</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">注意，反之不行</span><span style="font-family:Verdana;">)</span><span style="font-family:宋体;">。支持这一论断的理由是，只要</span><span style="font-family:Verdana;">Ti</span><span style="font-family:宋体;">能够<strong>隐式</strong>转型为</span><span style="font-family:Verdana;">Pi</span><span style="font-family:宋体;">，那么参数被转发给真实的函数调用就是安全的，并且如果</span><span style="font-family:Verdana;">R2</span><span style="font-family:宋体;">能够<strong>隐式</strong>转型为</span><span style="font-family:Verdana;">R1</span><span style="font-family:宋体;">，那么返回真实函数调用所返回的值就是安全的。这里安全的含义是，</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">类型系统假定隐式转换不会丢失信息，或者编译器至少会给出编译警告。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">后面你会看到，</span><span style="font-family:Verdana;"><strong>boost::function</strong></span><span style="font-family:宋体;">通过所谓的</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">非常巧妙地实现了这点，并且阻止了被形式不兼容的函数赋值的操作。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体;"><span style="font-size:15pt;"><strong>探险</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">先看一个</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的最简单的使用： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">int g(int); // </span><span style="font-family:宋体;">为了让代码简单，假设</span><span style="font-family:Courier New;">g</span><span style="font-family:宋体;">有定义，以后的代码都会如此 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function&lt;int(int)&gt; f(g);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">f(0);</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:14pt;"><strong><span style="font-family:宋体;">间奏</span><span style="font-family:Verdana;">——R(T1,T2,...)</span></strong></span><span style="font-family:宋体;"><span style="font-size:14pt;"><strong>函数类型</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-family:宋体; font-size:12pt;">虽然这个间奏未免早了点儿，但是为了让你以后不会带着迷惑，这是必要的。请保持耐心。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">或许你会对模板参数</span><span style="font-family:Verdana;"><strong>int(int)</strong></span><span style="font-family:宋体;">感到陌生，其实它是个<strong>函数类型</strong></span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">函数</span><span style="font-family:Verdana;"><strong>g</strong></span><span style="font-family:宋体;">的<strong>确切</strong>类型就是</span><span style="font-family:Verdana;"><strong>int(int)</strong></span><span style="font-family:宋体;">，而我们通常所看到的函数指针类型</span><span style="font-family:Verdana;"><strong>int (*)(int)</strong></span><span style="font-family:宋体;">则是</span><span style="font-family:Verdana;"><strong>&amp;g</strong></span><span style="font-family:宋体;">的类型。它们的区别与联系在于：当把</span><span style="font-family:Verdana;">g</span><span style="font-family:宋体;">作为一个值进行拷贝的时候（例如，按值传参），其类型就会由</span><span style="font-family:Verdana;">int(int)</span><span style="font-family:宋体;">退化为</span><span style="font-family:Verdana;">int(*)(int)</span><span style="font-family:宋体;">，即从函数类型退化为函数指针类型</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">因为从语义上说，<strong>函数</strong>不能被</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">按值拷贝</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">，但身为<strong>函数指针</strong>的地址值则是可以被拷贝的。另一方面，如果</span><span style="font-family:Verdana;">g</span><span style="font-family:宋体;">被绑定到<strong>引用</strong>，则其类型不会退化，仍保持<strong>函数类型</strong>。例如： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;class T&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">void test_func_type(T ft) // </span><span style="font-family:宋体;">按值传递，类型退化 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">故意引发编译错误，在错误信息里看出</span><span style="font-family:Courier New;">ft</span><span style="font-family:宋体;">的类型为退化后的函数指针类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">static_cast&lt;int&gt;(ft); </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">int g(int); // g</span><span style="font-family:宋体;">的<strong>确切</strong>类型为</span><span style="font-family:Courier New;">int(int)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">test_func_type(g);  // g</span><span style="font-family:宋体;">的类型将会退化为函数指针类型 </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">int (&amp;ref_f)(int) = g; // </span><span style="font-family:宋体;">由于绑定到引用，类型并不退化 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">当然，这样的代码不能通过编译，因为</span><span style="font-family:Verdana;">static_cast</span><span style="font-family:宋体;">显然不会让一个函数指针转换为</span><span style="font-family:Verdana;">int</span><span style="font-family:宋体;">，然而我们就是要它通不过编译，这样我们才能窥视到按值传递的参数</span><span style="font-family:Verdana;">ft</span><span style="font-family:宋体;">的类型到底是什么，从编译错误中我们看出，</span><span style="font-family:Verdana;">ft</span><span style="font-family:宋体;">的类型是</span><span style="font-family:Verdana;">int(*)(int)</span><span style="font-family:宋体;">，也就是说，在按值传递的过程中，</span><span style="font-family:Verdana;">g</span><span style="font-family:宋体;">的类型退化为函数指针类型，变得和</span><span style="font-family:Verdana;">&amp;g</span><span style="font-family:宋体;">的类型一样了。而</span><span style="font-family:Verdana;">ref_t</span><span style="font-family:宋体;">的类型则是引用，引用绑定则没有引起类型退化。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">请注意，<strong>函数类型</strong>乃是个极其特殊的类型，在大多数时候它都会退化为函数指针类型，以便满足拷贝语义，只有面对引用绑定的时候，能够维持原来的类型。当然，对于</span><span style="font-family:Verdana;">boost::function</span><span style="font-family:宋体;">，总是按值拷贝。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体;"><span style="font-size:14pt;"><strong>继续旅程</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>function</strong>&lt;<strong>int(int)</strong>&gt;</span><span style="font-family:宋体;">实际上进行了模板偏特化，</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">库给</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的类声明为： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename Signature,  //</span><span style="font-family:宋体;">函数类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename Allocator = ... //Allocator</span><span style="font-family:宋体;">并非重点，故不作介绍 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">&gt;&nbsp;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">class function;</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">事实上</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">类只是个薄薄的外覆（</span><span style="font-family:Verdana;">wrapper</span><span style="font-family:宋体;">），真正起作用的是其偏特化版本。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">对于</span><span style="font-family:Verdana;">function&lt;<strong>R(T0)</strong>&gt;</span><span style="font-family:宋体;">形式，偏特化版本的</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">源码像这样</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">实际上在</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">源代码中你看不到模板参数</span><span style="font-family:Verdana;">T0</span><span style="font-family:宋体;">的声明，也看不到</span><span style="font-family:Verdana;"><strong>function1</strong></span><span style="font-family:宋体;">，它们被宏替换掉了，那些精巧的宏是为了减小可见的代码量，至于它们的细节则又是一个世界，以下代码可看作对将那些令人眼花缭乱的宏展开后所得到的代码，具有更好的可读性</span><span style="font-family:Verdana;">)</span><span style="font-family:宋体;">： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:宋体;">摘自：</span><span style="font-family:Courier New;">"boost/function/function_template.hpp"</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename R,typename T0,typename Allocator&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">class function&lt;<strong>R(T0)</strong>,Allocator&gt; // </span><span style="font-family:宋体;">对</span><span style="font-family:Courier New;">R(T0)</span><span style="font-family:宋体;">函数类型的偏特化版本 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">:public <strong>function1</strong>&lt;R,T0,Allocator&gt; // </span><span style="font-family:宋体;">为</span><span style="font-family:Courier New;">R(T0)</span><span style="font-family:宋体;">形式的函数准备的基类 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef <strong>function1</strong>&lt;R,T0,Allocator&gt; base_type;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef function selftype;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">struct <strong>clear_type</strong>{}; // </span><span style="font-family:宋体;">马上你会看到这个蹊跷的类型定义的作用 </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">public:</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">…</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">模板化的构造函数，为了能够接受形式兼容的仿函数对象。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">这个构造函数的作用在下面解释 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename Functor&gt; </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  function(Functor f, </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename <strong>enable_if</strong>&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">             (ice_not&lt;(is_same&lt;Functor, int&gt;::value)&gt;::value),</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">             int</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">&gt;::type = 0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">:base_type(f)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">这个构造函数的作用见下文解释 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function(<strong>clear_type*</strong>) : base_type() {} </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">...</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">};</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:14pt;"><strong>boost::enable_if</strong></span><span style="font-family:宋体; font-size:12pt;">   </span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">你一定对模板构造函数中出现的那个冗长的</span><span style="font-family:Verdana;"><strong>enable_if</strong>&lt;...&gt;</span><span style="font-family:宋体;">的作用心存疑惑，其实它的作用说穿了很简单，就是：当用户构造： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">function&lt;int(int)&gt; f(<strong>0</strong>);</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">的时候，将该（带有</span><span style="font-family:Verdana;">enable_if</span><span style="font-family:宋体;">的）构造函数从重载决议的候选集中踢掉。使重载决议的结果为选中第三个构造函数： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">function(<strong>clear_type</strong>*):base_type(){}</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">从而进行缺省构造。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">而说得冗长一点就是：当</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">的类型</span><span style="font-family:Verdana;">——Functor——</span><span style="font-family:宋体;"><strong>不是</strong></span><span style="font-family:Verdana;">int</span><span style="font-family:宋体;">时，该构造函数就是</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">有效（</span><span style="font-family:Verdana;">enable</span><span style="font-family:宋体;">）</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">的，会被重载决议选中。但如果用户提供了一个</span><span style="font-family:Verdana;">0</span><span style="font-family:宋体;">，用意是构造一个空</span><span style="font-family:Verdana;">(null)</span><span style="font-family:宋体;">的函数指针，那么该函数就会由于</span><span style="font-family:Verdana;">"SFINAE"</span><span style="font-family:宋体;">原则而被从重载决议的候选函数中踢掉。为什么要这样呢？因为该构造函数负责把确切的</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">保存起来，它假定</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">并非</span><span style="font-family:Verdana;">0</span><span style="font-family:宋体;">。那应该选择谁呢？第三个构造函数！其参数类型是</span><span style="font-family:Verdana;">clear_type*</span><span style="font-family:宋体;">，当然，</span><span style="font-family:Verdana;">0</span><span style="font-family:宋体;">可以被赋给任何指针，所以它被选出，执行缺省的构造行为。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:15pt;"><span style="font-family:宋体;"><strong>基类</strong></span><span style="font-family:Verdana;">     <strong>functionN</strong></span></span><span style="font-family:宋体; font-size:12pt;">   </span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的骨架就这些。也许你会问，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">作为一个仿函数类，怎么没有重载</span><span style="font-family:Verdana;"><strong>operator()</strong>——</span><span style="font-family:宋体;">这可是身为仿函数的标志啊！别急，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">把这些烦人的任务都丢给了它的基类</span><span style="font-family:Verdana;"><strong>functionN</strong></span><span style="font-family:宋体;">，根据情况不同，</span><span style="font-family:Verdana;">N</span><span style="font-family:宋体;">可能为</span><span style="font-family:Verdana;">0</span><span style="font-family:宋体;">，</span><span style="font-family:Verdana;">1</span><span style="font-family:宋体;">，</span><span style="font-family:Verdana;">2...</span><span style="font-family:宋体;">，说具体一点就是：根据用户使用</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">时给出的<strong>函数类型</strong>，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">将会继承自不同的基类</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">如果用户给出的函数类型为</span><span style="font-family:Verdana;">"<strong>R()</strong>"</span><span style="font-family:宋体;">形式的，即仅有一个参数，则</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">继承自</span><span style="font-family:Verdana;"><strong>function0</strong></span><span style="font-family:宋体;">，而对于</span><span style="font-family:Verdana;"><strong>R(T0)</strong></span><span style="font-family:宋体;">形式的函数类型，则继承自</span><span style="font-family:Verdana;"><strong>function1</strong></span><span style="font-family:宋体;">，依此类推。前面说过，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">只是一层外覆，而所有的秘密都在其基类</span><span style="font-family:Verdana;"><strong>functionN</strong></span><span style="font-family:宋体;">中！ </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">不知道你有没有发现，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的骨架中也几乎没有用到函数类型的信息，事实上，它也将这些信息一股脑儿抛给了基类。在这过程中，混沌一团的</span><span style="font-family:Verdana;"><strong>int(int)</strong></span><span style="font-family:宋体;">类型被拆解为两个单独的模板参数传给基类</span><span style="font-family:Verdana;">:</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename R,typename T0,typename Allocator&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">class function&lt;<strong>R(T0)</strong>,Allocator&gt; // R(T0)</span><span style="font-family:宋体;">整个为一类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">:public <strong>function1</strong>&lt;<strong>R</strong>,<strong>T0</strong>,Allocator&gt; // </span><span style="font-family:宋体;">拆解为两个模板参数</span><span style="font-family:Courier New;">R,T0</span><span style="font-family:宋体;">传给基类 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">好了，下面我们深入基类</span><span style="font-family:Verdana;"><strong>function1</strong></span><span style="font-family:宋体;">。真正丰富的宝藏在里面。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:14pt;"><strong>function1</strong></span><span style="font-family:宋体; font-size:12pt;">   </span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">function1</span><span style="font-family:宋体;">的源代码像这样</span><span style="font-family:Verdana;">(</span><span style="font-family:宋体;">与上面一样，事实上有些代码你是看不到的，为了不让你迷惑，我给出的是将宏展开后得到的代码</span><span style="font-family:Verdana;">):</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:宋体;">摘自：</span><span style="font-family:Courier New;">"boost/function/function_template.hpp"</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename R,typename T0,class Allocator = ...&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">class <strong>function1</strong></span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">: public <strong>function_base</strong> // function_base</span><span style="font-family:宋体;">负责管理内存 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">...</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">public:</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef R result_type;   //</span><span style="font-family:宋体;">返回类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef function1 self_type;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename Functor&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function1(Functor const &amp; f,</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename enable_if&lt;...&gt;::type = 0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">: function_base(), invoker(0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">this-&gt;<strong>assign_to</strong>(f);   //</span><span style="font-family:宋体;">这儿真正进行赋值，</span><span style="font-family:Courier New;">assign_to</span><span style="font-family:宋体;">的代码在下面列出 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename Functor&gt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">void <strong>assign_to</strong>(Functor f) // </span><span style="font-family:宋体;">所有的构造函数都调用它！具有多个重载版本。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">     // </span><span style="font-family:宋体;">以一个</span><span style="font-family:Courier New;">get_function_tag</span><span style="font-family:宋体;">萃取出</span><span style="font-family:Courier New;">Functor</span><span style="font-family:宋体;">的类别</span><span style="font-family:Courier New;">(category)!</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef typename detail::function::<strong>get_function_tag</strong>&lt;Functor&gt;::type </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">tag;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">       &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">      // </span><span style="font-family:宋体;">根据不同类别的</span><span style="font-family:Courier New;">Functor</span><span style="font-family:宋体;">采取不同的</span><span style="font-family:Courier New;">assign</span><span style="font-family:宋体;">策略！ </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">this-&gt;<strong>assign_to</strong>(f, <strong>tag()</strong>); // </span><span style="font-family:宋体;">转到真正做事情的</span><span style="font-family:Courier New;">assign_to</span><span style="font-family:宋体;">版本，见下文。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">...</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">result_type <strong>operator()</strong>(T0<strong> a0</strong>) const // </span><span style="font-family:宋体;">身为仿函数的标志！ </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">...</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">    // </span><span style="font-family:宋体;">这里进行真正的函数调用，使用</span><span style="font-family:Courier New;">invoker</span><span style="font-family:宋体;">， </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// invoker</span><span style="font-family:宋体;">是</span><span style="font-family:Courier New;">functionN</span><span style="font-family:宋体;">的成员变量，在下面的</span><span style="font-family:Courier New;">assign_to</span><span style="font-family:宋体;">中被赋值。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// functor</span><span style="font-family:宋体;">为实际被调用的函数或仿函数，</span><span style="font-family:Courier New;">a0</span><span style="font-family:宋体;">当然是其参数。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">    <strong>internal_result_type</strong> result = <strong>invoker</strong>(function_base::<strong>functor</strong>, <strong>a0</strong>); </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">将得到的结果</span><span style="font-family:Courier New;">cast</span><span style="font-family:宋体;">至最终返回出去的类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">return static_cast&lt;result_type&gt;(result);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">其中值得注意的是： </span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>get_function_tag</strong>&lt;&gt;</span><span style="font-family:宋体;">能萃取出</span><span style="font-family:Verdana;">Functor</span><span style="font-family:宋体;">的类别</span><span style="font-family:Verdana;">(category)</span><span style="font-family:宋体;">，有下面几种类别 </span></span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">struct function_ptr_tag {}; // </span><span style="font-family:宋体;">函数指针 </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">struct function_obj_tag {}; // </span><span style="font-family:宋体;">仿函数对象 </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">struct member_ptr_tag {}; // </span><span style="font-family:宋体;">成员函数 </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">struct function_obj_ref_tag {}; // </span><span style="font-family:宋体;">以</span><span style="font-family:Verdana;">ref(obj)</span><span style="font-family:宋体;">加以封装的类别，具有引用语义 </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">struct stateless_function_obj_tag {}; // </span><span style="font-family:宋体;">无状态函数对象 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;">此外，满足以下所有条件： </span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">has_trivial_constructor</span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">has_trivial_copy</span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">has_trivial_destructor</span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">is_empty</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">的仿函数对象称为</span><span style="font-family:Verdana;">stateless</span><span style="font-family:宋体;">的。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">对于不同的函数类别，</span><span style="font-family:Verdana;">assign_to</span><span style="font-family:宋体;">有各个不同的重载版本，如下： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename FunctionPtr&gt; // </span><span style="font-family:宋体;">如果是函数指针就调用这个版本 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">void assign_to(FunctionPtr f, <strong>function_ptr_tag</strong>) // </span><span style="font-family:宋体;">这个版本针对函数指针 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">clear();</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">  {</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">    typedef </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename ...::<strong>get_function_invoker1</strong>&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">                  FunctionPtr,R,T0&gt;::type </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;"><strong>invoker_type</strong>; // </span><span style="font-family:宋体;">萃取相应的</span><span style="font-family:Courier New;">invoker</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">invoker = &amp;invoker_type::<strong>invoke</strong>; // <strong>invoke</strong></span><span style="font-family:宋体;">是一个</span><span style="font-family:Courier New;">static</span><span style="font-family:宋体;">成员函数 </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">function_base::<strong>manager</strong> = // </span><span style="font-family:宋体;">管理策略，一个函数指针 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">      &amp;...::<strong>functor_manager</strong>&lt;FunctionPtr, Allocator&gt;::manage;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">   &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">交给</span><span style="font-family:Courier New;">function</span><span style="font-family:宋体;">的函数指针或仿函数对象指针最终在这儿保存 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function_base::<strong>functor</strong> = </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function_base::<strong>manager</strong>(</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">...::make_any_pointer((void (*)())(f)),</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">        ...::<strong>clone_functor_tag</strong>); // </span><span style="font-family:宋体;">拷贝一份 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  ...</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">  // <strong>any_pointer</strong></span><span style="font-family:宋体;">在下文解释 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef internal_result_type(*<strong>invoker_type</strong>)(...::<strong>any_pointer</strong>, T0);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;"><strong>invoker_type invoker</strong>; // </span><span style="font-family:宋体;">重要成员，负责调用函数！ </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">}; // function1</span><span style="font-family:宋体;">类定义的结尾 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:14pt;"><strong>function</strong></span><span style="font-family:宋体;"><span style="font-size:14pt;"><strong>的底层存储机制</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">请将目光转向上面的代码段末尾的</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">函数中，其中有两行代码分别对</span><span style="font-family:Verdana;">function_base</span><span style="font-family:宋体;">里的</span><span style="font-family:Verdana;"><strong>manager</strong></span><span style="font-family:宋体;">和</span><span style="font-family:Verdana;"><strong>functor</strong></span><span style="font-family:宋体;">成员赋值。这两行代码肩负了保存各种<strong>函数指针</strong>的任务。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>manager</strong></span><span style="font-family:宋体;">是一个函数指针，它所指向的函数代表管理策略，例如，对于函数指针，仅仅作一次赋值，就保存完毕了，但是对于仿函数，得额外分配一次内存，然后将仿函数拷贝到分配的内存中，这才完成了保存的任务。这些策略根据函数的类别而定，上面代码中的</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">函数是针对<strong>函数指针</strong>类别的重载版本，所以</span><span style="font-family:Verdana;"><strong>manager</strong></span><span style="font-family:宋体;">的策略是不作任何内存分配，直接返回被转型为</span><span style="font-family:Verdana;">"<strong>void(*)()</strong>"</span><span style="font-family:宋体;">（利于在底层以统一的形式保存）的函数指针就行了，这从代码中可以看出。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">需要说明的是，对于函数指针，</span><span style="font-family:Verdana;">function_base</span><span style="font-family:宋体;">并不知道也不关心它要保存的函数指针是什么确切的类型，只要是函数指针就行，因为它总会把该函数指针</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">转型为</span><span style="font-family:Verdana;">"<strong>void (*)()</strong>"</span><span style="font-family:宋体;">类型，然后保存在</span><span style="font-family:Verdana;"><strong>functor</strong></span><span style="font-family:宋体;">成员中，</span><span style="font-family:Verdana;"><strong>functor</strong></span><span style="font-family:宋体;">成员是一个</span><span style="font-family:Verdana;"><strong>union</strong></span><span style="font-family:宋体;">类型</span><span style="font-family:Verdana;">:</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">union any_pointer</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">    // </span><span style="font-family:宋体;">任意仿函数对象指针都可以用</span><span style="font-family:Courier New;">static_cast</span><span style="font-family:宋体;">转型为</span><span style="font-family:Courier New;">void*</span><span style="font-family:宋体;">型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">void* obj_ptr;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">    // </span><span style="font-family:宋体;">为</span><span style="font-family:Courier New;">const</span><span style="font-family:宋体;">仿函数准备的 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">const void* const_obj_ptr;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">任意函数指针都可以用</span><span style="font-family:Courier New;">reinterpret_cast</span><span style="font-family:宋体;">转型为</span><span style="font-family:Courier New;">void(*)()</span><span style="font-family:宋体;">型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">void (*func_ptr)();</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">char data[1];</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">};</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">这个</span><span style="font-family:Verdana;"><strong>any_pointer</strong></span><span style="font-family:宋体;">可以通过安全转型保存所有形式的仿函数和函数指针，承载在底层保存数据的任务 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:14pt;"><strong><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的调用机制</span><span style="font-family:Verdana;">——invoker</span></strong></span><span style="font-family:宋体; font-size:12pt;">   </span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">我们把目光转到</span><span style="font-family:Verdana;"><strong>function1</strong></span><span style="font-family:宋体;">的定义的最底部，那儿定义了它最重要的成员</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">，它是一个函数指针，所指向的函数就是</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的调用机制所在，</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">的类型为： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef internal_result_type (*<strong>invoker_type</strong>)(any_pointer,T0);</span><span style="font-family:宋体;">   </span></p><p style="text-align: center;">&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">前面已经说过，</span><span style="font-family:Verdana;">any_pointer</span><span style="font-family:宋体;">是个</span><span style="font-family:Verdana;">union</span><span style="font-family:宋体;">，可以保存任何类型的函数指针或函数对象，里面保存的是用户给出的函数或仿函数，</span><span style="font-family:Verdana;">T0</span><span style="font-family:宋体;">则是保存于</span><span style="font-family:Verdana;">any_pointer</span><span style="font-family:宋体;">中的函数的参数类型（若有两个参数则是</span><span style="font-family:Verdana;">T1,T2</span><span style="font-family:宋体;">）。这也就是说，</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">负责调用保存在</span><span style="font-family:Verdana;">any_pointer</span><span style="font-family:宋体;">中的函数或仿函数。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">那么，</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">这个函数指针到底指向什么函数呢</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">也就是说，在什么时候</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">被赋值了呢？我们再次把目光转向</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">函数，其中有一行对</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">成员赋值的语句，从这行语句出发我们可以揭开</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">的全部奥秘： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">invoker = &amp;<strong>invoker_type::invoke</strong>; // invoke</span><span style="font-family:宋体;">是一个</span><span style="font-family:Courier New;">static</span><span style="font-family:宋体;">成员函数 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">请不要把这个</span><span style="font-family:Verdana;"><strong>invoker_type</strong></span><span style="font-family:宋体;">和上面那个函数指针类型</span><span style="font-family:Verdana;"><strong>invoker_type</strong></span><span style="font-family:宋体;">混淆起来，这个</span><span style="font-family:Verdana;"><strong>invoker_type</strong></span><span style="font-family:宋体;">是位于</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">函数中的一个局部的</span><span style="font-family:Verdana;">typedef</span><span style="font-family:宋体;">，所以隐藏了后者（即类作用域中的那个</span><span style="font-family:Verdana;"><strong>invoker_type</strong>——<strong>invoker</strong></span><span style="font-family:宋体;">成员的类型）。往上一行，你就看到这个局部类型</span><span style="font-family:Verdana;"><strong>invoker_type</strong></span><span style="font-family:宋体;">的定义了： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef typename get_function_invoker1&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">          FunctionPtr,R,T0&gt;::type invoker_type;</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>get_function_invoker1</strong></span><span style="font-family:宋体;">又是何物？很显然，这是个</span><span style="font-family:Verdana;">traits</span><span style="font-family:宋体;">，其内嵌的</span><span style="font-family:Verdana;"><strong>::type</strong></span><span style="font-family:宋体;">会根据不同的模板参数表现为不同的类型，在本例中，</span><span style="font-family:Verdana;"><strong>::type</strong></span><span style="font-family:宋体;">的类型将会被推导为 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>function_invoker1</strong>&lt;int(*)(int),int,int&gt;</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">而</span><span style="font-family:Verdana;"><strong>function_invoker1</strong></span><span style="font-family:宋体;">是个类模板，其定义为： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename FunctionPtr,</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename R</span><span style="font-family:宋体;">，</span><span style="font-family:Courier New;">typename T0</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">&gt; // </span><span style="font-family:宋体;">注意这里的模板参数，后面会解释 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">struct function_invoker1</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">static R <strong>invoke</strong>(any_pointer function_ptr, T0 a0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">FunctionPtr <strong>f</strong> = </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;"><strong>reinterpret_cast</strong>&lt;FunctionPtr&gt;(<strong>function_ptr.func_ptr</strong>);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">return <strong>f(a0)</strong>;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">};</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">所以对</span><span style="font-family:Verdana;"><strong>invoker</strong></span><span style="font-family:宋体;">的赋值最终相当于： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">invoker = &amp;function_invoker1&lt;int(*)(int),int,int&gt;::invoke;</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">而从上面的</span><span style="font-family:Verdana;">function_invoker1</span><span style="font-family:宋体;">的定义可以看出， </span></span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>function_invoker1</strong>&lt;int(*)(int),int,int&gt;::<strong>invoke</strong></span><span style="font-family:宋体;">是一个静态成员函数，它被实例化后相当于： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">static int <strong>invoke</strong>(any_pointer function_ptr, int a0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;"><strong>先转型，再调用</strong>，注意，这一行语句还有一个<em>额外的作用</em>，在后面解释 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">int (*f)(int) = reinterpret_cast&lt;int(*)(int)&gt;(function_ptr.func_ptr);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">   &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">因为</span><span style="font-family:Courier New;">f</span><span style="font-family:宋体;">指向的是用户保存在该</span><span style="font-family:Courier New;">function</span><span style="font-family:宋体;">中的函数或仿函数， </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">所以这一行语句进行了<strong>最终真正的调用</strong>！ </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">return <strong>f(a0)</strong>;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">我们可以看出，在</span><span style="font-family:Verdana;"><strong>invoke</strong></span><span style="font-family:宋体;">函数中，真正的调用现身了。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">此外，如果用户当初给出的是仿函数而不是函数指针，则有</span><span style="font-family:Verdana;"><strong>function_obj_invoker1</strong></span><span style="font-family:宋体;">与它对应，后者也是一个类似的模板，它的</span><span style="font-family:Verdana;"><strong>invoke</strong></span><span style="font-family:宋体;">静态成员函数的形式也是： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">static R invoke(any_pointer <strong>function_obj_ptr</strong>, T0 a0);</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">其中</span><span style="font-family:Verdana;">function_obj_ptr</span><span style="font-family:宋体;">是指向仿函数的指针，所以这个版本的</span><span style="font-family:Verdana;"><strong>invoke</strong></span><span style="font-family:宋体;">中对它的调用语句是这样的： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">FunctionObj* f = <strong>(FunctionObj*)</strong>(function_obj_ptr.obj_ptr);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">return <strong>(*f)</strong>(a0); // </span><span style="font-family:宋体;">调用用户当初给出的仿函数 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">最后一种可能：如果接受的是成员函数怎么办呢？简单的答案是：</span><span style="font-family:Verdana;">boost::function</span><span style="font-family:宋体;">并没有为成员函数作任何特殊准备！理由也很简单，</span><span style="font-family:Verdana;">boost::function</span><span style="font-family:宋体;">只要先将成员函数封装为仿函数，然后将其作为一般的仿函数对待就行了，具体代码就不列了，</span><span style="font-family:Verdana;">STL</span><span style="font-family:宋体;">中有一个函数模板</span><span style="font-family:Verdana;">std::mem_fun</span><span style="font-family:宋体;">就是用于封装成员函数指针的，它返回的是一个仿函数。</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">中也对该函数模板做了扩充，使它可以对付任意多个参数的成员函数。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:14pt;"><strong><span style="font-family:宋体;">做一个，送一个</span><span style="font-family:Verdana;">——invoker</span></strong></span><span style="font-family:宋体;"><span style="font-size:14pt;"><strong>的额外好处</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">我们注意到</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的构造和赋值函数及其基类的构造和赋值函数都是模板函数，这是因为用户可能提供函数也可能提供仿函数，但最关键的还是，</span><span style="font-family:Verdana;">functiont</span><span style="font-family:宋体;">提供一种能力：对于</span><span style="font-family:Verdana;">function&lt;<strong>double</strong>(int)&gt;</span><span style="font-family:宋体;">类型的泛型函数指针，用户可以给它一个</span><span style="font-family:Verdana;"><strong>int</strong>(int)</span><span style="font-family:宋体;">类型的函数</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">是的，这是可行且安全的，因为其返回值类型</span><span style="font-family:Verdana;"><strong>int</strong></span><span style="font-family:宋体;">可以安全的转型为</span><span style="font-family:Verdana;"><strong>double</strong></span><span style="font-family:宋体;">，而对于这种类型兼容性的检查就在上面分析的</span><span style="font-family:Verdana;">invoke</span><span style="font-family:宋体;">静态成员函数中，这就是我们要说的额外好处</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">如果类型兼容，那么</span><span style="font-family:Verdana;">invoke</span><span style="font-family:宋体;">函数就能正常编译通过，但如果用户给出类型不兼容的函数，就会得到一个错误，这个错误是在编译器实例化</span><span style="font-family:Verdana;">invoke</span><span style="font-family:宋体;">函数代码的时候给出的，例如，用户如果这样写： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">// </span><span style="font-family:宋体;">声明一个双参的函数</span><span style="font-family:Courier New;">f</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">RT1 f(P1,P2); </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">   &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">  // </span><span style="font-family:宋体;">单参的</span><span style="font-family:Courier New;">function</span><span style="font-family:宋体;">实例 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">function&lt;RT(P)&gt; f_ptr; </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">f_ptr = &amp;f; // </span><span style="font-family:宋体;">类型不兼容，错误！ </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">这就会导致编译错误，错误发生在</span><span style="font-family:Verdana;">invoke</span><span style="font-family:宋体;">静态成员函数中。下面我就为你解释为什么。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">我想你对</span><span style="font-family:Verdana;"><strong>function_invoker1</strong></span><span style="font-family:宋体;">的三个模板参数仍然心存疑惑，我们再一次来回顾一下其声明： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename FunctionPtr,</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typename R</span><span style="font-family:宋体;">，</span><span style="font-family:Courier New;">typename T0&gt; </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">struct function_invoker1</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">我们还得把目光投向</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">模板函数，其中使用</span><span style="font-family:Verdana;"><strong>function_invoker1</strong></span><span style="font-family:宋体;">的时候是这样的： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef typename ...::<strong>get_function_invoker1</strong>&lt;</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">                         FunctionPtr,R,T0&gt;::type invoker_type;</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><strong><span style="font-family:Verdana;">FunctionPtr</span><span style="font-family:宋体;">，</span><span style="font-family:Verdana;">R</span><span style="font-family:宋体;">，</span><span style="font-family:Verdana;">T0</span></strong><span style="font-family:宋体;">三个模板参数将会被原封不动的传给</span><span style="font-family:Verdana;"><strong>function_invoker1</strong></span><span style="font-family:宋体;">，那么对于我们上面的错误示例，这三个模板参数各是什么呢？ </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">首先，我们很容易看出，</span><span style="font-family:Verdana;"><strong>FunctionPtr</strong></span><span style="font-family:宋体;">就是</span><span style="font-family:Verdana;">assign_to</span><span style="font-family:宋体;">模板函数的模板参数，也就是用户传递的函数或仿函数的类型，在我们的错误示例中，函数</span><span style="font-family:Verdana;"><strong>f</strong></span><span style="font-family:宋体;">的类型为</span><span style="font-family:Verdana;"><strong>RT1(P1,P2)</strong></span><span style="font-family:宋体;">，所以 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>FunctionPtr </strong>= <strong>RT1(*)(P1,P2)</strong></span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">而</span><span style="font-family:Verdana;"><strong>R</strong>,<strong>T0</strong></span><span style="font-family:宋体;">则是用户在实例化</span><span style="font-family:Verdana;"><strong>function</strong></span><span style="font-family:宋体;">模板时给出的模板参数，我们写的是</span><span style="font-family:Verdana;">function&lt;<strong>RT(P)</strong>&gt;</span><span style="font-family:宋体;">，于是</span><span style="font-family:Verdana;">:</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 22pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>R</strong> = <strong>RT</strong></span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 22pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>T0 </strong>= <strong>P</strong></span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">所以，对于我们的错误示例，</span><span style="font-family:Verdana;"><strong>invoker_type</strong></span><span style="font-family:宋体;">的类型为： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>function_invoker1</strong>&lt;<strong> RT1(*)(P1,P2)</strong>,<strong>RT,P</strong>&gt;</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">对于这样一个</span><span style="font-family:Verdana;">function_invoker1</span><span style="font-family:宋体;">，其内部的</span><span style="font-family:Verdana;"><strong>invoke</strong></span><span style="font-family:宋体;">静态成员函数被实例化为： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">static RT invoke(any_pointer function_ptr,P a0)</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">  // </span><span style="font-family:宋体;">注意</span><span style="font-family:Courier New;">f</span><span style="font-family:宋体;">的类型 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">RT1 (*<strong>f</strong>)(P1,P2) = reinterpret_cast&lt;RT1(*)(P1,P2)&gt;(function_ptr.func_ptr);</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;">     &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">return f(a0); //</span><span style="font-family:宋体;">错啦！瞧瞧</span><span style="font-family:Courier New;">f</span><span style="font-family:宋体;">的类型，</span><span style="font-family:Courier New;">f</span><span style="font-family:宋体;">能接受一个</span><span style="font-family:Courier New;">P</span><span style="font-family:宋体;">类型的参数吗？编译器在此打住。 </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">}</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">看看最后一行语句，所有的检查都在那里了</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">我们最终把检查</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">委托</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">给了</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">底层的类型系统。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">很精妙不是吗？虽然在模板形式的</span><span style="font-family:Verdana;">assign_to</span><span style="font-family:宋体;">函数中，看起来我们并不关心到底用户给的参数是何类型，看起来用户可以把任何函数或仿函数塞过来，但是一旦下面触及</span><span style="font-family:Verdana;">invoker</span><span style="font-family:宋体;">的赋值，就得实例化</span><span style="font-family:Verdana;">invoke</span><span style="font-family:宋体;">静态成员函数，其中的： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">return f<strong>(a0)</strong>;</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">一下就把问题暴露出来了！这种把类型检查延迟到最后，不得不进行的时候，由</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">底层的类型系统来负责检查的手法的确很奇妙</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">看起来我们没有在</span><span style="font-family:Verdana;"><strong>assign_to</strong></span><span style="font-family:宋体;">函数中及时利用类型信息进行类型检查，但是我们却并没有丧失任何类型安全性，一切最终都逃不过</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">底层的类型系统的考验！ </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:14pt;"><strong>function</strong></span><span style="font-family:宋体;"><span style="font-size:14pt;"><strong>如何对待成员函数</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">对于成员函数，</span><span style="font-family:Verdana;">assign_to</span><span style="font-family:宋体;">的重载版本只有一行： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">this-&gt;assign_to(<strong>mem_fn(</strong>f<strong>)</strong>);</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>mem_fun(</strong>f<strong>)</strong></span><span style="font-family:宋体;">返回一个仿函数，它封装了成员函数</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">，之后一切皆与仿函数无异。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">关于</span><span style="font-family:Verdana;">mem_fun</span><span style="font-family:宋体;">的细节，这里就不多说了，大家可以参考</span><span style="font-family:Verdana;">STL</span><span style="font-family:宋体;">中的实现，相信很容易看懂，这里只简单的提醒一下，成员函数封装的效果是这样的： </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">R (<strong>C</strong>::*)(T0,T1,...) =&gt; R (*)(<strong>C*</strong>,T0,T1,...) </span><span style="font-family:宋体;">或</span><span style="font-family:Verdana;"> R (*)(<strong>C&amp;,</strong>T0,T1,...)</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:15pt;"><strong>safe_bool</strong></span><span style="font-family:宋体;"><span style="font-size:15pt;"><strong>惯用手法</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:宋体;">如你所知，对于函数指针</span><span style="font-family:Verdana;">fptr</span><span style="font-family:宋体;">，我们可以这样测试它：</span><span style="font-family:Verdana;"> ...</span><span style="font-family:宋体;">，所以</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">也应该提供这一特性，然而如果直接重载</span><span style="font-family:Verdana;">operator bool()</span><span style="font-family:宋体;">则会导致下面的代码成为合法的</span><span style="font-family:Verdana;">:</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;">function&lt;int(int)&gt; f;</span><span style="font-family:宋体;">    </span></span></p><p style="margin-left: 11pt;"><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>int</strong> b=f;</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">这显然不妥，所以</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">用另一个巧妙的手法替代它，既所谓的</span><span style="font-family:Verdana;">safe_bool</span><span style="font-family:宋体;">惯用手法，这在</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">定义内部的源码如下： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">struct dummy { void nonnull(){};};</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">typedef void (dummy::*<strong>safe_bool</strong>)(); // </span><span style="font-family:宋体;">确保</span><span style="font-family:Courier New;">safebool</span><span style="font-family:宋体;">不能转型为任何其它类型！ </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">operator <strong>safe_bool</strong> () const </span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">{ return (this-&gt;empty())? 0 : &amp;dummy::nonnull; }</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">这样，当你写</span><span style="font-family:Verdana;"></span><span style="font-family:宋体;">的时候，编译器会找到</span><span style="font-family:Verdana;">operator safe_bool()</span><span style="font-family:宋体;">，从而将</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">转型为</span><span style="font-family:Verdana;">safe_bool</span><span style="font-family:宋体;">，这是个指针类型，</span><span style="font-family:Verdana;">if</span><span style="font-family:宋体;">语句会正确判定它是否为空指针。而当你试图把</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">赋给其它整型变量的时候则会遭到编译期的拒绝</span><span style="font-family:Verdana;">——</span><span style="font-family:宋体;">因为</span><span style="font-family:Verdana;">safe_bool</span><span style="font-family:宋体;">是一个成员指针类型，无法向其它整型转换。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:Verdana; font-size:15pt;"><strong>get_function_tag</strong></span><span style="font-family:宋体; font-size:12pt;">   </span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;"><strong>get_function_tag</strong></span><span style="font-family:宋体;">用于萃取出函数所属类别</span><span style="font-family:Verdana;">(category)</span><span style="font-family:宋体;">，各个类别在源代码中已经列出，至于它到底是如何萃取的，这与本文关系不是很大，有一点需要提醒一下：函数指针类型也是指针类型，这听起来完全是句废话，但是考虑这样的代码： </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename T&gt; struct is_pointer{enum{value=0};};</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">template&lt;typename T&gt; struct is_pointer&lt;T*&gt;{enum{value=1};};</span><span style="font-family:宋体;">   </span></p><p style="text-align: justify;"><span style="font-family:Courier New;">std::cout&lt;&lt;is_pointer&lt;int(*)(int)&gt;::value; // </span><span style="font-family:宋体;">这将输出</span><span style="font-family:Courier New;"> 1</span><span style="font-family:宋体;">   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">也就是说</span><span style="font-family:Verdana;"><strong>int(*)(int)</strong></span><span style="font-family:宋体;">可以与</span><span style="font-family:Verdana;"><strong>T*</strong></span><span style="font-family:宋体;">形式匹配，匹配时</span><span style="font-family:Verdana;"><strong>T</strong></span><span style="font-family:宋体;">为</span><span style="font-family:Verdana;"><strong>int(int)</strong></span><span style="font-family:宋体;">。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体;"><span style="font-size:15pt;"><strong>最后一些细节</strong></span><span style="font-size:12pt;">    </span></span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">1. </span><span style="font-family:宋体;">我没有给出</span><span style="font-family:Verdana;">function_base</span><span style="font-family:宋体;">的源代码，实际上那很简单，它最主要的成员就是一个</span><span style="font-family:Verdana;">union any_pointer</span><span style="font-family:宋体;">型的数据成员 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">    // </span><span style="font-family:宋体;">用于统一保存函数指针及仿函数对象指针 </span></span></p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">detail::function::any_pointer functor;  </span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">2. </span><span style="font-family:宋体;">我没有给出</span><span style="font-family:Verdana;">functor_manager</span><span style="font-family:宋体;">的信息，实际上它与</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的实现没有太大关系，它负责</span><span style="font-family:Verdana;">copy</span><span style="font-family:宋体;">和</span><span style="font-family:Verdana;">delete</span><span style="font-family:宋体;">函数对象，如果必要的话。所以我将它略去，它的源码在</span><span style="font-family:Verdana;">"boost/function/function_base.hpp"</span><span style="font-family:宋体;">里。 </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:Verdana;">3. </span><span style="font-family:宋体;">我给出的源代码是将宏展开后的版本，实际的代码中充斥着让人眼花缭乱的宏，关于那些宏则又是一个奇妙的世界。</span><span style="font-family:Verdana;">boost</span><span style="font-family:宋体;">库通过那些宏省去了许多可见代码量。随着函数参数的不同，那些宏会扩展出</span><span style="font-family:Verdana;">function2,function3...</span><span style="font-family:宋体;">各个版本。而本文只研究了</span><span style="font-family:Verdana;">int(int)</span><span style="font-family:宋体;">型的情况，其它只是参数数目的改变而已。经过宏的扩展，</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">的偏特化版本将有</span><span style="font-family:Verdana;">:</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">template&lt;typename R,typename Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">class function&lt;<strong>R()</strong>,Allocator&gt;:public function0&lt;R,Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">{...};</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">template&lt;typename R,typename T0,typename Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">class function&lt;<strong>R(T0)</strong>,Allocator&gt;:public function1&lt;R,T0,Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">{...};</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">template&lt;typename R,typename T0,typename T1,typename Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">class function&lt;<strong>R(T0,T1)</strong>,Allocator&gt;:public function2&lt;R,T0,T1,Allocator&gt;</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">{...};</span><span style="font-family:宋体;">    </span></span></p><p style="text-align: justify;"><span style="font-size:12pt;"><span style="font-family:Courier New;">...</span><span style="font-family:宋体;">    </span></span></p><p>&nbsp; &nbsp;</p><p><span style="font-size:12pt;"><span style="font-family:宋体;">等更多版本，一共有</span><span style="font-family:Verdana;">BOOST_FUNCTION_MAX_ARGS+1</span><span style="font-family:宋体;">个版本，</span><span style="font-family:Verdana;">BOOST_FUNCTION_MAX_ARGS</span><span style="font-family:宋体;">为一个宏，控制最多能够接受有多少个参数的函数及仿函数对象，你可以重新定义这个宏为一个新值，以控制</span><span style="font-family:Verdana;">function</span><span style="font-family:宋体;">所能支持的函数参数个数的最大值。其中的</span><span style="font-family:Verdana;"><strong>function0</strong>,<strong>function1</strong>,<strong>function2</strong></span><span style="font-family:宋体;">等名字也由宏扩展出。</span></span></p>
</body></html>