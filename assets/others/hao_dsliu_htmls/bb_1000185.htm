<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：ATL Under the Hood 1</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>ATL Under the Hood 1</h2>
<p align="right">发布时间：2011-11-28 14:10
<br>分类名称：ATL</p><br>
<p><span style="font-family:Verdana;"  ><span style="color:#ff9900; font-size:13pt;"  ><strong>Introduction<br></strong></span><span style="font-size:10pt;"  >In this series of tutorials I am going to discuss some of the inner workings of ATL and the techniques that ATL uses. <br>Let's start the discussion by talking about the memory layout of a program. Let's make a simple program which doesn't have any data members and take a look at the memory structure of it.<br></span><span style="color:#ff9900;"  ><strong>Program 1.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>};</span><br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of object is = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objClass) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of object is = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objClass <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size of <span style="color:#339999;"  >object</span> is = <span style="color:navy;"  >1</span><br>Address of <span style="color:#339999;"  >object</span> is = 0012FF7C<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Now if we are going to add some data members then the size of the class is the sum of all the storage of the individual member variables. It is also true in the case of template. Now let's take a look at template class of Point. <br></span><span style="color:#ff9900;"  ><strong>Program 2.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> CPoint {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;T m_x;<br>&nbsp;&nbsp;&nbsp;&nbsp;T m_y;<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint<span style="color:blue;"  >&lt;int&gt;</span> objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of object is = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objPoint) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of object is = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objPoint <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now the output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size of <span style="color:#339999;"  >object</span> is = <span style="color:navy;"  >8</span><br>Address of <span style="color:#339999;"  >object</span> is = 0012FF78<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Now add inheritance too in the program. Now we are going to inherit class Point3D from Point class and see the memory structure of this program. <br></span><span style="color:#ff9900;"  ><strong>Program 3.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> CPoint {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;T m_x;<br>&nbsp;&nbsp;&nbsp;&nbsp;T m_y;<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> CPoint3D : <span style="color:blue;"  >public</span> CPoint<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;T m_z;<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint<span style="color:blue;"  >&lt;int&gt;</span> objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of object Point is = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objPoint) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of object Point is = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objPoint <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint3D<span style="color:blue;"  >&lt;int&gt;</span> objPoint3D;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of object Point3D is = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objPoint3D) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of object Point3D is = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objPoint3D <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size of <span style="color:#339999;"  >object</span> Point is = <span style="color:navy;"  >8</span><br>Address of <span style="color:#339999;"  >object</span> Point is = 0012FF78<br>Size of <span style="color:#339999;"  >object</span> Point3D is = <span style="color:navy;"  >12</span><br>Address of <span style="color:#339999;"  >object</span> Point3D is = 0012FF6C<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This program shows the memory structure of the derived class. It shows the memory occupied by the object is sum of its data member plus its base member.&nbsp; <br>Things become interesting when a virtual function joins the party. Take a look at the following program<br></span><span style="color:#ff9900;"  ><strong>Program 4.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fun() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objClass) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objClass <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size of Class = <span style="color:navy;"  >4</span><br>Address of Class = 0012FF7C<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >And situation becomes more interesting when we add more than one virtual function. <br></span><span style="color:#ff9900;"  ><strong>Program 5.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fun1() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::fun1"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fun2() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::fun2"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fun3() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::fun3"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objClass) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objClass <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of the program is same as above program. Let's do one more experiment to better understand it. <br></span><span style="color:#ff9900;"  ><strong>Program 6.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> CPoint {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_ix;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iy;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span> ~CPoint() { };<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objPoint) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of Class = "</span>    <span style="color:blue;"  >&lt;&lt;</span> &amp;objPoint <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size of Class = <span style="color:navy;"  >12</span><br>Address of Class = 0012FF68<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of these programs shows that when you add any virtual function in the class then its size increases one </span><span style="color:blue; font-family:Courier New;"  >int</span><span style="font-family:Verdana; font-size:10pt;"  > size. i.e. in Visual C++ it increase by 4 bytes. It means there are 3 slots for integer in this class one for x one for y and one to handle virtual function that is called a <strong>virtual pointer</strong>. First take a look at the new slot, namely the virtual pointer that is at the start (or end) the object. To do this we are going to directly access memory occupied by the object. We do this by storing the address of an object in an </span><span style="color:blue; font-family:Courier New;"  >int</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > pointer and using the magic of pointer arithmetic. <br></span><span style="color:#ff9900;"  ><strong>Program 7.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> CPoint {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_ix;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iy;<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint(<span style="color:blue;"  >const</span>    <span style="color:blue;"  >int</span> p_ix = <span style="color:navy;"  >0</span>, <span style="color:blue;"  >const</span>    <span style="color:blue;"  >int</span> p_iy = <span style="color:navy;"  >0</span>) : <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_ix(p_ix), m_iy(p_iy) { <br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> getX() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_ix;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> getY() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_iy;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span> ~CPoint() { };<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint objPoint(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span>* pInt = (<span style="color:blue;"  >int</span>*)&amp;objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+0) = <span style="color:navy;"  >100</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of x<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+1) = <span style="color:navy;"  >200</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of y<br></em></span><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"X = "</span>    <span style="color:blue;"  >&lt;&lt;</span> objPoint.getX() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Y = "</span>    <span style="color:blue;"  >&lt;&lt;</span> objPoint.getY() <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The important thing in this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span>* pInt = (<span style="color:blue;"  >int</span>*)&amp;objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+0) = <span style="color:navy;"  >100</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of x<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+1) = <span style="color:navy;"  >200</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of y<br></em></span></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >In which we treat object as an integer pointer after store its address in integer pointer. The output of this program is <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img4.ph.126.net_jDLCIMh_XjRCefU0QGxyjg==_1552897446529759244.jpg"  alt=""  ></span><span style="font-size:8pt;"  >     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  >X = <span style="color:navy;"  >200</span><br>Y = <span style="color:navy;"  >10</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Of course this is not our required result. This shows when 200 is store in the location where </span><span style="color:#990000; font-family:Courier New;"  >m_ix</span><span style="font-family:Verdana; font-size:10pt;"  > data member is resident. This means </span><span style="color:#990000; font-family:Courier New;"  >m_ix</span><span style="font-family:Verdana; font-size:10pt;"  > i.e. first member variable, start from second position of the memory not the first. In other words the first member is the virtual pointer and then rest is the data member of the object. Just change the following two lines <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >int</span>* pInt = (<span style="color:blue;"  >int</span>*)&amp;objPoint;<br>*(pInt+1) = <span style="color:navy;"  >100</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of x<br></em></span>*(pInt+2) = <span style="color:navy;"  >200</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of y<br></em></span></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >And we get the required result. Here is the complete program <br></span><span style="color:#ff9900;"  ><strong>Program 8.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> CPoint {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_ix;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iy;<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint(<span style="color:blue;"  >const</span>    <span style="color:blue;"  >int</span> p_ix = <span style="color:navy;"  >0</span>, <span style="color:blue;"  >const</span>    <span style="color:blue;"  >int</span> p_iy = <span style="color:navy;"  >0</span>) : <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_ix(p_ix), m_iy(p_iy) { <br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> getX() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_ix;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> getY() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_iy;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span> ~CPoint() { };<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;CPoint objPoint(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span>* pInt = (<span style="color:blue;"  >int</span>*)&amp;objPoint;<br>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+1) = <span style="color:navy;"  >100</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of x<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;*(pInt+2) = <span style="color:navy;"  >200</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// want to change the value of y<br></em></span><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"X = "</span>    <span style="color:blue;"  >&lt;&lt;</span> objPoint.getX() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Y = "</span>    <span style="color:blue;"  >&lt;&lt;</span> objPoint.getY() <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >And output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >X = <span style="color:navy;"  >100</span><br>Y = <span style="color:navy;"  >200</span><br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This clearly shows that whenever we add the virtual function into the class then the virtual pointer is added at first location of memory structure. <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img1.ph.126.net_V5jAfvz2xyeeFTRCBY2kIw==_2712574350577702711.jpg"  alt=""  ><br><br>Now the question arises: what is stored in the virtual pointer? Take a look at the following program to get an idea of this <br></span><span style="color:#ff9900;"  ><strong>Program 9.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> fun() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Class::fun"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of virtual pointer "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at virtual pointer "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Address of <span style="color:blue;"  >virtual</span> pointer 0012FF7C<br>Value at <span style="color:blue;"  >virtual</span> pointer 0046C060<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The virtual pointer stores the address of a table that is called the virtual table. And a virtual table stores address of all the virtual functions of that class. In other words the virtual table is an array of addresses of virtual functions. Let's take a look at the following program to get an idea of it. <br></span><span style="color:#ff9900;"  ><strong>Program 10.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> fun() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Class::fun"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>};<br><br><span style="color:blue;"  >typedef</span>    <span style="color:blue;"  >void</span> (*Fun)(<span style="color:blue;"  >void</span>);<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of virtual pointer "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at virtual pointer i.e. Address of virtual table "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at first entry of virtual table "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Executing virtual function"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;Fun pFun = (Fun)*(<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program has some uncommon indirection with typecast. The most important line of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;Fun pFun = (Fun)*(<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0);<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here </span><span style="color:#990000; font-family:Courier New;"  >Fun </span><span style="font-family:Verdana; font-size:10pt;"  >is a </span><span style="color:blue; font-family:Courier New;"  >typedef</span><span style="font-family:Verdana; font-size:10pt;"  >'d function pointer. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >typedef</span>    <span style="color:blue;"  >void</span> (*Fun)(<span style="color:blue;"  >void</span>);<br></span><span style="font-family:Verdana; font-size:10pt;"  >Let's dissect the lengthy uncommon indirection. </span><span style="color:#990000;"  ><span style="font-family:Courier New;"  >(<span style="color:blue;"  >int<span style="color:#990000;"  >*)(&amp;objClass+0) </span></span></span><span style="font-family:Verdana; font-size:10pt;"  >gives the address of the virtual pointer of the class which is the first entry in the class and we typecast it to </span><span style="color:blue;"  ><span style="font-family:Courier New;"  >int<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  >. To get the value at this address we use the indirection operator (i.e. </span><span style="color:#990000; font-family:Courier New;"  >*</span><span style="font-family:Verdana; font-size:10pt;"  >) and then again typecast it to </span><span style="font-family:Courier New;"  >int<span style="color:#990000;"  >*</span></span><span style="font-family:Verdana; font-size:10pt;"  > i.e. </span><span style="color:#990000;"  ><span style="font-family:Courier New;"  >(<span style="color:blue;"  >int<span style="color:#990000;"  >*)*(<span style="color:blue;"  >int<span style="color:#990000;"  >*)(&amp;objClass+0)</span></span></span></span></span><span style="font-family:Verdana; font-size:10pt;"  >. This will give the address of first entry of the virtual table. To get the value at this location, i.e. get the address of first virtual function of the class again use the indirection operator and now typecast to the appropriate function pointer typ</span></span><span style="font-family:Verdana; font-size:10pt;"  >e. So </span></span><span style="font-family:Verdana; font-size:10pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;Fun pFun = (Fun)*(<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0);<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Means get the value from the first entry of the virtual table and store it in pFun after typecast it into the Fun type. <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img4.ph.126.net_iPo8ggdu5beateWSqq_TOA==_619244948780553194.jpg"  alt=""  ><br><br>What happen when one more virtual function add in the class. Now we want to access second member of the virtual table. Take a look at the following program to see the values at virtual table <br></span><span style="color:#ff9900;"  ><strong>Program 11.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Class::f"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of virtual pointer "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at virtual pointer i.e. Address of virtual table "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Information about VTable"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 1st entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 2nd entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+1) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Address of <span style="color:blue;"  >virtual</span> pointer 0012FF7C<br>Value at <span style="color:blue;"  >virtual</span> pointer i.e. Address of <span style="color:blue;"  >virtual</span> table 0046C0EC<br><br>Information about VTable<br><br>Value at 1st entry of VTable 0040100A<br>Value at 2nd entry of VTable 0040129E<br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img5.ph.126.net_tWDew4FDrPW8QUX4YK1MWw==_1046242488450614795.jpg"  alt=""  ></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  ><br><br>Now one question naturally comes in the mind. How does the compiler know the length of the vtable? The answer is the last entry of vtable is NULL. Change a program little bit to get an idea of this. <br></span><span style="color:#ff9900;"  ><strong>Program 12.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Class::f"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of virtual pointer "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at virtual pointer i.e. Address of virtual table "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Information about VTable"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 1st entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+0) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 2nd entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+1) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 3rd entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+2) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Value at 4th entry of VTable "</span>    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>*)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+3) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img4.ph.126.net_jDLCIMh_XjRCefU0QGxyjg==_1552897446529759244.jpg"  alt=""  ></span><span style="font-size:8pt;"  >     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  >Address of <span style="color:blue;"  >virtual</span> pointer 0012FF7C<br>Value at <span style="color:blue;"  >virtual</span> pointer i.e. Address of <span style="color:blue;"  >virtual</span> table 0046C134<br><br>Information about VTable<br><br>Value at 1st entry of VTable 0040100A<br>Value at 2nd entry of VTable 0040129E<br>Value at 3rd entry of VTable <span style="color:navy;"  >00000000</span><br>Value at 4th entry of VTable 73616C43<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Output of this program shows that the last entry of vtable is NULL. Let's call virtual function from the knowledge we have. <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img3.ph.126.net_EYDSFx83MLXhYGPXHCEKaA==_622341173524370443.jpg"  alt=""  ><br></span><span style="color:#ff9900;"  ><strong>Program 13.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Class {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Class::f"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Class::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >typedef</span>    <span style="color:blue;"  >void</span>(*Fun)(<span style="color:blue;"  >void</span>);<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Class objClass;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Fun pFun = NULL;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 1st virtual function<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+0);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 2nd virtual function<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)(&amp;objClass+0)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Class::f<br>Class::g<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Now let's see the case of multiple inheritance. Let's see the simple case of multiple inheritances <br></span><span style="color:#ff9900;"  ><strong>Program 14.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive objDrive;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size is = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(objDrive) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Size is = <span style="color:navy;"  >12</span><br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This program shows when you drive class with more then one base class then drive class have virtual pointer of all of base classes. <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img2.ph.126.net_kgER_qt7NagoBl8-rwWJ8g==_590815976132775292.jpg"  alt=""  ><br><br>And what happen when drive class also have virtual function. Lets see this program to better understand the concepts of virtual function with multiple inheritance. <br></span><span style="color:#ff9900;"  ><strong>Program 15.<br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img4.ph.126.net_jDLCIMh_XjRCefU0QGxyjg==_1552897446529759244.jpg"  alt=""  ></strong></span><span style="font-size:8pt;"  >     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>     <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>     <span style="color:purple;"  >"Base1::f"</span>     <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base1::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >class</span> Base2 {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base2::f"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base2::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base3::f"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> g() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base3::g"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fd() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fd"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> gd() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::gd"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >typedef</span>    <span style="color:blue;"  >void</span>(*Fun)(<span style="color:blue;"  >void</span>);<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive objDrive;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Fun pFun = NULL;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 1st virtual function of Base1<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+0)+0);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 2nd virtual function of Base1<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+0)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 1st virtual function of Base2<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+1)+0);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 2nd virtual function of Base2<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+1)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 1st virtual function of Base3<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+2)+0);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 2nd virtual function of Base3<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+2)+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 1st virtual function of Drive<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+0)+2);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// calling 2nd virtual function of Drive<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pFun = (Fun)*((<span style="color:blue;"  >int</span>*)*(<span style="color:blue;"  >int</span>*)((<span style="color:blue;"  >int</span>*)&amp;objDrive+0)+3);<br>&nbsp;&nbsp;&nbsp;&nbsp;pFun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img4.ph.126.net_jDLCIMh_XjRCefU0QGxyjg==_1552897446529759244.jpg"  alt=""  ></span><span style="font-size:8pt;"  >     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  >Base1::f<br>Base1::g<br>Base2::f<br>Base2::f<br>Base3::f<br>Base3::f<br>Drive::fd<br>Drive::gd<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program show that the virtual function of drive store in the vtable of first vptr. <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img3.ph.126.net_4doOplIGY42W5jwxyWKHVw==_51509920755159463.jpg"  alt=""  ><br><br>We can get the offset of Drive class vptr with the help of </span><span style="color:blue; font-family:Courier New;"  >static_cast</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >. Let's take a look at he following program to better understand it. <br></span><span style="color:#ff9900;"  ><strong>Program 16.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br>};<br><br><span style="color:green;"  ><em>// any non zero value because multiply zero with any no is zero<br></em><span style="color:navy;"  >#define</span> SOME_VALUE&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >1</span><br></span><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> (DWORD)<span style="color:blue;"  >static_cast&lt;</span>Base1*<span style="color:blue;"  >&gt;</span>((Drive*)SOME_VALUE)-SOME_VALUE <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> (DWORD)<span style="color:blue;"  >static_cast&lt;</span>Base2*<span style="color:blue;"  >&gt;</span>((Drive*)SOME_VALUE)-SOME_VALUE <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> (DWORD)<span style="color:blue;"  >static_cast&lt;</span>Base3*<span style="color:blue;"  >&gt;</span>((Drive*)SOME_VALUE)-SOME_VALUE <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >ATL use a macro name offsetofclass defined in ATLDEF.H to do this. Macro is defined at <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#define</span> offsetofclass(base, derived) \<br>       ((DWORD)(<span style="color:blue;"  >static_cast&lt;</span>base*<span style="color:blue;"  >&gt;</span>((derived*)_ATL_PACKING))-_ATL_PACKING)<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This macro returns the offset of the base class vptr in the drive class object model. Let's see an example to get an idea of this <br></span><span style="color:#ff9900;"  ><strong>Program 17.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br>#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>             <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base</span>1 {</span><br><span style="color:blue;"  >public</span>:</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>       <span style="color:blue;"  >void</span> f() { }</span><br></span>};</span><br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br>};<br><br><span style="color:navy;"  >#define</span> _ATL_PACKING <span style="color:navy;"  >8</span><br><br><span style="color:navy;"  >#define</span> offsetofclass(base, derived) \<br>&nbsp;&nbsp;&nbsp;&nbsp;((DWORD)(<span style="color:blue;"  >static_cast&lt;</span>base*<span style="color:blue;"  >&gt;</span>((derived*)_ATL_PACKING))-_ATL_PACKING)<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> offsetofclass(Base1, Drive) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> offsetofclass(Base2, Drive) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> offsetofclass(Base3, Drive) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The memory layout of the drive class is <br><img title="ATL Under the Hood 1 - Dsliu - Dspace"  src="pic/img2.ph.126.net_kgER_qt7NagoBl8-rwWJ8g==_590815976132775292.jpg"  alt=""  ><br><br>And output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >0</span><br><span style="color:navy;"  >4</span><br><span style="color:navy;"  >8</span><br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Output of this program shows this macro returns the offset of vptr of the required base class. In Don Box's Essential COM, he used a similar macro to this. Change the program little bit and replace ATL macro with Box's macro. <br></span><span style="color:#ff9900;"  ><strong>Program 18.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br>#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>             <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br>public</span>:</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>       <span style="color:blue;"  >void</span> f() { }</span><br></span>};</span><br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br>};<br><br><span style="color:navy;"  >#define</span> BASE_OFFSET(ClassName, BaseName) \<br>&nbsp;&nbsp;&nbsp;&nbsp;(DWORD(<span style="color:blue;"  >static_cast&lt;</span>BaseName*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >reinterpret_cast&lt;</span>ClassName*<span style="color:blue;"  >&gt;</span>\<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x10000000))) - 0x10000000)<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> BASE_OFFSET(Drive, Base1) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> BASE_OFFSET(Drive, Base2) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> BASE_OFFSET(Drive, Base3) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output and purpose of this program is the same as the previous program. <br>Let's do something practical and use this macro in our program. In fact we can call the virtual function of our required base class by getting the offset of base class vptr in drive's memory structure.<br></span><span style="color:#ff9900;"  ><strong>Program 19.<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br>#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>             <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br>public</span>:</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>       <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>       <span style="color:purple;"  >"Base1::f()"</span>       <span style="color:blue;"  >&lt;&lt;</span> endl; }</span><br></span>};</span><br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base2::f()"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >class</span> Base3 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> f() { cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base3::f()"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl; }<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base1, <span style="color:blue;"  >public</span> Base2, <span style="color:blue;"  >public</span> Base3 {<br>};<br><br><span style="color:navy;"  >#define</span> _ATL_PACKING <span style="color:navy;"  >8</span><br><br><span style="color:navy;"  >#define</span> offsetofclass(base, derived) \<br>&nbsp;&nbsp;&nbsp;&nbsp;((DWORD)(<span style="color:blue;"  >static_cast&lt;</span>base*<span style="color:blue;"  >&gt;</span>((derived*)_ATL_PACKING))-_ATL_PACKING)<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive d;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span>* pVoid = NULL;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// call function of Base1<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pVoid = (<span style="color:blue;"  >char</span>*)&amp;d + offsetofclass(Base1, Drive);<br>&nbsp;&nbsp;&nbsp;&nbsp;((Base1*)(pVoid))-<span style="color:blue;"  >&gt;</span>f();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// call function of Base2<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pVoid = (<span style="color:blue;"  >char</span>*)&amp;d + offsetofclass(Base2, Drive);<br>&nbsp;&nbsp;&nbsp;&nbsp;((Base2*)(pVoid))-<span style="color:blue;"  >&gt;</span>f();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// call function of Base1<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;pVoid = (<span style="color:blue;"  >char</span>*)&amp;d + offsetofclass(Base3, Drive);<br>&nbsp;&nbsp;&nbsp;&nbsp;((Base3*)(pVoid))-<span style="color:blue;"  >&gt;</span>f();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Base1::f()<br>Base2::f()<br>Base3::f()<br></span><span style="font-family:Verdana; font-size:10pt;"  >I tried to explain the working of </span><span style="color:#990000; font-family:Courier New;"  >offsetofclass</span><span style="font-family:Verdana; font-size:10pt;"  > macro of ATL in this tutorial. I Hope to explore other mysterious of ATL in the next article.<br></span>想知道static_cast为什么可以计算偏移量，可以看看《What static_cast&lt;&gt; is actually doing》</p>
</body></html>