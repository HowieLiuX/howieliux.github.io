<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Socket编程心得</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Socket编程心得</h2>
<p align="right">发布时间：2010-9-5 16:32
<br>分类名称：windows</p><br>
     <p><b style=""  ><span style="font-size: 22pt;"  lang="EN-US"  ><br></span></b><b style=""  ><span style="font-size: 22pt; font-family: 宋体;"  ></span></b><span lang="EN-US"  ></span><b style=""  ><span style="font-family: 宋体;"  >背景知识</span><span lang="EN-US"  ></span></b></p>  <p><b style=""  ><span lang="EN-US"  >TCP/IP</span></b><b style=""  ><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  ></span></b></p>  <p><b style=""  ><span lang="EN-US"  >&nbsp;</span></b></p>  <table style="margin-left: 5.4pt; border-collapse: collapse; border: medium none;"  border="1"  cellpadding="0"  cellspacing="0"  >  <tbody><tr style=""  >   <td style="width: 99pt; border: 1pt solid windowtext; padding: 0cm 5.4pt;"  valign="top"  width="132"  >   <p><span style="font-family: 宋体;"  >应用层</span></p>   </td>  </tr>  <tr style=""  >   <td style="width: 99pt; border-right: 1pt solid windowtext; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;"  valign="top"  width="132"  >   <p><span style="font-family: 宋体;"  >传输层</span><span lang="EN-US"  >(TCP/UDP)</span></p>   </td>  </tr>  <tr style=""  >   <td style="width: 99pt; border-right: 1pt solid windowtext; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;"  valign="top"  width="132"  >   <p><span style="font-family: 宋体;"  >网络层</span><span lang="EN-US"  >(IP)</span></p>   </td>  </tr>  <tr style=""  >   <td style="width: 99pt; border-right: 1pt solid windowtext; border-width: medium 1pt 1pt; border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; padding: 0cm 5.4pt;"  valign="top"  width="132"  >   <p><span style="font-family: 宋体;"  >数据链路层</span></p>   </td>  </tr> </table>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >通常的<b style=""  >套接字是应用到传输层的接口</b></span><span lang="EN-US"  >.(</span><span style="font-family: 宋体;"  >有一种原始的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >可以直接使用</span><span lang="EN-US"  >IP).</span></p>  <p><span style="font-family: 宋体;"  >传输层一般的俩个协议</span><span lang="EN-US"  >: UDP (User Datagram Protocol) and TCP (Transmission Control Protocol ).</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span lang="EN-US"  >UDP </span></b></p>  <p><span style="font-family: 宋体;"  >无连接</span><span lang="EN-US"  > (</span><span style="font-family: 宋体;"  >发送数据无需建立连接</span><span lang="EN-US"  >)</span></p>  <p><span style="font-family: 宋体;"  >不可靠</span><span lang="EN-US"  > (</span><span style="font-family: 宋体;"  >不能确保</span><span lang="EN-US"  >UDP</span><span style="font-family: 宋体;"  >数据报最终达到目的地</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >对接收的数据不发送确认</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >无法指定是否到达目的地</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >数据不会重发</span><span lang="EN-US"  >).</span></p>  <p><span style="font-family: 宋体;"  >速度快</span><span lang="EN-US"  > (</span><span style="font-family: 宋体;"  >由于无需建立连接和确认信息</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >速度也就快了</span><span lang="EN-US"  >).</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span lang="EN-US"  >TCP</span></b></p>  <p><span style="font-family: 宋体;"  >面向连接</span><span lang="EN-US"  > (</span><span style="font-family: 宋体;"  >发送数据前先要建立连接</span><span lang="EN-US"  >)</span></p>  <p><span style="font-family: 宋体;"  >可靠</span><span lang="EN-US"  ><span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>(</span><span style="font-family: 宋体;"  >当发送数据后</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >要求对方返回一个确认信息</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >如果没有接收到对方确认</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >重发</span><span lang="EN-US"  >.)</span></p>  <p><span style="font-family: 宋体;"  >基于字节流</span><span lang="EN-US"  > (</span><span style="font-family: 宋体;"  >对发送的数据排序</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >每个发送字节关联一个序列号</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >对方根据此序列号进行数据排序</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >确保数据的顺序</span><span lang="EN-US"  >).</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >三握手</span><span lang="EN-US"  >:</span></b></p>  <p><span style="font-family: 宋体;"  >客户</span><span lang="EN-US"  > ----SYN---&gt;<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体;"  >服务器</span></p>  <p><span style="font-family: 宋体;"  >客户</span> <span lang="EN-US"  >&lt;--SYN and ACK--- </span><span style="font-family: 宋体;"  >服务器</span></p>  <p><span style="font-family: 宋体;"  >客户</span><span lang="EN-US"  > ----SYN---&gt;<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体;"  >服务器</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >端口</span></b><span lang="EN-US"  >(0 ~ 65535, (unsigned long) 2</span><sup><span style=""  lang="EN-US"  >16</span></sup><span style=""  lang="EN-US"  >)</span></p>  <p><span lang="EN-US"  >0 ~ 1023 </span><span style="font-family: 宋体;"  >一般和某些服务绑定</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >所以一般我们不用这个范围的端口</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >1024 ~ 49151 </span><span style="font-family: 宋体;"  >提供一般应用程序使用</span><span lang="EN-US"  >.(Win Socket</span><span style="font-family: 宋体;"  >开发选中的范围</span><span lang="EN-US"  >)</span></p>  <p><span style="font-family: 宋体;"  >动态或私有端口</span><span lang="EN-US"  >: 49151 ~ 65535</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span lang="EN-US"  >IP</span></b><b style=""  ><span style="font-family: 宋体;"  >地址</span><span lang="EN-US"  ></span></b></p>  <pre><code><span style="font-size: 10pt;"  lang="EN-US"  >struct sockaddr_in {</span></code></pre><pre><code><span style="font-size: 10pt;"  lang="EN-US"  > &nbsp;&nbsp; short<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>sin_family;<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// must be AF_INET</span></code></pre><pre><code><span style="font-size: 10pt;"  lang="EN-US"  > &nbsp;&nbsp; unsigned short<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>sin_port;<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// </span></code><code><span style="font-size: 10pt;"  >端口号<span lang="EN-US"  ></span></span></code></pre><pre><code><span style="font-size: 10pt;"  lang="EN-US"  > &nbsp;&nbsp; struct&nbsp;&nbsp; in_addr<span style=""  >&nbsp;&nbsp; </span>sin_addr;<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// IP</span></code><code><span style="font-size: 10pt;"  >地址<span lang="EN-US"  ></span></span></code></pre><pre style=""  ><code><span style="font-size: 10pt;"  lang="EN-US"  > &nbsp;&nbsp; char<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>sin_zero[8];<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>// </span></code><code><span style="font-size: 10pt;"  >扩充<span lang="EN-US"  ></span></span></code></pre><pre><code><span style="font-size: 10pt;"  lang="EN-US"  >};</span></code></pre>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >字节顺序</span><span lang="EN-US"  ></span></b></p>  <p><span lang="EN-US"  >Intel</span><span style="font-family: 宋体;"  >的电脑一般都是将低地址对应实际数子的高位</span><span lang="EN-US"  >.</span><span style="font-family: 宋体;"  >如</span></p>  <p><span style="font-family: 宋体;"  >计算机用一个</span><span lang="EN-US"  >Short </span><span style="font-family: 宋体;"  >表示</span><span lang="EN-US"  >1</span><span style="font-family: 宋体;"  >的方式</span><span lang="EN-US"  >:</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  >0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,0x0F</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  ><span style=""  >&nbsp;</span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp; </span>1<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0<span style=""  >&nbsp;&nbsp;&nbsp; </span>0</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  >1</span><span style="font-size: 10pt; font-family: 宋体;"  >本来应该是</span><span style="font-size: 10pt;"  lang="EN-US"  >:</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  >00 01, </span><span style="font-size: 10pt; font-family: 宋体;"  >计算机将其以字节为单位反转高低位</span><span style="font-size: 10pt;"  lang="EN-US"  >, </span><span style="font-size: 10pt; font-family: 宋体;"  >为</span><span style="font-size: 10pt;"  lang="EN-US"  >: 01 00.</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-size: 10pt; font-family: 宋体;"  >再如</span><span style="font-size: 10pt;"  lang="EN-US"  >, </span><span style="font-size: 10pt; font-family: 宋体;"  >一个</span><span style="font-size: 10pt;"  lang="EN-US"  >u_long</span><span style="font-size: 10pt; font-family: 宋体;"  >类型</span><span style="font-size: 10pt;"  lang="EN-US"  >: 4432</span></p>  <p><span style="font-size: 10pt; font-family: 宋体;"  >内存表示为</span><span style="font-size: 10pt;"  lang="EN-US"  >: 50 11 00 00, </span><span style="font-size: 10pt; font-family: 宋体;"  >实际应该是</span><span style="font-size: 10pt;"  lang="EN-US"  >: 00 00 11 51</span></p>  <p><span style="font-size: 10pt; font-family: 宋体;"  >而网络流就是按照这种顺序传输的</span><span style="font-size: 10pt;"  lang="EN-US"  >, </span><span style="font-size: 10pt; font-family: 宋体;"  >所以要利用</span><span style="font-size: 10pt;"  lang="EN-US"  > htonl, htons, ntohl, ntohs</span><span style="font-size: 10pt; font-family: 宋体;"  >四个函数来转换字节流顺序</span><span style="font-size: 10pt;"  lang="EN-US"  >.</span></p>  <p><span style="font-size: 10pt;"  lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >关于关闭</span><span lang="EN-US"  ></span></b></p>  <p><span style="font-family: 宋体;"  >关闭连接有两个选择</span><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >从容关闭</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >硬关闭</span><span lang="EN-US"  >.</span></p>  <p><span style="font-family: 宋体;"  >两个混淆的关闭</span><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >关闭连接</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >关闭套接字</span><span lang="EN-US"  >.</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >从容关闭</span></b><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >一方关闭连接</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >另一方可以继续读取网络堆栈的数据</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >直到数据传送完毕</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >双方都关闭了连接</span><span lang="EN-US"  >,</span><span style="font-family: 宋体;"  >可以保证在关闭之前</span><span lang="EN-US"  >,</span><span style="font-family: 宋体;"  >数据都被接收</span><span lang="EN-US"  >.</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >硬关闭</span></b><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >只要一方关闭了连接</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >另一方就无法接收数据</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >数据无法传送完毕</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >关系</span><span lang="EN-US"  >:</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >关闭连接</span></b><span style="font-family: 宋体;"  >的方式包括</span><span lang="EN-US"  >: </span><b style=""  ><span style="font-family: 宋体;"  >从容关闭连接方式</span> </b><b style=""  ><span style="font-family: 宋体;"  >和</span> </b><b style=""  ><span style="font-family: 宋体;"  >硬关闭连接方式</span><span lang="EN-US"  ></span></b></p>  <p><b style=""  ><span style="font-family: 宋体;"  >关闭套接字</span></b><span style="font-family: 宋体;"  >其实就是相对于操作系统而已的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >释放资源</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >关闭句柄</span><span lang="EN-US"  >,</span><span style="font-family: 宋体;"  >相当于</span><span lang="EN-US"  >CloseHandle</span><span style="font-family: 宋体;"  >的意思</span><span lang="EN-US"  >.</span></p>  <p><span style="font-family: 宋体;"  >关闭连接函数</span><span lang="EN-US"  >: <b style=""  >shutdown</b> and <b style=""  >WSASendDisconnect</b></span><span style="font-family: 宋体;"  >函数</span></p>  <p><span style="font-family: 宋体;"  >关闭套接字函数</span><span lang="EN-US"  >: <b style=""  >closesocket</b>(</span><span style="font-family: 宋体;"  >同时隐含执行</span><span lang="EN-US"  >shutdown</span><span style="font-family: 宋体;"  >函数功能</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >从容关闭的思想</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >甲方我要关闭</span><span lang="EN-US"  > -&gt; </span><span style="font-family: 宋体;"  >通知给乙方</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >乙方得到消息后</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >哦知道了</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >此时甲方还能接收数据</span><span lang="EN-US"  >), </span><span style="font-family: 宋体;"  >乙方可以选择继续发送数据</span><span lang="EN-US"  >,</span><span style="font-family: 宋体;"  >也可以通知甲方</span><span lang="EN-US"  >,</span><span style="font-family: 宋体;"  >我也要关闭了</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >然后调用</span><span lang="EN-US"  >closesocket</span><span style="font-family: 宋体;"  >关闭套接字</span><span lang="EN-US"  > -&gt;&nbsp;</span><span style="font-family: 宋体;"  >甲</span><span style="font-family: 宋体;"  >方得到关闭消息</span><span lang="EN-US"  >,closesocket</span><span style="font-family: 宋体;"  >关闭套接字</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >甲</span><span lang="EN-US"  >:</span><span style="font-family: 宋体;"  >客户端</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >乙</span><span lang="EN-US"  >:</span><span style="font-family: 宋体;"  >服务器</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >甲</span><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >调用</span><span lang="EN-US"  >shutdown(SD_SEND), </span><span style="font-family: 宋体;"  >接着等待</span><span lang="EN-US"  >FD_READ</span><span style="font-family: 宋体;"  >和</span><span lang="EN-US"  >FD_CLOSE, </span><span style="font-family: 宋体;"  >等到</span><span lang="EN-US"  >FD_CLOSE</span><span style="font-family: 宋体;"  >关闭套接字</span><span lang="EN-US"  >)</span></p>  <p><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >乙</span><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >调用</span><span lang="EN-US"  > shutdown(SD_SEND), </span><span style="font-family: 宋体;"  >紧着调用</span><span lang="EN-US"  >closesocket)</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >基本的函数</span><span lang="EN-US"  >:</span></p>  <p><span lang="EN-US"  >WSAStartup<span style=""  >&nbsp;&nbsp; </span> socket<span style=""  >&nbsp;&nbsp;&nbsp; </span> bind<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>listen<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>accept<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>recv<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>send<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>closesocket</span></p>  <p><span lang="EN-US"  >shutdown<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span> connect<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>recvfrom<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>sendto<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp; </span>WSCleanup</span></p>  <p><span lang="EN-US"  >getsockopt<span style=""  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span> setsockopt</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >俩大模式</span></b><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >阻塞模式</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >非阻塞模式</span><span lang="EN-US"  >.</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >五大模型</span></b><span lang="EN-US"  >: Select</span><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  >, WSAAsyncSelect</span><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  >, WSAEventSelect</span><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >重叠</span><span lang="EN-US"  >I/O, </span><span style="font-family: 宋体;"  >完成端口</span><span lang="EN-US"  >.</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >阻塞模式</span><span lang="EN-US"  >, </span></b><b style=""  ><span style="font-family: 宋体;"  >在哪儿阻塞</span><span lang="EN-US"  >? </span></b></p>  <p><span style="font-family: 宋体;"  >有两个地方</span><span lang="EN-US"  >: </span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >1.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >等待数据的时候</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >当数据没有到达</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >就会被阻塞</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >等待数据的到达</span><span lang="EN-US"  >.</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >2.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >数据到达</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >从系统缓冲区复制到用户区</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >此过程也被阻塞</span><span lang="EN-US"  >. </span></p>  <p><span style="font-family: 宋体;"  >五个模型的阻塞方式各不相同</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >通常说的非阻塞</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >其实是在上面提到的阻塞的第一个地方不阻塞</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >真正实现两个地方都不阻塞的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >只有</span> <span style="font-family: 宋体;"  >重叠</span><span lang="EN-US"  >I/O, </span><span style="font-family: 宋体;"  >完成端口</span> <span style="font-family: 宋体;"  >俩个模型</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >阻塞模型</span><span lang="EN-US"  ></span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img319.ph.126.net_atvlRznzx0zbNiYjJGZ6PQ==_3827496733311841087.png"  ></div><div><br></div><p></p>  <p><span style="font-family: 宋体;"  >如果是单线程</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >一旦阻塞</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >程序就被操作系统换入等待队列</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >程序就处于等待状态</span><span lang="EN-US"  >,(</span><span style="font-family: 宋体;"  >如果是</span><span lang="EN-US"  >GUI</span><span style="font-family: 宋体;"  >界面</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >可以想象假死的状态多么难堪</span><span lang="EN-US"  >). </span><span style="font-family: 宋体;"  >所以可以用多线程来操作</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >例如主线程来运行</span><span lang="EN-US"  >GUI</span><span style="font-family: 宋体;"  >的消息循环</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >创建一个线程用来等待</span><span lang="EN-US"  >(recv</span><span style="font-family: 宋体;"  >之类的函数</span><span lang="EN-US"  >), </span><span style="font-family: 宋体;"  >创建一个线程来接处理数据</span><span lang="EN-US"  >.</span><span style="font-family: 宋体;"  >这样在其中一个线程等待的时间里</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >可以来响应用户消息和处理数据等</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >可以想象</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >如果大量用户接入</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >就要创建大量的线程</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >对系统造成的开销很大</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span>  <p><b style=""  ><span style="font-family: 宋体;"  >非阻塞模式</span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img762.ph.126.net_FJITFyTpPlmbjpxoNG8IrQ==_4939604366295359595.png"  ></div>&nbsp;<p></p>  <p><span style="font-family: 宋体;"  >可以看到</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >程序循环检测数据</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >浪费</span><span lang="EN-US"  >CPU, </span><span style="font-family: 宋体;"  >如果写个程序能看到</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >程序的占有率基本上总是</span><span lang="EN-US"  >100%, </span><span style="font-family: 宋体;"  >对系统的资源占用很大</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >而且比起阻塞模式而已</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >没有什么优点</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >非阻塞的作用主要体现在和</span><span lang="EN-US"  >5</span><span style="font-family: 宋体;"  >个模型共同协作</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >才能体现其优点</span><span lang="EN-US"  >.</span></p>  <span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span>  <p><span lang="EN-US"  >Select</span><span style="font-family: 宋体;"  >模型</span></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img.ph.126.net_GZdrMSR3huQbSIJlqBHQlA==_2368330454043837215.png"  ></div>&nbsp;<p></p>  <p><span style="font-family: 宋体;"  >可以同时等待多个套接字</span><span lang="EN-US"  >.</span></p>  <span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span>  <p><b style=""  ><span lang="EN-US"  >WSAAsyncSelect</span></b><b style=""  ><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  ></span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img.ph.126.net_jseS4mqCBZTAVwvurXLRpQ==_2368330454043837220.png"  ></div>&nbsp;<p></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span lang="EN-US"  >WSAAsyncSelect </span><span style="font-family: 宋体;"  >是</span><span lang="EN-US"  > select</span><span style="font-family: 宋体;"  >模型的<b style=""  >异步</b>版本</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >那么异步指的是谁和谁异步</span><span lang="EN-US"  >?</span></p>  <p><span style="font-family: 宋体;"  >这里的异步应该是指</span><span lang="EN-US"  >: </span><span style="font-family: 宋体;"  >目前执行</span><span lang="EN-US"  >WSAAsyncSelect</span><span style="font-family: 宋体;"  >的线程和等待数据的到达俩个流程是异步的</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >也就是说</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >谁也不等谁</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >线程调用完此函数继续下下执行</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >数据到达才发送消息给应用程序窗口</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >接着线程就要处理这批数据了</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >通过图看的出</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >从缓冲区复制到用户空间的数据仍然是阻塞的</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >这个过程类似于</span><span lang="EN-US"  >ReadFile, </span><span style="font-family: 宋体;"  >所以还没算真正意义的</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >执行流程和接收数据的</span><span lang="EN-US"  >)</span><span style="font-family: 宋体;"  >异步</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span lang="EN-US"  >WSAAsyncSelect </span><span style="font-family: 宋体;"  >与</span><span lang="EN-US"  > Select</span></p>  <p><span lang="EN-US"  >WSAAsyncSelect</span><span style="font-family: 宋体;"  >模型与</span><span lang="EN-US"  >Select</span><span style="font-family: 宋体;"  >模型相同</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >都可以有效的对多个套接字进行管理</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >WSAAsyncSelect</span><span style="font-family: 宋体;"  >是基于消息的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >所以必须创建窗口</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >可以创建一个隐藏的窗口</span><span lang="EN-US"  >), </span><span style="font-family: 宋体;"  >向</span><span lang="EN-US"  >Unix</span><span style="font-family: 宋体;"  >很多基于命令符界面的环境</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >都一般用</span><span lang="EN-US"  >Select</span><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >WSAAsyncSelect</span><span style="font-family: 宋体;"  >自动将套接字设置为非阻塞模式</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >而</span><span lang="EN-US"  >select</span><span style="font-family: 宋体;"  >并没有这个特性</span></p>  <p><b style=""  ><span lang="EN-US"  >&nbsp;</span></b></p>  <b style=""  ><span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span></b>  <p><b style=""  ><span lang="EN-US"  >WSAEventSelect</span></b><b style=""  ><span style="font-family: 宋体;"  >模型</span><span lang="EN-US"  ></span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img.ph.126.net_-EfwnmB3I6vSC7g1rUiQPw==_3740802440484995872.png"  ></div>&nbsp;<p></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span style="font-family: 宋体;"  >通过对比图</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >可以看出</span><span lang="EN-US"  >, <b style=""  >WSAEventSelect </b></span><b style=""  ><span style="font-family: 宋体;"  >和</span> <span lang="EN-US"  >WSAAsyncSelect</span></b><span style="font-family: 宋体;"  >的唯一区别就是<b style=""  >通知方式</b>不同</span><span lang="EN-US"  >, <b style=""  >WSAAsyncSelect </b></span><span style="font-family: 宋体;"  >是通过发送消息来通知应用程序的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >而</span><span lang="EN-US"  >WSAEventSelect</span><span style="font-family: 宋体;"  >则是事件形式通知</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >当然实现的形式也不相同</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >一个是通过操作系统发送消息给窗口过程来处理</span><span lang="EN-US"  >. </span><span style="font-family: 宋体;"  >一个是操作系统触发事件</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >在应用程序端则是等待事件发生</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >由于等待事件是阻塞的</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >所以要多开一个线程</span><span lang="EN-US"  >).</span></p>  <span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span>  <p><b style=""  ><span style="font-family: 宋体;"  >重叠</span><span lang="EN-US"  >I/O</span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img.ph.126.net_KMhJeGu-wnHeYktgES0gig==_3253287780823284163.png"  ></div>&nbsp;<p><b style=""  ><span lang="EN-US"  ></span></b></p>  <p><b style=""  ><span lang="EN-US"  >&nbsp;</span></b></p>  <p><b style=""  ><span style="font-family: 宋体;"  >对比</span><span lang="EN-US"  >:</span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img314.ph.126.net_BP--wd0_wknPCfFQygXdpQ==_3888295328281321356.png"  ></div>&nbsp;<p><b style=""  ><span lang="EN-US"  ></span></b></p>  <b style=""  ><span style="font-size: 10.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"  lang="EN-US"  ><br style="page-break-before: always;"  clear="all"  > </span></b>  <p><b style=""  ><span style="font-family: 宋体;"  >完成端口模型</span><span lang="EN-US"  ></span></b></p>  <p></p><div><img title="Socket编程心得 - Dsliu - Dspace"  alt="Socket编程心得 - Dsliu - Dspace"  style="margin: 0pt 10px 0pt 0pt;"  src="pic/img.ph.126.net_aApAdwNSn8pMKjQkRHQrNQ==_3706743968303016577.png"  ></div>&nbsp;<p></p>  <p><span style="font-family: 宋体;"  >完成端口解决了</span> <span lang="EN-US"  >“one-thread-per-client” </span><span style="font-family: 宋体;"  >问题</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><b style=""  ><span style="font-family: 宋体;"  >网络程序开发流程</span><span lang="EN-US"  >:</span></b></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >1.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >需求分析</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >2.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >根据需求</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >进行数据包设计</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >一般分为包头和包数据两部分</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >包头用来存储包的必要信息</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >如信息类型</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >数据长度等</span><span lang="EN-US"  >)</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >3.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >定义传输协议</span><span lang="EN-US"  >(</span><span style="font-family: 宋体;"  >如何传输</span><span lang="EN-US"  >).</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >4.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >理解需求</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >设计总体架构</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >利用设计模式等方法</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >进行问题分析和设计类图</span><span lang="EN-US"  >.</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >5.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >实现</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >通常要配合多线程来实现通信问题</span><span lang="EN-US"  >. (</span><span style="font-family: 宋体;"  >一般有等待客户请求线程</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >接收数据线程</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >发送数据线程</span><span lang="EN-US"  >, </span><span style="font-family: 宋体;"  >资源清理线程</span><span lang="EN-US"  >).</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >6.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >实现服务器端</span><span lang="EN-US"  >.</span></p>  <p style="margin-left: 18pt; text-indent: -18pt;"  ><span style=""  lang="EN-US"  ><span style=""  >7.<span style="font: 7pt &quot;Times New Roman&quot;;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体;"  >实现客户端</span><span lang="EN-US"  >.</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>  <p><span lang="EN-US"  >&nbsp;</span></p>
</body></html>