<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] auto_ptr</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] auto_ptr</h2>
<p align="right">发布时间：2012-8-28 14:28
<br>分类名称：STL</p><br>
<p>作者：<a target="_blank" rel="nofollow" href="http://www.cnblogs.com/GnagWang/"  >GangWang</a>   <br>出处：<a target="_blank" rel="nofollow" href="http://www.cnblogs.com/GnagWang/"  >http://www.cnblogs.com/GnagWang/</a>   <br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 </p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >C++的auto_ptr auto_ptr所做的事情，就是动态分配对象以及当对象不再需要时自动执行清理。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>1 构造函数与析构函数 </strong>auto_ptr在构造时获取对某个对象的所有权(ownership),在析构时释放该对象。我们可以这样使用auto_ptr来提高代码安全性：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >int* p = new int(0);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap(p);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >从此我们不必关心应该何时释放p， 也不用担心发生异常会有内存泄漏。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >这里我们有几点要注意：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >1) 因为auto_ptr析构的时候肯定会删除他所拥有的那个对象，所有我们就要注意了，一个萝卜一个坑，两个auto_ptr不能同时拥有同一个对象。像这样：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >int* p = new int(0);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap1(p);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap2(p);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >因为ap1与ap2都认为指针p是归它管的，在析构时都试图删除p, 两次删除同一个对象的行为在C++标准中是未定义的。所以我们必须防止这样使用auto_ptr.  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2) 考虑下面这种用法：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >int* pa = new int[10];  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap(pa);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >因为auto_ptr的析构函数中删除指针用的是delete,而不是delete [],所以我们不应该用auto_ptr来管理一个数组指针。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3) 构造函数的explicit关键词有效阻止从一个"裸"指针隐式转换成auto_ptr类型。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >4) 因为C++保证删除一个空指针是安全的， 所以我们没有必要把析构函数写成：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >~auto_ptr() throw()  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >{  </span></p><p><span style="font-family:宋体; font-size:12pt;"  > delete ap;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >}  </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>2 拷贝构造与赋值</strong>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >与引用计数型智能指针不同的，auto_ptr要求其对"裸"指针的完全占有性。也就是说一个"裸"指针不能同时被两个以上的auto_ptr所拥有。那 么，在拷贝构造或赋值操作时，我们必须作特殊的处理来保证这个特性。auto_ptr的做法是"所有权转移"，即拷贝或赋值的源对象将失去对"裸"指针的 所有权，所以，与一般拷贝构造函数，赋值函数不同， auto_ptr的拷贝构造函数，赋值函数的参数为引用而不是常引用(const reference).当然，一个auto_ptr也不能同时拥有两个以上的"裸"指针，所以，拷贝或赋值的目标对象将先释放其原来所拥有的对象。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >这里的注意点是：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >1) 因为一个auto_ptr被拷贝或被赋值后， 其已经失去对原对象的所有权，这个时候，对这个auto_ptr的提领(dereference)操作是不安全的。如下:  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >int* p = new int(0);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap1(p);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap2 = ap1;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >cout&lt;&lt;*ap1; //错误，此时ap1只剩一个null指针在手了  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >这种情况较为隐蔽的情形出现在将auto_ptr作为函数参数按值传递，因为在函数调用过程中在函数的作用域中会产生一个局部对象来接收传入的 auto_ptr(拷贝构造)，这样，传入的实参auto_ptr就失去了其对原对象的所有权，而该对象会在函数退出时被局部auto_ptr删除。如 下：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >void f(auto_ptr&lt;int&gt; ap){cout&lt;&lt;*ap;}  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap1(new int(0));  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >f(ap1);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >cout&lt;&lt;*ap1; //错误，经过f(ap1)函数调用，ap1已经不再拥有任何对象了。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >因为这种情况太隐蔽，太容易出错了， 所以auto_ptr作为函数参数按值传递是一定要避免的。或许大家会想到用auto_ptr的指针或引用作为函数参数或许可以，但是仔细想想，我们并不 知道在函数中对传入的auto_ptr做了什么， 如果当中某些操作使其失去了对对象的所有权， 那么这还是可能会导致致命的执行期错误。 也许，用const reference的形式来传递auto_ptr会是一个不错的选择。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2)我们可以看到拷贝构造函数与赋值函数都提供了一个成员模板在不覆盖"正统"版本的情况下实现auto_ptr的隐式转换。如我们有以下两个类  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >class base{};  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >class derived: public base{};  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >那么下列代码就可以通过，实现从auto_ptr&lt;derived&gt;到auto_ptr&lt;base&gt;的隐式转换，因为derived*可以转换成base*类型  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;base&gt; apbase = auto_ptr&lt;derived&gt;(new derived);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3) 因为auto_ptr不具有值语义(value semantic), 所以auto_ptr不能被用在stl标准容器中。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >所谓值语义，是指符合以下条件的类型(假设有类A)：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >A a1;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >A a2(a1);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >A a3;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >a3 = a1;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >那么  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >a2 == a1, a3 == a1  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >很明显，auto_ptr不符合上述条件，而我们知道stl标准容器要用到大量的拷贝赋值操作，并且假设其操作的类型必须符合以上条件。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>3 提领操作(dereference)</strong>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >提领操作有两个操作， 一个是返回其所拥有的对象的引用， 另一个是则实现了通过auto_ptr调用其所拥有的对象的成员。如：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >struct A  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >{  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >void f();  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >}  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;A&gt; apa(new A);  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >(*apa).f();  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >apa-&gt;f();  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >当然， 我们首先要确保这个智能指针确实拥有某个对象，否则，这个操作的行为即对空指针的提领是未定义的。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>4 辅助函数</strong>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >1) get用来显式的返回auto_ptr所拥有的对象指针。我们可以发现，标准库提供的auto_ptr既不提供从"裸"指针到auto_ptr的隐式转换 (构造函数为explicit),也不提供从auto_ptr到"裸"指针的隐式转换，从使用上来讲可能不那么的灵活， 考虑到其所带来的安全性还是值得的。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2) release,用来转移所有权  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3) reset，用来接收所有权，如果接收所有权的auto_ptr如果已经拥有某对象， 必须先释放该对象。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>5 特殊转换</strong>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >这里提供一个辅助类auto_ptr_ref来做特殊的转换，按照标准的解释， 这个类及下面 4个函数的作用是：使我们得以拷贝和赋值non-const auto_ptrs， 却不能拷贝和赋值const auto_ptrs. 我无法非常准确的理解这两句话的意义，但根据我们观察与试验，应该可以这样去理解：没有这些代码，我们本来就可以拷贝和赋值non-const的 auto_ptr和禁止拷贝和赋值const的auto_ptr的功能， 只是无法拷贝和赋值临时的auto_ptr(右值)， 而这些辅助代码提供某些转换，使我们可以拷贝和赋值临时的auto_ptr，但并没有使const的auto_ptr也能被拷贝和赋值。如下：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt; ap1 = auto_ptr&lt;int&gt;(new int(0));  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >auto_ptr&lt;int&gt;(new int(0))是一个临时对象，一个右值，一般的拷贝构造函数当然能拷贝右值，因为其参数类别必须为一个const reference, 但是我们知道，auto_ptr的拷贝函数其参数类型为reference，所以，为了使这行代码能通过，我们引入 auto_ptr_ref来实现从右值向左值的转换。其过程为：  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >1) ap1要通过拷贝 auto_ptr&lt;int&gt;(new int(0))来构造自己  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >2) auto_ptr&lt;int&gt;(new int(0))作为右值与现有的两个拷贝构造函数参数类型都无法匹配，也无法转换成该种参数类型  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >3) 发现辅助的拷贝构造函数auto_ptr(auto_ptr_ref&lt;T&gt; rhs) throw()  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >4) 试图将auto_ptr&lt;int&gt;(new int(0))转换成auto_ptr_ref&lt;T&gt;  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >5) 发现类型转换函数operator auto_ptr_ref&lt;Y&gt;() throw()， 转换成功，从而拷贝成功。  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >从而通过一个间接类成功的实现了拷贝构造右值（临时对象）  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >同时，这个辅助方法不会使const auto_ptr被拷贝， 原因是在第5步， 此类型转换函数为non-const的，我们知道，const对象是无法调用non-const成员的， 所以转换失败。当然， 这里有一个问题要注意， 假设你把这些辅助转换的代码注释掉，该行代码还是可能成功编译，这是为什么呢？debug一下， 我们可以发现只调用了一次构造函数，而拷贝构造函数并没有被调用，原因在于编译器将代码优化掉了。这种类型优化叫做returned value optimization，它可以有效防止一些无意义的临时对象的构造。当然，前提是你的编译器要支持returned value optimization。</span></p>
</body></html>