<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：ATL Under the Hood 4</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>ATL Under the Hood 4</h2>
<p align="right">发布时间：2011-11-29 11:03
<br>分类名称：ATL</p><br>
<p><img title="ATL Under the Hood 4 - Dsliu - Dspace"  src="http://img.ph.126.net/bwD2Wd3wO1IItum7q0GzGA==/-1.jpg"  alt=""  ><span style="font-family:Verdana;"  ><span style="color:#ff9900; font-size:13pt;"  ><strong>Introduction<br></strong></span><span style="font-size:10pt;"  >Till now we haven't discuss anything about assembly language. But we can't avoid it so long if we really want to know what is going on under the hood of ATL. Because ATL use some low level technique as well as some inline assembly language to make it as small and as fast as possible. I assume that reader already have basic knowledge of assembly language so I will only concentrate on my topic and not try to write another tutorial of assembly language. If you don't know enough assembly language then I recommends taking a look at Matt Pietrek's Article "Under The Hood" in Feb 1998 issue of Microsoft System Journal, it gives you enough information about the assembly language. <br>To start out tour take a look at this simple program <br><strong>Program 55</strong>     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now compile it on command line with command line compiler cl.exe. Compile it with -FAs switch. E.g. if this program name is prog55 then compile it this way <br></span><span style="font-family:Courier New; font-size:9pt;"  >Cl -FAs prog55.cpp<br></span><span style="font-family:Verdana; font-size:10pt;"  >This will generate a file with the same name but .asm extension contains the assembly language code of the following program. Now take a look at generated output file. Lets discuss the calling of function first. The assembly code to call this function is something like this. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;?fun@@YAXHH@Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; fun<br></em></span></span><span style="font-family:Verdana; font-size:10pt;"  >The parameters of function are pushed on the stack from right to left order and then call function. But the name of function is little bit different then our given function name. This is because C++ compiler decorates the name of function to perform function overloading. Let's change a program little bit and overload the function to take a look at the behavior of the code. <br><strong>Program 56</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>, <span style="color:navy;"  >15</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now the assembly languages of calling both of the functions are something like this <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;?fun@@YAXHH@Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; fun<br></em></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >15</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000fH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;?fun@@YAXHHH@Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; fun<br></em></span></span><span style="font-family:Verdana; font-size:10pt;"  >Take a look at the name of the function, we write both function with the same name but compiler decorates these functions itself to do function overloading. <br>If you don't want to decorate the function name then you can use extern "C" with function. Let's see little bit change in the program. <br><strong>Program 57</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The assembly language code of this function is <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;_fun<br></span><span style="font-family:Verdana; font-size:10pt;"  >This means that now you can't overload the function with C linkage. Take a look at the following program <br><strong>Program 58</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program give compilation error because function overloading is not supported in C language and you are going to make the two function with the same name and tells the compiler to not decorate its name i.e. use C language linkage not C++ linkage. <br>Now take a look what code compiler is generated for our do noting function. Here is the code which compiler generate for our function. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >pop</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >ret</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >0</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Before go into further detail take a look at the last statement of the function i.e. ret 0. Why it is 0? Or can it be other than 0? As we have seen all the parameters which we pass to the function are in fact pushed into the stack. What will be the effect on register when you or compiler pushes something on stack? Take a look at the following simple program to see the behavior of this. I use the </span><span style="color:#990000; font-family:Courier New;"  >printf</span><span style="font-family:Verdana; font-size:10pt;"  > rather than </span><span style="color:#990000; font-family:Courier New;"  >cout</span><span style="font-family:Verdana; font-size:10pt;"  > to avoid the overhead of </span><span style="color:#990000; font-family:Courier New;"  >cout</span><span style="font-family:Verdana; font-size:10pt;"  >. <br><strong>Program 59</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >cstdio<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>int</span> g_iTemp;</span><br></span><br><span style="color:blue;"  >int</span> main() {</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov g_iTemp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"Before push %d\n"</span>, g_iTemp);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;_asm push eax<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov g_iTemp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"After push %d\n"</span>, g_iTemp);<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm pop eax<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Before push 1244980<br>After push 1244976<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program displays the value of ESP register before and after push some value into the stack. This clearly shows that when you push something into the stack then it grows downward in the memory. <br><img title="ATL Under the Hood 4 - Dsliu - Dspace"  src="pic/img9.ph.126.net_0_F9HN5arSb3tNDTHyyJkw==_2758173296804832759.jpg"  alt=""  ><br>Now there is a question, who is goring to restore the stack pointer when we pass parameter into the function, the function itself or the caller of that function? In fact both cases are possible and this is the difference between standard calling convention and c calling convention. Take a look at the very next statement after calling the function. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;_fun<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >add</span>&nbsp;&nbsp;&nbsp;&nbsp;esp, <span style="color:navy;"  >8</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Here two parameters are passed in the function, so the stack pointer is subtract 8 bytes after pushing two values into the stack. Now in this program it is the responsibility of the caller of the function to set the stack pointer. This is called C Calling convention. In this calling convention you can pass variable no of argument, because caller knows how many parameter is being passed to the function, so it can set the stack pointer itself. <br>However if standard calling convention is selected then it is the responsibility of the callee to clear the stack. So in this case variable not of argument can't be passed in the function, because there is no way to know the function that how much parameter is passed, so it cal set the stack pointer appropriately. <br>Take a look at the following program to see the behavior of standard calling convention. <br><strong>Program 60</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> _stdcall fun(<span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span>) {<br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now take a look at the calling of function. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000aH<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >call</span>&nbsp;&nbsp;&nbsp;&nbsp;_fun@8<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here @ with the function name shows that this is standard calling convention and 8 show the no of bytes pushed into the stack. So no of argument can be calculated by dividing this no by 4. <br>Here is the code of our do nothing function <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >pop</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >ret</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >8</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >This function set the stack pointer itself with the help of "ret 8" instruction before leaving it. <br>Now explore the code which compiler generate for us. Compiler inserts this code to make stack frame so it can access the parameter and local variable in standard way. Stack frame is a memory area reserved for the function to store the information about the parameter, local variable and return address. Stack frame is always created when new function is called and destroys when function returns. On 8086 architecture </span><span style="color:#990000; font-family:Courier New;"  >EBP</span><span style="font-family:Verdana; font-size:10pt;"  > register is used to store the address of stack frame, sometimes called stack pointer. <br>So compiler first save the address of previous stack frame and then create new stack frame by using the value of </span><span style="color:#990000; font-family:Courier New;"  >ESP</span><span style="font-family:Verdana; font-size:10pt;"  >. And before return the function the value of old stack frame is preserved. <br>Now take a look what is in the stack frame. Stack frame have all the parameter at +ve side of </span><span style="color:#990000; font-family:Courier New;"  >EBP</span><span style="font-family:Verdana; font-size:10pt;"  > and all the local variable at -ve side of </span><span style="color:#990000; font-family:Courier New;"  >EBP</span><span style="font-family:Verdana; font-size:10pt;"  >. <br>So the return address of function is store at </span><span style="color:#990000; font-family:Courier New;"  >EBP</span><span style="font-family:Verdana; font-size:10pt;"  > and the value of previous Stack frame is store at </span><span style="color:#990000;"  ><span style="font-family:Courier New;"  >EBP + <span style="color:navy;"  >4<span style="color:#990000;"  >.</span></span></span><span style="font-family:Verdana; font-size:10pt;"  > Now take a look at the example, which have two parameter and three local variables. </span></span><span style="font-family:Verdana; font-size:10pt;"  ><br><strong>Program 61</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> fun(<span style="color:blue;"  >int</span> a, <span style="color:blue;"  >int</span> b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> x = a;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> y = b;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> z = x + y;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >And now take a look at the compiler generated code of the function. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >sub</span>&nbsp;&nbsp;&nbsp;&nbsp;esp, <span style="color:navy;"  >12</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000cH<br></em></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int x = a;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;eax, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _a$[ebp]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _x$[ebp], <span style="color:blue;"  >eax</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int y = b;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ecx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _b$[ebp]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _y$[ebp], <span style="color:blue;"  >ecx</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int z = x + y;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;edx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _x$[ebp]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >add</span>&nbsp;&nbsp;&nbsp;&nbsp;edx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _y$[ebp]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> _z$[ebp], edx<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;esp, ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >pop</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >ret</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >0</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Now what is _x, _y etc. It is define just above the function definition something like this <br></span><span style="font-family:Courier New; font-size:9pt;"  >_a$ = 8<br>_b$ = 12<br>_x$ = -4<br>_y$ = -8<br>_z$ = -12<br></span><span style="font-family:Verdana; font-size:10pt;"  >Means you can read this code something like this <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int x = a;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;eax, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp + <span style="color:navy;"  >8</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp - <span style="color:navy;"  >4</span>], <span style="color:blue;"  >eax</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int y = b;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ecx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp + <span style="color:navy;"  >12</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp - <span style="color:navy;"  >8</span>], <span style="color:blue;"  >ecx</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; int z = x + y;<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;edx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp - <span style="color:navy;"  >4</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >add</span>&nbsp;&nbsp;&nbsp;&nbsp;edx, <span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp - <span style="color:navy;"  >8</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >DWORD</span>    <span style="color:blue;"  >PTR</span> [ebp - <span style="color:navy;"  >12</span>], edx<br></span><span style="font-family:Verdana; font-size:10pt;"  >Means the address of parameters a and b are </span><span style="color:#990000;"  ><span style="font-family:Courier New;"  >EBP + <span style="color:navy;"  >8</span></span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="font-family:Courier New;"  >EBP + <span style="color:navy;"  >12<span style="color:#990000;"  >      </span></span></span><span style="font-family:Verdana; font-size:10pt;"  >respectively. And the value of x, y and z are store at memory location </span><span style="font-family:Courier New;"  >EBP - <span style="color:navy;"  >4</span></span><span style="font-family:Verdana; font-size:10pt;"  >, </span><span style="font-family:Courier New;"  >EBP - <span style="color:navy;"  >8</span></span><span style="font-family:Verdana; font-size:10pt;"  >, </span><span style="font-family:Courier New;"  >EBP - <span style="color:navy;"  >12<span style="color:#990000;"  >      </span></span></span><span style="font-family:Verdana; font-size:10pt;"  >respectively. </span></span><span style="font-family:Verdana; font-size:10pt;"  ><br>After armed with this knowledge lets play a game with the parameter of the functions. Let's take a look at this simple program. <br><strong>Program 62</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >cstdio<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>extern</span>       <span style="color:purple;"  >"C"</span>       <span style="color:blue;"  >int</span> fun(<span style="color:blue;"  >int</span> a, <span style="color:blue;"  >int</span> b) {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a + b;</span><br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"%d\n"</span>, fun(<span style="color:navy;"  >4</span>, <span style="color:navy;"  >5</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is expected. Out put of this program is "9". Now change a program little bit. <br><strong>Program 63</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >cstdio<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>extern</span>       <span style="color:purple;"  >"C"</span>       <span style="color:blue;"  >int</span> fun(<span style="color:blue;"  >int</span> a, <span style="color:blue;"  >int</span> b) {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov dword ptr[ebp+12], 15</span><br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov dword ptr[ebp+8], <span style="color:navy;"  >14</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a + b;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"%d\n"</span>, fun(<span style="color:navy;"  >4</span>, <span style="color:navy;"  >5</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is "29". We know the address of parameter and in this program we change the value of parameter. And when we add those variables then new values i.e. 15 and 14 are added. <br>VC has naked attributed for function. If you specify any function to naked then it won't generate prolog and epilog code for that function. Now what is prolog and epilog code? Prolog is an English word mean "Opening", yes it is a name of programming language too, which is used in AI, but there is no relation between that programming language and prolog code generated by the compiler. This is a code which compiler automatically inserted in the opening of the function calling to set the stack frame. Take a look at assembly language code generated by program 61. In the beginning of the function compiler automatically insert the following code to set the stack frame. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >push</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp, esp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >sub</span>&nbsp;&nbsp;&nbsp;&nbsp;esp, <span style="color:navy;"  >12</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>; 0000000cH<br></em></span></span><span style="font-family:Verdana; font-size:10pt;"  >This code is called prolog code. And in the same way the code inserted at the end of function is called Epilog code. In the same program the Epilog code generated by the compiler is <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >mov</span>&nbsp;&nbsp;&nbsp;&nbsp;esp, ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >pop</span>&nbsp;&nbsp;&nbsp;&nbsp;ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >ret</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;"  >0</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Now take a look at the function with naked attribute <br><strong>Program 64</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >extern</span>    <span style="color:purple;"  >"C"</span>    <span style="color:blue;"  >void</span> _declspec(<span style="color:blue;"  >naked</span>) fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm ret<br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The code of the function fun, which is generated by the compiler, is something like this. <br></span><span style="font-family:Courier New; font-size:9pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;_asm <span style="color:blue;"  >ret</span><br></span><span style="font-family:Verdana; font-size:10pt;"  >Means there is no prolog and epilog code in this function. In fact, there are rules of naked function, i.e. you can't declare automatic variable in naked function, because for this compiler have to generate the code for you and in naked function compiler wont generate any code for you. In fact you have to write the ret statement yourself otherwise program will be crash. You even can't write return statement in the naked function. Why? Because when you return something from the function, then compiler puts its value in </span><span style="color:#990000; font-family:Courier New;"  >eax</span><span style="font-family:Verdana; font-size:10pt;"  > register. So it means compiler have to generate the code for your return statement. Let's take a look at this simple program to understand the working of return value from the function. <br><strong>Program 64</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >cstdio<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>extern</span>       <span style="color:purple;"  >"C"</span>       <span style="color:blue;"  >int</span> sum(<span style="color:blue;"  >int</span> a, <span style="color:blue;"  >int</span> b) {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a + b;</span><br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> iRetVal;<br>&nbsp;&nbsp;&nbsp;&nbsp;sum(<span style="color:navy;"  >3</span>, <span style="color:navy;"  >7</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov iRetVal, eax<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"%d\n"</span>, iRetVal);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is "10". Here we haven't directly use the return value of the function, instead of this we copy the value of </span><span style="color:#990000; font-family:Courier New;"  >eax</span><span style="font-family:Verdana; font-size:10pt;"  > in the variable just after calling the function. <br>Now write our whole function naked with prolog and epilog code which return the value of two variables after return it. <br><strong>Program 65</strong>    <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >cstdio<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>extern</span>       <span style="color:purple;"  >"C"</span>       <span style="color:blue;"  >int</span> _declspec(<span style="color:blue;"  >naked</span>) sum(<span style="color:blue;"  >int</span> a, <span style="color:blue;"  >int</span> b) {</span><br></span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// prolog code<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;_asm push ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov ebp, esp<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// code for add two variables and return<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov eax, dword ptr [ebp + <span style="color:navy;"  >8</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm add eax, dword ptr [ebp + <span style="color:navy;"  >12</span>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;"  ><em>// epilog code<br></em></span>&nbsp;&nbsp;&nbsp;&nbsp;_asm pop ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm ret<br>}<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> iRetVal;<br>&nbsp;&nbsp;&nbsp;&nbsp;sum(<span style="color:navy;"  >3</span>, <span style="color:navy;"  >7</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;_asm mov iRetVal, eax<br>&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style="color:purple;"  >"%d\n"</span>, iRetVal);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is "10" i.e. the sum of two parameter 3 and 7. <br>This attributed is used in ATLBASE.H file to implement the member of </span><span style="color:#990000; font-family:Courier New;"  >_QIThunk</span><span style="font-family:Verdana; font-size:10pt;"  > structure. This is structure is used to debug reference counting the ATL program when </span><span style="color:#990000; font-family:Courier New;"  >_ATL_DEBUG_INTERFACES</span><span style="font-family:Verdana; font-size:10pt;"  > are defined. <br>I hope to explore some other mysterious of ATL in next article. <br></span><span style="font-family:宋体; font-size:8pt;"  >窗体底端</span></p>
</body></html>