<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] RAII惯用法：C++资源管理的利器</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] RAII惯用法：C++资源管理的利器</h2>
<p align="right">发布时间：2011-5-31 15:22
<br>分类名称：C++</p><br>
<p><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">是指</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">语言中的一个惯用法（</span><span style="font-family:Verdana;">idiom</span><span style="font-family:宋体;">），它是</span><span style="font-family:Verdana;">"<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization"</span><span style="font-family:宋体;">的首字母缩写。中文可将其翻译为</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">资源获取就是初始化</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">。虽然从某种程度上说这个名称并没有体现出该惯性法的本质精神，但是作为标准</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">资源管理的关键技术，</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">早已在</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">社群中深入人心。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">我记得第一次学到</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">惯用法是在</span><span style="font-family:Verdana;">Bjarne Stroustrup</span><span style="font-family:宋体;">的《</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">程序设计语言（第</span><span style="font-family:Verdana;">3</span><span style="font-family:宋体;">版）》一书中。当讲述</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">资源管理时，</span><span style="font-family:Verdana;">Bjarne</span><span style="font-family:宋体;">这样写道：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">使用局部对象管理资源的技术通常称为</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">资源获取就是初始化</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">。这种通用技术依赖于构造函数和析构函数的性质以及它们与异常处理的交互作用。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">Bjarne</span><span style="font-family:宋体;">这段话是什么意思呢？</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">首先让我们来明确资源的概念，在计算机系统中，资源是数量有限且对系统正常运转具有一定作用的元素。比如，内存，文件句柄，网络套接字（</span><span style="font-family:Verdana;">network sockets</span><span style="font-family:宋体;">），互斥锁（</span><span style="font-family:Verdana;">mutex locks</span><span style="font-family:宋体;">）等等，它们都属于系统资源。由于资源的数量不是无限的，有的资源甚至在整个系统中仅有一份，因此我们在使用资源时必须严格遵循的步骤是：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">1. </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">2. </span><span style="font-family:宋体;">使用资源</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">3. </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">例如在下面的</span><span style="font-family:Verdana;">UseFile</span><span style="font-family:宋体;">函数中：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseFile(char const* fn)<br>{<br>FILE* f = fopen(fn, "r"); // </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;"><br>// </span><span style="font-family:宋体;">在此处使用文件句柄</span><span style="font-family:Courier;">f... // </span><span style="font-family:宋体;">使用资源</span><span style="font-family:Courier;"><br>fclose(f); // </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;"><br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">调用</span><span style="font-family:Verdana;">fopen()</span><span style="font-family:宋体;">打开文件就是获取文件句柄资源，操作完成之后，调用</span><span style="font-family:Verdana;">fclose()</span><span style="font-family:宋体;">关闭文件就是释放该资源。资源的释放工作至关重要，如果只获取而不释放，那么资源最终会被耗尽。上面的代码是否能够保证在任何情况下都调用</span><span style="font-family:Verdana;">fclose</span><span style="font-family:宋体;">函数呢？请考虑如下情况：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseFile(char const* fn)<br>{<br>FILE* f = fopen(fn, "r"); // </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;"><br>// </span><span style="font-family:宋体;">使用资源</span><span style="font-family:Courier;"><br>if (!g()) return; // </span><span style="font-family:宋体;">如果操作</span><span style="font-family:Courier;">g</span><span style="font-family:宋体;">失败！</span><span style="font-family:Courier;"><br>// ...<br>if (!h()) return; // </span><span style="font-family:宋体;">如果操作</span><span style="font-family:Courier;">h</span><span style="font-family:宋体;">失败！</span><span style="font-family:Courier;"><br>// ...<br>fclose(f); // </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;"><br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">在使用文件</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">的过程中，因某些操作失败而造成函数提前返回的现象经常出现。这时函数</span><span style="font-family:Verdana;">UseFile</span><span style="font-family:宋体;">的执行流程将变为：</span><span style="font-family: Verdana;"><br></span></p><div><img title="RAII惯用法：C++资源管理的利器 - Dsliu - Dspace" alt="RAII惯用法：C++资源管理的利器 - Dsliu - Dspace" style="margin:0 10px 0 0;" src="pic/img157.ph.126.net_o3uBQuLaKUZhSzoC6-DCBg==_2246733264106199055.png"></div>&nbsp;<p><br></p><p><span style="font-family:宋体;">很明显，这里忘记了一个重要的步骤：在操作</span><span style="font-family:Verdana;">g</span><span style="font-family:宋体;">或</span><span style="font-family:Verdana;">h</span><span style="font-family:宋体;">失败之后，</span><span style="font-family:Verdana;">UseFile</span><span style="font-family:宋体;">函数必须首先调用</span><span style="font-family:Verdana;">fclose()</span><span style="font-family:宋体;">关闭文件，然后才能返回其调用者，否则会造成资源泄漏。因此，需要将</span><span style="font-family:Verdana;">UseFile</span><span style="font-family:宋体;">函数修改为：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseFile(char const* fn)<br>{<br>FILE* f = fopen(fn, "r"); // </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;"><br>// </span><span style="font-family:宋体;">使用资源</span><span style="font-family:Courier;"><br>if (!g()) { <strong>fclose(f);</strong> return; }<br>// ...<br>if (!h()) { <strong>fclose(f);</strong> return; }<br>// ...<br>fclose(f); // </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;"><br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">现在的问题是：用于释放资源的代码</span><span style="font-family:Verdana;">fclose(f)</span><span style="font-family:宋体;">需要在不同的位置重复书写多次。如果再加入异常处理，情况会变得更加复杂。例如，在文件</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">的使用过程中，程序可能会抛出异常：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseFile(char const* fn)<br>{<br>FILE* f = fopen(fn, "r"); // </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;"><br>// </span><span style="font-family:宋体;">使用资源</span><span style="font-family:Courier;"><br><strong>try</strong> {<br>if (!g()) { fclose(f); return; }<br>// ...<br>if (!h()) { fclose(f); return; }<br>// ...<br>}<br><strong>catch</strong> (...) {<br><strong>fclose(f); </strong>// </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;"><strong><br></strong>throw;<br>}<br>fclose(f); // </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;"><br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">我们必须依靠</span><span style="font-family:Verdana;">catch(...)</span><span style="font-family:宋体;">来捕获所有的异常，关闭文件</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">，并重新抛出该异常。随着控制流程复杂度的增加，需要添加资源释放代码的位置会越来越多。如果资源的数量还不止一个，那么程序员就更加难于招架了。可以想象这种做法的后果是：代码臃肿，效率下降，更重要的是，程序的可理解性和可维护性明显降低。是否存在一种方法可以实现资源管理的自动化呢？答案是肯定的。假设</span><span style="font-family:Verdana;">UseResources</span><span style="font-family:宋体;">函数要用到</span><span style="font-family:Verdana;">n</span><span style="font-family:宋体;">个资源，则进行资源管理的一般模式为：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseResources()<br>{<br>// </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;">1<br>// ...<br>// </span><span style="font-family:宋体;">获取资源</span><span style="font-family:Courier;">n<br><br>// </span><span style="font-family:宋体;">使用这些资源</span><span style="font-family:Courier;"><br><br>// </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;">n<br>// ...<br>// </span><span style="font-family:宋体;">释放资源</span><span style="font-family:Courier;">1<br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">不难看出资源管理技术的关键在于：要保证资源的释放顺序与获取顺序严格相反。这自然使我们联想到局部对象的创建和销毁过程。在</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">中，定义在栈空间上的局部对象称为自动存储（</span><span style="font-family:Verdana;">automatic memory</span><span style="font-family:宋体;">）对象。管理局部对象的任务非常简单，因为它们的创建和销毁工作是由系统自动完成的。我们只需在某个作用域（</span><span style="font-family:Verdana;">scope</span><span style="font-family:宋体;">）中定义局部对象（这时系统自动调用构造函数以创建对象），然后就可以放心大胆地使用之，而不必担心有关善后工作；当控制流程超出这个作用域的范围时，系统会自动调用析构函数，从而销毁该对象。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">读者可能会说：如果系统中的资源也具有如同局部对象一样的特性，自动获取，自动释放，那该有多么美妙啊！。事实上，您的想法已经与</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">不谋而合了。既然类是</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">中的主要抽象工具，那么就将资源抽象为类，用局部对象来表示资源，把管理资源的任务转化为管理局部对象的任务。这就是</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">惯用法的真谛！可以毫不夸张地说，</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">有效地实现了</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">资源管理的自动化。例如，我们可以将文件句柄</span><span style="font-family:Verdana;">FILE</span><span style="font-family:宋体;">抽象为</span><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">类：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">class FileHandle {<br>public:<br>FileHandle(char const* n, char const* a) { p = fopen(n, a); }<br>~FileHandle() { fclose(p); }<br>private:<br>// </span><span style="font-family:宋体;">禁止拷贝操作</span><span style="font-family:Courier;"><br>FileHandle(FileHandle const&amp;);<br>FileHandle&amp; operator= (FileHandle const&amp;);<br>FILE *p;<br>};</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">类的构造函数调用</span><span style="font-family:Verdana;">fopen()</span><span style="font-family:宋体;">获取资源；</span><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">类的析构函数调用</span><span style="font-family:Verdana;">fclose()</span><span style="font-family:宋体;">释放资源。请注意，考虑到</span><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">对象代表一种资源，它并不具有拷贝语义，因此我们将拷贝构造函数和赋值运算符声明为私有成员。如果利用</span><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">类的局部对象表示文件句柄资源，那么前面的</span><span style="font-family:Verdana;">UseFile</span><span style="font-family:宋体;">函数便可简化为：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void UseFile(char const* fn)<br>{<br>FileHandle file(fn, "r"); <br>// </span><span style="font-family:宋体;">在此处使用文件句柄</span><span style="font-family:Courier;">f...<br>// </span><span style="font-family:宋体;">超出此作用域时，系统会自动调用</span><span style="font-family:Courier;">file</span><span style="font-family:宋体;">的析构函数，从而释放资源</span><span style="font-family:Courier;"><br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">现在我们就不必担心隐藏在代码之中的</span><span style="font-family:Verdana;">return</span><span style="font-family:宋体;">语句了；不管函数是正常结束，还是提前返回，系统都必须</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">乖乖地</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">调用</span><span style="font-family:Verdana;">f</span><span style="font-family:宋体;">的析构函数，资源一定能被释放。</span><span style="font-family:Verdana;">Bjarne</span><span style="font-family:宋体;">所谓</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">使用局部对象管理资源的技术</span><span style="font-family:Verdana;">……</span><span style="font-family:宋体;">依赖于构造函数和析构函数的性质</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">，说的正是这种情形。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">且慢！如若使用文件</span><span style="font-family:Verdana;">file</span><span style="font-family:宋体;">的代码中有异常抛出，难道析构函数还会被调用吗？此时</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">还能如此奏效吗？问得好。事实上，当一个异常抛出之后，系统沿着函数调用栈，向上寻找</span><span style="font-family:Verdana;">catch</span><span style="font-family:宋体;">子句的过程，称为栈辗转开解（</span><span style="font-family:Verdana;">stack unwinding</span><span style="font-family:宋体;">）。</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">标准规定，在辗转开解函数调用栈的过程中，系统必须确保调用所有已创建起来的局部对象的析构函数。例如：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">void Foo()<br>{<br>FileHandle file1("n1.txt", "r"); <br>FileHandle file2("n2.txt", "w");<br>Bar(); // </span><span style="font-family:宋体;">可能抛出异常</span><span style="font-family:Courier;"><br>FileHandle file3("n3.txt", "rw")<br>}</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">当</span><span style="font-family:Verdana;">Foo()</span><span style="font-family:宋体;">调用</span><span style="font-family:Verdana;">Bar()</span><span style="font-family:宋体;">时，局部对象</span><span style="font-family:Verdana;">file1</span><span style="font-family:宋体;">和</span><span style="font-family:Verdana;">file2</span><span style="font-family:宋体;">已经在</span><span style="font-family:Verdana;">Foo</span><span style="font-family:宋体;">的函数调用栈中创建完毕，而</span><span style="font-family:Verdana;">file3</span><span style="font-family:宋体;">却尚未创建。如果</span><span style="font-family:Verdana;">Bar()</span><span style="font-family:宋体;">抛出异常，那么</span><span style="font-family:Verdana;">file2</span><span style="font-family:宋体;">和</span><span style="font-family:Verdana;">file1</span><span style="font-family:宋体;">的析构函数会被先后调用（注意：析构函数的调用顺序与构造函数相反）；由于此时栈中尚不存在</span><span style="font-family:Verdana;">file3</span><span style="font-family:宋体;">对象，因此它的析构函数不会被调用。只有当一个对象的构造函数执行完毕之后，我们才认为该对象的创建工作已经完成。栈辗转开解过程仅调用那些业已创建的对象的析构函数。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">惯用法同样适用于需要管理多个资源的复杂对象。例如，</span><span style="font-family:Verdana;">Widget</span><span style="font-family:宋体;">类的构造函数要获取两个资源：文件</span><span style="font-family:Verdana;">myFile</span><span style="font-family:宋体;">和互斥锁</span><span style="font-family:Verdana;">myLock</span><span style="font-family:宋体;">。每个资源的获取都有可能失败并且抛出异常。为了正常使用</span><span style="font-family:Verdana;">Widget</span><span style="font-family:宋体;">对象，这里我们必须维护一个不变式（</span><span style="font-family:Verdana;">invariant</span><span style="font-family:宋体;">）：当调用构造函数时，要么两个资源全都获得，对象创建成功；要么两个资源都没得到，对象创建失败。获取了文件而没有得到互斥锁的情况永远不能出现，也就是说，不允许建立</span><span style="font-family:Verdana;">Widget</span><span style="font-family:宋体;">对象的</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">半成品</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">。如果将</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">惯用法应用于成员对象，那么我们就可以实现这个不变式：</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Courier;">class Widget {<br>public:<br>Widget(char const* myFile, char const* myLock)<br>: file_(myFile), // </span><span style="font-family:宋体;">获取文件</span><span style="font-family:Courier;">myFile<br>lock_(myLock) // </span><span style="font-family:宋体;">获取互斥锁</span><span style="font-family:Courier;">myLock<br>{}<br>// ...<br>private:<br>FileHandle file_;<br>LockHandle lock_;<br>};</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:Verdana;">FileHandle</span><span style="font-family:宋体;">和</span><span style="font-family:Verdana;">LockHandle</span><span style="font-family:宋体;">类的对象作为</span><span style="font-family:Verdana;">Widget</span><span style="font-family:宋体;">类的数据成员，分别表示需要获取的文件和互斥锁。资源的获取过程就是两个成员对象的初始化过程。在此系统会自动地为我们进行资源管理，程序员不必显式地添加任何异常处理代码。例如，当已经创建完</span><span style="font-family:Verdana;">file_</span><span style="font-family:宋体;">，但尚未创建完</span><span style="font-family:Verdana;">lock_</span><span style="font-family:宋体;">时，有一个异常被抛出，则系统会调用</span><span style="font-family:Verdana;">file_</span><span style="font-family:宋体;">的析构函数，而不会调用</span><span style="font-family:Verdana;">lock_</span><span style="font-family:宋体;">的析构函数。</span><span style="font-family:Verdana;">Bjarne</span><span style="font-family:宋体;">所谓构造函数和析构函数</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">与异常处理的交互作用</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">，说的就是这种情形。</span><span style="font-family:Verdana;">   </span></p><p><span style="font-family:宋体;">综上所述，</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源必被释放。换句话说，拥有对象就等于拥有资源，对象存在则资源必定存在。由此可见，</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">惯用法是进行资源管理的有力武器。</span><span style="font-family:Verdana;">C++</span><span style="font-family:宋体;">程序员依靠</span><span style="font-family:Verdana;">RAII</span><span style="font-family:宋体;">写出的代码不仅简洁优雅，而且做到了异常安全。难怪微软的</span><span style="font-family:Verdana;">MSDN</span><span style="font-family:宋体;">杂志在最近的一篇文章中承认：</span><span style="font-family:Verdana;">"</span><span style="font-family:宋体;">若论资源管理，谁也比不过标准</span><span style="font-family:Verdana;">C++"</span><span style="font-family:宋体;">。</span></p>
</body></html>