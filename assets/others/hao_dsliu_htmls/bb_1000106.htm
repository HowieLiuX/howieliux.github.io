<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]浅谈字节序（Endianness）</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]浅谈字节序（Endianness）</h2>
<p align="right">发布时间：2012-11-15 19:40
<br>分类名称：windows</p><br>
  <P style="BACKGROUND: white;"  >&nbsp;From： <A rel="nofollow" href="http://4ever-memory.com/2010/03/05/introduction-to-endianness/"  >http://4ever-memory.com/2010/03/05/introduction-to-endianness/</A></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >假期里面在家里忙尹老师的激光项目，阅读文件格式文档的时候看到关于字节序（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Byte Order</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）的要求：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #ecf6f8;"  ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: Georgia; COLOR: #35383d;"  ><EM>For values which span more than a single byte, the multiple byte ordering followed is that of the Big Endian / Motorola standard. The most significant byte will occur first, the least significant byte last </EM></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >想起以前在汇编语言和数字逻辑的时候也有接触到一些这个概念，已经有点模糊了，搞不清楚哪个是低位在前哪个是高位在前。后来在</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Wiki</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Google</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的帮助下也算摸清楚了一些</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Endianness</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的概念。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #2a2a2a;"  ><SPAN style="FONT-SIZE: 16pt; COLOR: white;"  ><STRONG><SPAN style="FONT-FAMILY: 宋体;"  >一、字节序的起源</SPAN><SPAN style="FONT-FAMILY: Arial;"  > </SPAN></STRONG></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >在计算机中，<STRONG>字节序（</STRONG></SPAN><SPAN style="COLOR: #0099cc;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><STRONG>Endianness</STRONG></SPAN><SPAN style="COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  ><STRONG>）</STRONG>是数据中单独的可取地址的亚型（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >words</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >bytes</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >bits</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）在外部存储器中存储的顺序。通常在提到四字（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >ddword</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）、双字（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >dword</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）和字（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >word</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）的时候需要考虑其实际的字节顺序，为了简便起见它的英文也常常表示为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Byte Order</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Endianness</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >这个词源自</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1726</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >年</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Jonathan Swift</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的名著：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Gulliver's Travels</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（格列佛游记），在书中有一个故事，大意是指</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Lilliput</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（小人国）的领导下了一道指令，规定其人民在剥水煮蛋时必须从</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >little-end</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（小的那一端）开始。这个规定惹恼了一群觉得应该要从</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >big-end</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（大的那一刻）开始剥的人。事情发展到后来，竟然演变成一场纷战。支持小的那端的人被称为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >little-endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，反之则被称为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >big-endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（在英语中后缀</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"-ian"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >表示</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"xx</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >人</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的意思）。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1980</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >年</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Danny Cohen</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在他的论文</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"On Holy Wars and a Plea for Peace"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >中第一次使用了</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big-</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little-</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >这两个术语，最终它们成为了计算机通过网络与其他计算机连接时所要考虑的极其重要的一个问题。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #2a2a2a;"  ><SPAN style="FONT-SIZE: 16pt; COLOR: white;"  ><STRONG><SPAN style="FONT-FAMILY: 宋体;"  >二、字节序的种类和其表示</SPAN><SPAN style="FONT-FAMILY: Arial;"  > </SPAN></STRONG></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >那么为什么要引入字节序呢。我们都知道，计算机存储中最小的单位是位（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >bit</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >），而</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >8bit</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >构成一个字节（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >byte</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）。在一个</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >32</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >CPU</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >中，字长为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >32bit</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，也就是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >4byte</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，数据要想存放在内存中供</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >CPU</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >读取和写入，就需要拥有一定的存放顺序。这样不同的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >CPU</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >可接受的字节序有可能不同，那么在设计硬件和软件时数据的存放问题也需要分开考虑。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >数据都有所谓的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >有效位（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Significant Bit</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，顾名思义它表示了</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >数据存放有效的位置</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >"</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，而字节序的分类就是依赖于有效位来进行划分的。在一个字节当中，数据的有效位的顺序已经得到了大多数硬件生产商的共识，那就是最高有效位优先（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Most Significant Bit First</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >），例如我们用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >8</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位二进制数来表示十进制数</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >123</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >01111011</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，其第一位的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >就是最高有效位，而最后一位的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >就是最低有效位，在一个字节当中，几乎当前所有的硬件都采用了这种直观的字节序。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >然而情况在离开了单字节时就有所不同了。不同的硬件产商对于数据占据多个字节时拥有怎样的字节序有着不同的理解，具体说来分为以下三类：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <UL>  <LI>  <DIV style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #666666;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（大字节序）：最高有效字节优先，更高的字节有效位占据着更低地址的内存空间，其在内存中的表示与直观吻合，</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></DIV>  </LI><LI>  <DIV style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #666666;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（小字节序）：最低有效字节优先，更低的字节有效位占据着更低地址的内存空间，其在内存中的表示与直观相反，以及</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></DIV>  </LI><LI>  <DIV style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #666666;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Mixed-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（混合字节序）或者</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Middle-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（中字节序）：在</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >16</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位字（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >word</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）中的字节序与</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >32</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位字（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >dword</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）中的字节序不相同。这种类型的字节序较为少见。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >一些知名的使用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的处理器体系结构包括了：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x86</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >6502</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Z80</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >VAX</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >以及</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >PDP-11</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，使用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的处理器通常是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Motorola</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的处理器，例如：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >6800</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >68000</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >PowerPC</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（即</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Macintosh</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在迁移到</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x86</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >之前所采用的处理器）以及</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >System/370</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >。这也是为什么在文章开头提到的文档中使用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big Endian / Motorola standard</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >这样的词汇的原因。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >更进一步的，像</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >ARM</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >PowerPC</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Alpha</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >SPARC V9</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >MIPS</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >、</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >PA-RISC</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >IA64</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >等体系结构可以支持可切换的字节序这样的特性，这个特性可以提高效率或者简化网络设备和软件的逻辑。这种可切换的字节序被称为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Bi-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，用于硬件上意指计算机或者传递数据时可以使用两种不同字节序中任意一种的能力。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >文字不够直观，下面以数值</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0x0A0B0C0D<SUB>h</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >为例说明</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在内存布局上的不同：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  </LI><LI>  <DIV style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #666666;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在内存中的表示</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></DIV>  <P style="BACKGROUND: white;"  ><A rel="nofollow" href="http://www.flickr.com/photos/40052855@N08/4407980268/" ></A><A rel="nofollow" href="http://www.flickr.com/photos/40052855@N08/4407980268/" ><IMG title="浅谈字节序（Endianness） - Howie - Dspace"  border="0" alt=""  align="right" src="pic/img7.ph.126.net_T1_3EJhB0tqED7f7VDI60A==_6597380928448567707.jpg"  ></A><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  > </SPAN></P>  <DIV style="MARGIN-LEFT: 40pt;"  >  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 40px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" colSpan="6" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><EM>increasing addresses</EM>&nbsp; </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >→</SPAN></SPAN></P></TD></TR>  <TR>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0A<SUB>h</SUB></SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0B<SUB>h</SUB></SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0C<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-RIGHT: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0D<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-TOP: medium none; BORDER-RIGHT: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >在这个例子中，最高有效字节（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >MSB</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0A<SUB>h</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，储存在最低地址的内存中；次高有效位为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0B<SUB>h</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，储存在接下来的内存中，依此类推。这种字节序与从左向右的顺序读取十六进制数值非常类似。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >以</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >16</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位元素大小查看：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <DIV style="MARGIN-LEFT: 40pt;"  >  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 56px;"  >  <COL style="WIDTH: 56px;"  >  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 8px;"  >  <COL style="WIDTH: 8px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" colSpan="6" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><EM>increasing addresses</EM>&nbsp; </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >→</SPAN></SPAN></P></TD></TR>  <TR>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0A0B<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-RIGHT: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0C0D<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >&nbsp;</TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >&nbsp;</TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  ><SPAN style="FONT-SIZE: 10pt;"  >最高有效元素现在保存的是</SPAN><SPAN style="FONT-SIZE: 16pt;"  >0A0B<SUB>h</SUB></SPAN><SPAN style="FONT-SIZE: 10pt;"  >，接下来的元素保存</SPAN><SPAN style="FONT-SIZE: 16pt;"  >0C0D<SUB>h</SUB></SPAN></SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana;"  >. </SPAN></SPAN></P>  </LI><LI>  <DIV style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #666666;"  ><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在内存中的表示</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></DIV>  <P style="BACKGROUND: white;"  ><A rel="nofollow" href="http://www.flickr.com/photos/40052855@N08/4407997032/" ></A><A rel="nofollow" href="http://www.flickr.com/photos/40052855@N08/4407997032/" ><IMG title="浅谈字节序（Endianness） - Howie - Dspace"  border="0" alt=""  align="right" src="pic/img8.ph.126.net_0ECPMJFYt8PiygXefItYXg==_6597380928448567708.jpg"  ></A><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  > </SPAN></P>  <DIV style="MARGIN-LEFT: 40pt;"  >  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 35px;"  >  <COL style="WIDTH: 40px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" colSpan="6" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><EM>increasing addresses</EM>&nbsp; </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >→</SPAN></SPAN></P></TD></TR>  <TR>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0D<SUB>h</SUB></SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0C<SUB>h</SUB></SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0B<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-RIGHT: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0A<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-TOP: medium none; BORDER-RIGHT: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="COLOR: #35383d;"  ><SPAN style="FONT-SIZE: 10pt;"  ><SPAN style="FONT-FAMILY: 宋体;"  >在这个例子中，最低有效字节（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >LSB</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体;"  ><SPAN style="FONT-SIZE: 10pt;"  >）的值为</SPAN><SPAN style="FONT-SIZE: 16pt;"  >0D<SUB>h</SUB></SPAN><SPAN style="FONT-SIZE: 10pt;"  >，储存在最低地址的内存，其他字节依照字节有效性的递增依次存放。</SPAN></SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >16</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >位元素大小表示</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <DIV style="MARGIN-LEFT: 40pt;"  >  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 56px;"  >  <COL style="WIDTH: 56px;"  >  <COL style="WIDTH: 40px;"  >  <COL style="WIDTH: 8px;"  >  <COL style="WIDTH: 8px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" colSpan="6" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><EM>increasing addresses</EM>&nbsp; </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >→</SPAN></SPAN></P></TD></TR>  <TR>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0C0D<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-RIGHT: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >0A0B<SUB>h</SUB></SPAN></P></TD>  <TD style="BORDER-TOP: medium none; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; BORDER-LEFT: medium none; PADDING-RIGHT: 4px;"  vAlign="middle" >  <P style="TEXT-ALIGN: center;"  ><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  >...</SPAN></P></TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >&nbsp;</TD>  <TD style="PADDING-BOTTOM: 4px; PADDING-TOP: 4px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px;"  vAlign="middle" >&nbsp;</TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="COLOR: #35383d;"  ><SPAN style="FONT-SIZE: 10pt;"  ><SPAN style="FONT-FAMILY: 宋体;"  >最低有效</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >16</SPAN></SPAN><SPAN style="FONT-FAMILY: 宋体;"  ><SPAN style="FONT-SIZE: 10pt;"  >位单元储存的是值</SPAN><SPAN style="FONT-SIZE: 16pt;"  >0C0D<SUB>h</SUB></SPAN><SPAN style="FONT-SIZE: 10pt;"  >，紧接着储存值</SPAN><SPAN style="FONT-SIZE: 16pt;"  >0A0B<SUB>h</SUB></SPAN><SPAN style="FONT-SIZE: 10pt;"  >。</SPAN></SPAN><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #2a2a2a;"  ><SPAN style="FONT-SIZE: 16pt; COLOR: white;"  ><STRONG><SPAN style="FONT-FAMILY: 宋体;"  >三、字节序的重要性及其应用</SPAN><SPAN style="FONT-FAMILY: Arial;"  > </SPAN></STRONG></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >如前所述，不同硬件的体系结构接受不同字节序的数据表示，因此当同一个文件在不同的机器中进行读取和写入的时候，其所支持的字节序就显得尤为关键。设想在</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x86</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >计算机中将</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >(123888)<SUB>10</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >写入二进制文件中，由于</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x86</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >支持</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，所以该数在文件中保存为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >(0000003F1E)<SUB>16</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >。当在</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >PowerPC</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >计算机中读取该整数时，由于它支持的是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，故读取的结果将是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >(16158)<SUB>10</SUB></SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，大相径庭。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >同样的情况也会出现在网络传输当中，当你从支持一种字节序的机器发送数据到支持相反字节序的机器时，将会得到非预期的结果。这种错误在网络传输当中尤为突出，因为你无法决定发送你所需文件机器所支持的字节序，因为这些机器可能分散在世界各地，不是人为所能控制的。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >为了更明确的说明上述问题，考虑下列代码：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #fdfdfd;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: black;"  ><SPAN style="TEXT-DECORATION: underline;"  >Listing 1</SPAN>: Example </SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Consolas; COLOR: green;"  >01<SPAN style="COLOR: black;"  > <SPAN style="COLOR: blue;"  >#include &lt;stdio.h&gt;<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >02<SPAN style="COLOR: black;"  > <SPAN style="COLOR: blue;"  >#include &lt;string.h&gt;<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >03<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >04<SPAN style="COLOR: black;"  > <SPAN style="COLOR: #2b91af;"  >int<SPAN style="COLOR: black;"  > main (<SPAN style="COLOR: #2b91af;"  >int<SPAN style="COLOR: black;"  > argc, <SPAN style="COLOR: #2b91af;"  >char<SPAN style="COLOR: black;"  >* argv[]) {<BR><SPAN style="COLOR: #f810b0;"  >05<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: #2b91af;"  >FILE<SPAN style="COLOR: black;"  >* fp;<BR><SPAN style="COLOR: green;"  >06<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >07<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: green;"  >/* Our example data structure */<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >08<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue;"  >struct<SPAN style="COLOR: black;"  > {<BR><SPAN style="COLOR: green;"  >09<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: #2b91af;"  >char<SPAN style="COLOR: black;"  > one[4];<BR><SPAN style="COLOR: #f810b0;"  >10<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: #2b91af;"  >int<SPAN style="COLOR: black;"  >&nbsp; two;<BR><SPAN style="COLOR: green;"  >11<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: #2b91af;"  >char<SPAN style="COLOR: black;"  > three[4];<BR><SPAN style="COLOR: green;"  >12<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; } data;<BR><SPAN style="COLOR: green;"  >13<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >14<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: green;"  >/* Fill our structure with data */<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: #f810b0;"  >15<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; strcpy (data.one, <SPAN style="COLOR: #a31515;"  >"foo"<SPAN style="COLOR: black;"  >);<BR><SPAN style="COLOR: green;"  >16<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; data.two = 0×01234567;<BR><SPAN style="COLOR: green;"  >17<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; strcpy (data.three, <SPAN style="COLOR: #a31515;"  >"bar"<SPAN style="COLOR: black;"  >);<BR><SPAN style="COLOR: green;"  >18<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >19<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: green;"  >/* Write it to a file */<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: #f810b0;"  >20<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen (<SPAN style="COLOR: #a31515;"  >"output"<SPAN style="COLOR: black;"  >, <SPAN style="COLOR: #a31515;"  >"wb"<SPAN style="COLOR: black;"  >);<BR><SPAN style="COLOR: green;"  >21<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: blue;"  >if<SPAN style="COLOR: black;"  > (fp) {<BR><SPAN style="COLOR: green;"  >22<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fwrite (&amp;data, <SPAN style="COLOR: blue;"  >sizeof<SPAN style="COLOR: black;"  > (data), 1, fp);<BR><SPAN style="COLOR: green;"  >23<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose (fp);<BR><SPAN style="COLOR: green;"  >24<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; }<BR><SPAN style="COLOR: #f810b0;"  >25<SPAN style="COLOR: black;"  > } </SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >这是一段很简单的</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >C</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >语言代码，作用就是向一个</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >data</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >结构体赋值并且将它写入文件当中，从结果</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Listing 2</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >和</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Listing 3</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >当中我们就可以看到支持不同字节序的机器在处理数据时候存在的不同。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  ><STRONG>Listing 2. hexdump –C output on big-endian machines </STRONG></SPAN></P>  <DIV>  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 572px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="BORDER-TOP: 0.75pt outset; BORDER-RIGHT: 0.75pt outset; BORDER-BOTTOM: 0.75pt outset; BORDER-LEFT: 0.75pt outset;"  vAlign="middle" >  <P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  ><FONT size="2" >00000000 66 6f 6f 00 01 23 45 67 62 61 72 00 |foo..#Egbar.| </FONT></SPAN></P>  <P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  ><FONT size="2" >0000000c</FONT></SPAN></P></TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  ><STRONG>Listing 3. hexdump -C output on little-endian machines</STRONG> </SPAN></P>  <DIV>  <TABLE style="BORDER-COLLAPSE: collapse;"  border="0" >  <COLGROUP>  <COL style="WIDTH: 572px;"  >  <TBODY vAlign="top" >  <TR>  <TD style="BORDER-TOP: 0.75pt outset; BORDER-RIGHT: 0.75pt outset; BORDER-BOTTOM: 0.75pt outset; BORDER-LEFT: 0.75pt outset;"  vAlign="middle" >  <P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  ><FONT size="2" >00000000 66 6f 6f 00 67 45 23 01 62 61 72 00 |foo.gE#.bar.| </FONT></SPAN></P>  <P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #35383d;"  ><FONT size="2" >0000000c</FONT></SPAN></P></TD></TR></TABLE></DIV>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >注意力好的同学一眼就能发现，在写整数的时候，数据保存的顺序依赖于不同的机器，而字符串却不受此影响，这是为什么呢？这就牵涉到字节序是如何如代码进行影响的了。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  ><STRONG>字节序并不会影响数据存储的所有方面</STRONG>，例如对一个整数进行</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >bitwise</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >或者</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >bitshift</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的操作，你是不需要去注意对应的字节序的。因为多字节的顺序是由计算机来维护的，对于程序员来说，一个整数的最低有效位仍然是最低有效位，最高有效位亦然，并不会由于它在计算机底层存储模式的改变而影响到有效位的含义。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >同样的，<STRONG>字节序不会影响到</STRONG></SPAN><SPAN style="FONT-FAMILY: Verdana;"  ><STRONG>C</STRONG></SPAN><SPAN style="FONT-FAMILY: 宋体;"  ><STRONG>风格字符串在计算机底层的存储顺序</STRONG>，这是为什么呢？考虑到一个</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >C</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >风格字符串的实质是一个包含着许多</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >char</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的数组，每一个</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >char</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >在现代计算机中几乎都是表示计算机中的一个字节。因此，当读写</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >C</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >风格字符串时，其最小的元素单位是一个字节；而且数组在内存单元中地址的排列顺序是递增的，例如定义</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >char str[5];</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >这么一条语句，假设</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >&amp;str[0]</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的地址为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1000</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，则</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >&amp;str[1]</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的地址为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1001</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，依次类推。所以不论从直观含义或者底层技术来看，字符串的存储都是相对字节序独立的，这个特性将应用在接下来的许多小技巧中。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >那么字节序除了影响到多字节数据在内存中的存放顺序以外，在写代码的时候还有什么需要注意的呢？当对一个数据进行类型转换的时候，需要记住<STRONG>特定的字节序很可能影响到类型转换的结果</STRONG>。假设我们有</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Listing 4</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >所列的这么一段代码</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #fdfdfd;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: black;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><SPAN style="TEXT-DECORATION: underline;"  >Listing 4</SPAN>: </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >强制类型转换</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Consolas; COLOR: green;"  >1<SPAN style="COLOR: black;"  > <SPAN style="COLOR: #2b91af;"  >unsigned<SPAN style="COLOR: black;"  > <SPAN style="COLOR: #2b91af;"  >char<SPAN style="COLOR: black;"  > endian[2] = {1, 0};<SPAN style="COLOR: green;"  >2<SPAN style="COLOR: black;"  > <SPAN style="COLOR: #2b91af;"  >short<SPAN style="COLOR: black;"  > x;<SPAN style="COLOR: green;"  >3<SPAN style="COLOR: black;"  ><BR><SPAN style="COLOR: green;"  >4<SPAN style="COLOR: black;"  > x = *(<SPAN style="COLOR: #2b91af;"  >short<SPAN style="COLOR: black;"  > *) endian; </SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >那么最后得到</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的结果是多少呢？是不是简单的就是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >数组的第一个元素</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >呢？答案是错，</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的数值需要根据运行时的环境来决定。让我们回忆一下</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >C</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >语言的指针指向多大的内存以及怎么去解释所指的这块内存是由指针所指向的类型来确定的，在上述代码中，将</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >数组的首元素指针强制转换成</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >short *</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的指针，那么编译器在解释它的时候将不再把它指向的内存空间视为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1 byte</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，而是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >short</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的长度</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >——2 byte</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >；更重要的是当我们对这个指针解引用的时候将会得到的值会是什么。再回到上面所提到的字符串或者字符数组在计算机中就是依照数组顺序存放的，那么这个时候</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >数组占用了两个字节，其内存数据为：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0100</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >。当该指针强制转换为指向</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >short</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的指针并解引用时，计算机将一次读取两个字节，这个时候字节序就发挥它的影响了。在支持</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的机器中</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的值将是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（读取为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0001</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >），而在支持</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big-Endian</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的机器中</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >x</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的值就是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >256</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（读取为</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0100</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）。因此在对指针进行类型转换并解引用，特别是在单字节到多字节数据的转换时，要特别注意字节序是否会使得预期结果出现偏差。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >单字节指针到多字节指针的转换其实并不完全像</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Listing 4</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >所举例子那样恼人，它还有其他的用途，例如我们可以使用这个特性在运行时判断当前计算机所支持的字节序，这样可以使得程序员在编写代码的时候更加灵活，也使得代码更加强健（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >robust</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）。基本的思路就是先定义一个</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >int</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >变量</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >，这个变量在不同的计算机中将有两种不同的存储顺序：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >01000000</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Little</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >）以及</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >00000001</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >（</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Big</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >），然后我们将指向这个变量的指针强制转换为指向字符的指针，再解引用根据它的值是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >0</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >还是</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >1</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >就可以得出当前机器支持的字节序的，代码很简单：</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #fdfdfd;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: black;"  ><SPAN style="FONT-FAMILY: Verdana;"  ><SPAN style="TEXT-DECORATION: underline;"  >Listing 5</SPAN>: </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >判断字节序</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Consolas; COLOR: green;"  >1<SPAN style="COLOR: black;"  > <SPAN style="COLOR: #2b91af;"  >int<SPAN style="COLOR: black;"  > i = 1;<SPAN style="COLOR: green;"  >23<SPAN style="COLOR: black;"  > <SPAN style="COLOR: blue;"  >if<SPAN style="COLOR: black;"  > (*(<SPAN style="COLOR: #2b91af;"  >char<SPAN style="COLOR: black;"  >*)&amp;i == 0) </SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: green;"  >4<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: green;"  >// Big Endian<SPAN style="COLOR: black;"  > </SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #f810b0;"  >5<SPAN style="COLOR: black;"  > <SPAN style="COLOR: blue;"  >else<SPAN style="COLOR: black;"  > </SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: #f9f7ed;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: green;"  >6<SPAN style="COLOR: black;"  >&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="COLOR: green;"  >// Little Endian<SPAN style="COLOR: black;"  > </SPAN></SPAN></SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: 宋体;"  >利用</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >char*</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >的这种特性还可以方便的反转数据顺序以适应不同的机器，怎么编写这样的代码不如让你来思考一下？</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > </SPAN></SPAN></P>  <P style="BACKGROUND: #2a2a2a;"  ><SPAN style="FONT-SIZE: 16pt; COLOR: white;"  ><STRONG><SPAN style="FONT-FAMILY: 宋体;"  >四、参考文献</SPAN><SPAN style="FONT-FAMILY: Arial;"  > </SPAN></STRONG></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  >1. Endianness. <A rel="nofollow" href="http://en.wikipedia.org/wiki/Endianness" ><SPAN style="COLOR: #0099cc;"  >http://en.wikipedia.org/wiki/Endianness</SPAN></A> </SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; COLOR: #35383d;"  ><SPAN style="FONT-FAMILY: Verdana;"  >2. </SPAN><SPAN style="FONT-FAMILY: 宋体;"  >关于</SPAN><SPAN style="FONT-FAMILY: Verdana;"  >Endianness</SPAN><SPAN style="FONT-FAMILY: 宋体;"  >翻译的讨论。</SPAN><SPAN style="FONT-FAMILY: Verdana;"  > <A title="http://shu1tong2wen2.wikia.com/wiki/Endianness" rel="nofollow" href="http://shu1tong2wen2.wikia.com/wiki/Endianness" ><SPAN style="COLOR: #0099cc;"  >http://shu1tong2wen2.wikia.com/wiki/Endianness</SPAN></A> </SPAN></SPAN></P>  <P style="BACKGROUND: white;"  ><SPAN style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana; COLOR: #35383d;"  >3. Writing Endian-independent Code in C. <A title="http://www.ibm.com/developerworks/aix/library/au-endianc/index.html?ca=drs" rel="nofollow" href="http://www.ibm.com/developerworks/aix/library/au-endianc/index.html?ca=drs" ><SPAN style="COLOR: #0099cc;"  >http://www.ibm.com/developerworks/aix/library/au-endianc/index.html?ca=drs</SPAN></A></SPAN></P></LI></UL>
</body></html>