<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] (5) OpenSSL 之内存分配</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] (5) OpenSSL 之内存分配</h2>
<p align="right">发布时间：2010-4-4 17:30
<br>分类名称：OpenSSL</p><br>
<div><b>openssl内存分配</b></div><div>用户在使用内存时，容易犯的错误就是内存泄露。当用户调用内存分配和释放函数时，查找内存泄露比较麻烦。openssl提供了内置的内存分配/释放函数。如果用户完全调用openssl的内存分配和释放函数，可以方便的找到内存泄露点。openssl分配内存时，在其内部维护一个内存分配哈希表，用于存放已经分配但未释放的内存信息。当用户申请内存分配时，在哈希表中添加此项信息，内存释放时删除该信息。当用户通过openssl函数查找内存泄露点时，只需查询该哈希表即可。用户通过openssl回调函数还能处理那些泄露的内存。</div><div><br></div><div>openssl供用户调用的内存分配等函数主要在crypto/mem.c中实现，其内置的分配函数在crypto/mem_dbg.c中实现。默认情况下mem.c中的函数调用mem_dbg.c中的实现。如果用户实现了自己的内存分配函数以及查找内存泄露的函数，可以通过调用CRYPTO_set_mem_functions函数和CRYPTO_set_mem_debug_functions函数来设置。下面主要介绍了openssl内置的内存分配和释放函数。</div><div><br></div><div><b>内存数据结构</b></div><div>openssl内存分配数据结构是一个内部数据结构，定义在crypto/mem_dbg.c中。如下所示：</div><div>typedef struct app_mem_info_st</div><div>{<span style="white-space:pre;"> </span></div><div><span style="white-space:pre;"> </span>unsigned long thread;</div><div><span style="white-space:pre;"> </span>const char *file;</div><div><span style="white-space:pre;"> </span>int line;</div><div><span style="white-space:pre;"> </span>const char *info;</div><div><span style="white-space:pre;"> </span>struct app_mem_info_st *next; /* tail of thread's stack */</div><div><span style="white-space:pre;"> </span>int references;</div><div>} APP_INFO;</div><div><br></div><div>typedef struct mem_st</div><div>{</div><div><span style="white-space:pre;"> </span>void *addr;</div><div><span style="white-space:pre;"> </span>int num;</div><div><span style="white-space:pre;"> </span>const char *file;</div><div><span style="white-space:pre;"> </span>int line;</div><div><span style="white-space:pre;"> </span>unsigned long thread;</div><div><span style="white-space:pre;"> </span>unsigned long order;</div><div><span style="white-space:pre;"> </span>time_t time;</div><div><span style="white-space:pre;"> </span>APP_INFO *app_info;</div><div>} MEM;</div><div><br></div><div>各项意义：</div><div>addr：分配内存的地址。</div><div>num：分配内存的大小。</div><div>file：分配内存的文件。</div><div>line：分配内存的行号。</div><div>thread：分配内存的线程ID。</div><div>order：第几次内存分配。</div><div>time：内存分配时间。</div><div>app_info:用于存放用户应用信息，为一个链表，里面存放了文件、行号以及线程ID等信息。</div><div>references：被引用次数。</div><div><br></div><div><b>主要函数</b></div><div>1)CRYPTO_mem_ctrl</div><div>本函数主要用于控制内存分配时，是否记录内存信息。如果不记录内存信息，将不能查找内存泄露。开启内存记录调用CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON)，关闭内存记录调用CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF)。一旦CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON)被调用，直到用户调用CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF)前，用户<span style="white-space:pre;"> </span>所有的opessl内存分配都会被记录。</div><div>2)CRYPTO_is_mem_check_on</div><div>查询内存记录标记是否开启。</div><div>3)CRYPTO_dbg_malloc</div><div>本函数用于分配内存空间，如果内存记录标记开启，则记录用户申请的内存。当需要记录内存信息时，该函数本身也需要申请内存插入哈希表，为了防止递归申请错误，它申请内存记录信息前必须暂时关闭内存记录标记，申请完毕再放开。</div><div>4)CRYPTO_dbg_free</div><div>释放内存，如果内存记录标记开启，还需要删除哈希表中对应的记录。</div><div>5)CRYPTO_mem_leaks</div><div>将内存泄露输出到BIO中。</div><div>6)CRYPTO_mem_leaks_fp</div><div>将内存泄露输出到FILE中(文件或者标准输出)，该函数调用了CRYPTO_mem_leaks。</div><div>7)CRYPTO_mem_leaks_cb</div><div>处理内存泄露，输入参数为用户自己实现的处理内存泄露的函数地址。该函数只需要处理一个内存泄露，openssl通过lh_doall_arg调用用户函数来处理所有记录(泄露的内存)。</div><div><br></div><div><div><b>编程示例</b></div><div>示例1</div><div>#include &lt;string.h&gt;</div><div>#include &lt;openssl/crypto.h&gt;</div><div>int<span style="white-space:pre;"> </span>main()</div><div>{<span style="white-space:pre;"> </span></div><div><span style="white-space:pre;"> </span>char<span style="white-space:pre;"> </span>*p;</div><div><span style="white-space:pre;"> </span>int<span style="white-space:pre;"> </span>i;</div><div><span style="white-space:pre;"> </span>p=OPENSSL_malloc(4);</div><div><span style="white-space:pre;"> </span>p=OPENSSL_remalloc(p,40);</div><div><span style="white-space:pre;"> </span>p=OPENSSL_realloc(p,32);</div><div><span style="white-space:pre;"> </span>for(i=0;i&lt;32;i++)</div><div><span style="white-space:pre;"> </span>memset(&amp;p[i],i,1);</div><div><span style="white-space:pre;"> </span>/* realloc时将以前的内存区清除(置乱) */</div><div><span style="white-space:pre;"> </span>p=OPENSSL_realloc_clean(p,32,77);</div><div><span style="white-space:pre;"> </span>p=OPENSSL_remalloc(p,40);</div><div><span style="white-space:pre;"> </span>OPENSSL_malloc_locked(3);</div><div><span style="white-space:pre;"> </span>OPENSSL_free(p);</div><div><span style="white-space:pre;"> </span>return 0;</div><div>}</div><div>上述示例使用了基本的openssl内存分配和释放函数。</div><div>OPENSSL_malloc:<span style="white-space:pre;"> </span>分配内存空间。</div><div>OPENSSL_remalloc：<span style="white-space:pre;"> </span>重新分配内存空间。</div><div>OPENSSL_realloc_clean：<span style="white-space:pre;"> </span>重新分配内存空间，将老的数据进行拷贝，置乱老的数据空间并释放。</div><div>OPENSSL_malloc_locked<span style="white-space:pre;"> </span>与锁有关。</div><div>OPENSSL_free：<span style="white-space:pre;"> </span>释放空间。</div><div><br></div><div>示例2</div><div>include &lt;openssl/crypto.h&gt;</div><div>#include &lt;openssl/bio.h&gt;</div><div>int<span style="white-space:pre;"> </span>main()</div><div><span style="white-space:pre;"> </span>{</div><div><span style="white-space:pre;"> </span>char<span style="white-space:pre;"> </span>*p;</div><div><span style="white-space:pre;"> </span>BIO<span style="white-space:pre;"> </span>*b;</div><div><span style="white-space:pre;"> </span>CRYPTO_malloc_debug_init();</div><div><span style="white-space:pre;"> </span>CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);</div><div><span style="white-space:pre;"> </span>CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);</div><div><span style="white-space:pre;"> </span>p=OPENSSL_malloc(4);</div><div><span style="white-space:pre;"> </span>CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF);</div><div><span style="white-space:pre;"> </span>b=BIO_new_file("leak.log","w");</div><div><span style="white-space:pre;"> </span>CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);</div><div><span style="white-space:pre;"> </span>CRYPTO_mem_leaks(b);</div><div><span style="white-space:pre;"> </span>OPENSSL_free(p);</div><div><span style="white-space:pre;"> </span>BIO_free(b);</div><div><span style="white-space:pre;"> </span>return 0;<span style="white-space:pre;"> </span></div><div>}</div></div>
</body></html>