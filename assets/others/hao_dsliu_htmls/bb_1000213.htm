<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] boost 库 enable_shared_from_this 实现原理分析</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] boost 库 enable_shared_from_this 实现原理分析</h2>
<p align="right">发布时间：2011-6-1 14:13
<br>分类名称：Boost</p><br>
<p><span style="color:red;"  ><span style="font-family:宋体;"  >使用情景<span style="color:blue;"  >：当类对象被</span></span><span style="font-family:Verdana;"  > shared_ptr </span><span style="color:blue;"  ><span style="font-family:宋体;"  >管理时，需要在类自己定义的函数里把当前类对象作为参数传给其他函数时，这时需要传递一个</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >，否则就不能保持</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >管理这个类对象的语义（<span style="color:black;"  >因为有一个</span></span><span style="font-family:Verdana;"  > raw pointer </span><span style="color:black;"  ><span style="font-family:宋体;"  >指向这个类对象，而</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >对类对象的这个引用没有计数，很有可能</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >已经把类对象资源释放了，而那个调用函数还在使用类对象</span><span style="font-family:Verdana;"  >——</span><span style="font-family:宋体;"  >显然，这肯定会产生错误<span style="color:blue;"  >）。</span></span><span style="color:black; font-family:Verdana;"  >      </span></span></span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >很好奇这个模板类的实现。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:red;"  ><span style="font-family:宋体;"  >先看看怎么使用<span style="color:blue;"  >：</span></span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >对一个类</span><span style="font-family:Verdana;"  > A </span><span style="font-family:宋体;"  >，当我们希望使用</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >来管理其类对象时，而且需要在自己定义的函数里把类对象</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >（<span style="color:black;"  >为什么不用普通指针，当我们使用智能指针管理资源时，必须统一使用智能指针，而不能在某些地方使用智能指针某些地方使用</span></span><span style="font-family:Verdana;"  > raw pointer </span><span style="color:black;"  ><span style="font-family:宋体;"  >，否则不能保持智能指针的语义，从而产生各种错误<span style="color:blue;"  >）传给其他函数时，可以让类</span></span><span style="font-family:Verdana;"  > A </span><span style="color:blue;"  ><span style="font-family:宋体;"  >从</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >继承：</span><span style="color:black; font-family:Verdana;"  >      </span></span></span></span></p><p><span style="color:blue; font-family:Verdana;"  >class A : public boost::enable_shared_from_this&lt;A&gt; {<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >};<span style="color:black;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >然后在类</span><span style="font-family:Verdana;"  > A </span><span style="font-family:宋体;"  >中需要传递类对象本身</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >的地方使用</span><span style="font-family:Verdana;"  > shared_from_this </span><span style="font-family:宋体;"  >函数来获得指向自身的</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >一个非常有代表性的例子：</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><a target="_blank" rel="nofollow" href="http://www.boost.org/doc/libs/1_39_0/doc/html/boost_asio/tutorial/tutdaytime3/src.html"  ><span style="color:blue; font-family:Verdana; text-decoration:underline;"  >http://www.boost.org/doc/libs/1_39_0/doc/html/boost_asio/tutorial/tutdaytime3/src.html</span></a><span style="color:black; font-family:Verdana;"  >   </span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >另《</span><span style="font-family:Verdana;"  >Beyond the C++ Standard Library</span><span style="font-family:宋体;"  >》</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >节也有很简单明了的例子。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:red;"  ><span style="font-family:宋体;"  >实现原理<span style="color:blue;"  >：</span></span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >首先要考虑的是：在类对象本身当中不能存储类对象本身的</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >，否则类对象</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >永远也不会为</span><span style="font-family:Verdana;"  >0</span><span style="font-family:宋体;"  >了，从而这些资源永远不会释放，除非程序结束。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >其次：类对象肯定是外部函数通过某种机制分配的，而且一经分配立即交给</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >管理（<span style="color:black;"  >再次强调一遍：给</span></span><span style="font-family:Verdana;"  > shared_ptr </span><span style="color:black;"  ><span style="font-family:宋体;"  >管理的资源必须在分配时交给</span><span style="font-family:Verdana;"  > shared_ptr&nbsp;</span><span style="color:blue;"  ><span style="font-family:宋体;"  >），而且以后凡是需要共享使用类对象的地方必须使用这个</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >当作右值来构造产生或者拷贝产生另一个</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >从而达到共享使用的目的。</span><span style="color:black; font-family:Verdana;"  >      </span></span></span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >有了以上两点的限制，要实现我们的目标（<span style="color:black;"  >即在类对象内部使用类对象的</span></span><span style="font-family:Verdana;"  > shared_ptr<span style="color:black;"  >&nbsp;</span></span><span style="color:blue;"  ><span style="font-family:宋体;"  >）有以下两种方案：</span><span style="color:black; font-family:Verdana;"  >     </span></span></span></p><p><span style="color:blue;"  ><span style="font-family:Verdana;"  >1</span><span style="font-family:宋体;"  >、类对象的外部</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >作为函数参数传给类的需要引用类对象自身的函数</span><span style="font-family:Verdana;"  >——</span><span style="font-family:宋体;"  >显然，这种方法很丑陋，而且并不是所有的情况都可行（<span style="color:black;"  >如在外部</span></span><span style="font-family:Verdana;"  > shared_ptr </span><span style="color:black;"  ><span style="font-family:宋体;"  >不可见的作用域中就不行<span style="color:blue;"  >）；</span></span><span style="color:black; font-family:Verdana;"  >     </span></span></span></p><p><span style="color:blue;"  ><span style="font-family:Verdana;"  >2</span><span style="font-family:宋体;"  >、类对象自身存储某种信息，在需要自身</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >时来产生一个临时的</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >显然，第</span><span style="font-family:Verdana;"  >2</span><span style="font-family:宋体;"  >种方法更优雅（对于用户来说），关键是信息怎么存储？</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >对了，</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >！</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >实际上，</span><span style="font-family:Verdana;"  > boost </span><span style="font-family:宋体;"  >中就是这样实现的。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >但现在的问题是：何时初始化这个</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >？因为类对象生成时还没有生成相应的用来管理这个对象的</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:Verdana;"  >boost 1.39.0 </span><span style="font-family:宋体;"  >中是这样实现的：</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >首先生成类</span><span style="font-family:Verdana;"  > A </span><span style="font-family:宋体;"  >：会依次调用</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >的构造函数（定义为</span><span style="font-family:Verdana;"  > protected </span><span style="font-family:宋体;"  >），以及类</span><span style="font-family:Verdana;"  > A </span><span style="font-family:宋体;"  >的构造函数。在调用</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >的构造函数时，会初始化定义在</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >中的</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >（调用其默认构造函数），这时这个</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >是无效的（或者说不指向任何对象）。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >接着：外部程序会把指向类</span><span style="font-family:Verdana;"  > A </span><span style="font-family:宋体;"  >对象的指针作为初始化参数来初始化一个</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >现在来看看</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >是如何初始化的，</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >定义了如下构造函数：</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >template&lt;class Y&gt;<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;explicit shared_ptr( Y * p ): px( p ), pn( p )&nbsp;<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;{<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::detail::sp_enable_shared_from_this( this, p, p );<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;}<span style="color:black;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >里面调用了</span><span style="font-family:Verdana;"  > &nbsp;boost::detail::sp_enable_shared_from_this </span><span style="font-family:宋体;"  >：</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >template&lt; class X, class Y, class T &gt;<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;inline void sp_enable_shared_from_this( boost::shared_ptr&lt;X&gt; const * ppx,<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;Y const * py, boost::enable_shared_from_this&lt; T &gt; const * pe )<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >{<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;{<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pe-&gt;_internal_accept_owner( ppx, const_cast&lt; Y* &gt;( py ) );<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;}<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >}<span style="color:black;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >里面又调用了</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >的</span><span style="font-family:Verdana;"  > _internal_accept_owner </span><span style="font-family:宋体;"  >：</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;{<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weak_this_ = shared_ptr&lt;T&gt;( *ppx, py );<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<span style="color:black;"  >    </span></span></p><p><span style="color:blue; font-family:Verdana;"  >&nbsp;&nbsp;&nbsp;&nbsp;}<span style="color:black;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >而在这里对</span><span style="font-family:Verdana;"  > enable_shared_from_this </span><span style="font-family:宋体;"  >的成员</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >进行拷贝赋值，使得整个</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >作为类对象</span><span style="font-family:Verdana;"  > &nbsp;shared_ptr </span><span style="font-family:宋体;"  >的一个观察者。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue;"  ><span style="font-family:宋体;"  >这时，当类对象本身需要自身的</span><span style="font-family:Verdana;"  > shared_ptr </span><span style="font-family:宋体;"  >时，就可以从这个</span><span style="font-family:Verdana;"  > weak_ptr </span><span style="font-family:宋体;"  >来生成一个了。</span><span style="color:black; font-family:Verdana;"  >    </span></span></p><p><span style="color:blue; font-family:宋体;"  >原来如此。</span></p>
</body></html>