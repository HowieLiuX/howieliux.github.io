<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Getting Started with Winsock</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Getting Started with Winsock</h2>
<p align="right">发布时间：2012-5-22 21:02
<br>分类名称：windows</p><br>
<p><span style="font-family:宋体; font-size:14pt;"  ><strong>复习一下网络编程，三年没看这东西了，忘的是一干二净啊，转自MSDN... ...  </strong></span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>About Servers and Clients </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >There are two distinct types of socket network applications: Server and Client. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Servers and Clients have different behaviors; therefore, the process of creating them is different. What follows is the general model for creating a streaming TCP/IP Server and Client. </span></p><p><span style="font-family:宋体; font-size:13pt;"  ><strong>Server </strong></span></p><ol><li><span style="font-family:宋体; font-size:12pt;"  >Initialize Winsock.&nbsp;&nbsp;&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Create a socket. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Bind the socket. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Listen on the socket for a client. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Accept a connection from a client. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Receive and send data. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Disconnect. </span></li></ol><p><span style="font-family:宋体; font-size:13pt;"  ><strong>Client </strong></span></p><ol><li><span style="font-family:宋体; font-size:12pt;"  >Initialize Winsock. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Create a socket. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Connect to the server. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Send and receive data. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >Disconnect. </span></li></ol><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Creating a Basic Winsock Application </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>============================================================== </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>#include &lt;winsock2.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 包含头文件 </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;ws2tcpip.h&gt; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;stdio.h&gt; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><strong><span style="color:blue;"  >#pragma</span> comment(lib, "Ws2_32.lib")&nbsp;&nbsp;&nbsp;&nbsp;// 添加Lib库 </strong></span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >int</span> main() { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 0; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>Note</strong>&nbsp;&nbsp; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The <em>Iphlpapi.h</em> header file is required if an application is using the IP Helper APIs. When the <em>Iphlpapi.h</em> header file is required, the #include line for the <em>Winsock2.h</em> header this file should be placed before the #include line for the <em>Iphlpapi.h</em> header file.  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The <em>Winsock2.h</em> header file internally includes core elements from the <em>Windows.h</em> header file, so there is not usually an #include line for the <em>Windows.h</em> header file in Winsock applications. If an #include line is needed for the <em>Windows.h</em> header file, this should be preceded with the #define WIN32_LEAN_AND_MEAN macro. For historical reasons, the <em>Windows.h</em> header defaults to including the <em>Winsock.h</em> header file for Windows Sockets 1.1. The declarations in the <em>Winsock.h</em> header file will conflict with the declarations in the <em>Winsock2.h</em> header file required by Windows Sockets 2.0. The WIN32_LEAN_AND_MEAN macro prevents the <em>Winsock.h</em> from being included by the <em>Windows.h</em> header. An example illustrating this is shown below.  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:blue;"  >#if</span>ndef WIN32_LEAN_AND_MEAN </code></pre><p></p><pre><code><span style="color:blue;"  >#define</span> WIN32_LEAN_AND_MEAN </code></pre><p></p><pre><code><span style="color:blue;"  >#endif</span>    </code></pre><p> &nbsp;</p><p></p><pre><code>#include &lt;windows.h&gt; </code></pre><p></p><pre><code>#include &lt;winsock2.h&gt; </code></pre><p></p><pre><code>#include &lt;ws2tcpip.h&gt; </code></pre><p></p><pre><code>#include &lt;iphlpapi.h&gt; </code></pre><p></p><pre><code>#include &lt;stdio.h&gt; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >#pragma</span> comment(lib, "Ws2_32.lib") </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >int</span> main() { </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 0; </code></pre><p></p><pre><code>} </code></pre><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p> &nbsp;</p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Initializing Winsock </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >All processes (applications or DLLs) that call Winsock functions must initialize the use of the Windows Sockets DLL before making other Winsock functions calls. This also makes certain that Winsock is supported on the system. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code>WSADATA wsaData; &nbsp;&nbsp;&nbsp;&nbsp;// Create a WSADATA object called wsaData. </code></pre><p></p><pre><code><span style="color:blue;"  >int</span> iResult; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Initialize Winsock</span>    </code></pre><p></p><pre><code>iResult = WSAStartup(MAKEWORD(2,2), &amp;wsaData); // Call WSAStartup and return its value as an integer and check for errors. </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (iResult != 0) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"WSAStartup failed: %d\n"</span>, iResult); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The WSAStartup function is called to initiate use of WS2_32.dll. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The WSADATA structure contains information about the Windows Sockets implementation. The MAKEWORD(2,2) parameter of WSAStartup makes a request for version 2.2 of Winsock on the system, and sets the passed version as the highest version of Windows Sockets support that the caller can use. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Creating a Socket for the Client  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >After initialization, a SOCKET object must be instantiated for use by the client. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Declare an addrinfo object that contains a sockaddr structure and initialize these values. For this application, the Internet address family is unspecified so that either an IPv6 or IPv4 address can be returned. The application requests the socket type to be a stream socket for the TCP protocol. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:blue;"  >struct</span> addrinfo *result = NULL, </code></pre><p></p><pre><code>                *ptr = NULL, </code></pre><p></p><pre><code>                hints; </code></pre><p> &nbsp;</p><p></p><pre><code>ZeroMemory( &amp;hints, <span style="color:blue;"  >sizeof</span>(hints) ); </code></pre><p></p><pre><code>hints.ai_family = AF_UNSPEC; </code></pre><p></p><pre><code>hints.ai_socktype = SOCK_STREAM; </code></pre><p></p><pre><code>hints.ai_protocol = IPPROTO_TCP; </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Call the <strong>getaddrinfo</strong> function requesting the IP address for the server name passed on the command line. The TCP port on the server that the client will connect to is defined by DEFAULT_PORT as 27015 in this sample. The getaddrinfo function returns its value as an integer that is checked for errors. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:blue;"  >#define</span> DEFAULT_PORT "27015" </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Resolve the server address and port</span>    </code></pre><p></p><pre><code>iResult = getaddrinfo(argv[1], DEFAULT_PORT, &amp;hints, &amp;result); </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (iResult != 0) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"getaddrinfo failed: %d\n"</span>, iResult); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p> &nbsp;</p><p></p><pre><code>SOCKET ConnectSocket = INVALID_SOCKET; // Create a <strong>SOCKET</strong> object called ConnectSocket. </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Call the <strong>socket</strong> function and return its value to the ConnectSocket variable. For this application, use the first IP address returned by the call to <strong>getaddrinfo</strong> that matched the address family, socket type, and protocol specified in the hints parameter. In this example, a TCP stream socket was specified with a socket type of SOCK_STREAM and a protocol of IPPROTO_TCP. The address family was left unspecified (AF_UNSPEC), so the returned IP address could be either an IPv6 or IPv4 address for the server. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >If the client application wants to connect using only IPv6 or IPv4, then the address family needs to be set to AF_INET6 for IPv6 or AF_INET for IPv4 in the hints parameter. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:green;"  >// Attempt to connect to the first address returned by</span>    </code></pre><p></p><pre><code><span style="color:green;"  >// the call to getaddrinfo</span>    </code></pre><p></p><pre><code>ptr=result; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Create a SOCKET for connecting to server</span>    </code></pre><p></p><pre><code>ConnectSocket = socket(ptr-&gt;ai_family, ptr-&gt;ai_socktype,  </code></pre><p></p><pre><code>ptr-&gt;ai_protocol); </code></pre><p> &nbsp;</p><p></p><pre><code>// Check for errors to ensure that the socket is a valid socket. </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (ConnectSocket == INVALID_SOCKET) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"Error at socket(): %ld\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>    freeaddrinfo(result); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Error detection is a key part of successful networking code. If the socket call fails, it returns INVALID_SOCKET. The if statement in the previous code is used to catch any errors that may have occurred while creating the socket. <strong>WSAGetLastError</strong> returns an error number associated with the last error that occurred. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Connecting to a Socket  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >Call the <strong>connect</strong> function, passing the created socket and the <strong>sockaddr</strong> structure as parameters. Check for general errors. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:green;"  >// Connect to server.</span>    </code></pre><p></p><pre><code>iResult = connect( ConnectSocket, ptr-&gt;ai_addr, (<span style="color:blue;"  >int</span>)ptr-&gt;ai_addrlen); </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>    closesocket(ConnectSocket); </code></pre><p></p><pre><code>    ConnectSocket = INVALID_SOCKET; </code></pre><p></p><pre><code>} </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Should really try the next address returned by getaddrinfo</span>    </code></pre><p></p><pre><code><span style="color:green;"  >// if the connect call failed</span>    </code></pre><p></p><pre><code><span style="color:green;"  >// But for this simple example we just free the resources</span>    </code></pre><p></p><pre><code><span style="color:green;"  >// returned by getaddrinfo and print an error message</span>    </code></pre><p></p><pre><code>freeaddrinfo(result); </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >if</span> (ConnectSocket == INVALID_SOCKET) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"Unable to connect to server!\n"</span>); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The <strong>getaddrinfo</strong> function is used to determine the values in the sockaddr structure. In this example, the first IP address returned by the getaddrinfo function is used to specify the sockaddr structure passed to the connect. If the connect call fails to the first IP address, then try the next addrinfo structure in the linked list returned from the getaddrinfo function. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The information specified in the <strong>sockaddr</strong> structure includes: </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    the IP address of the server that the client will try to connect to. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >the port number on the server that the client will connect to. This port was specified as port 27015 when the client called the getaddrinfo function. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Sending and Receiving Data on the Client  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >The following code demonstrates the send and recv functions used by the client once a connection is established. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p></p><pre><code><span style="color:blue;"  >#define</span> DEFAULT_BUFLEN 512 </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >int</span> recvbuflen = DEFAULT_BUFLEN; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >char</span> *sendbuf = <span style="color:#a31515;"  >"this is a test"</span>; </code></pre><p></p><pre><code><span style="color:blue;"  >char</span> recvbuf[DEFAULT_BUFLEN]; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >int</span> iResult; </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Send an initial buffer</span>    </code></pre><p></p><pre><code>iResult = send(ConnectSocket, sendbuf, (<span style="color:blue;"  >int</span>) strlen(sendbuf), 0); </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"send failed: %d\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>    closesocket(ConnectSocket); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p> &nbsp;</p><p></p><pre><code>printf(<span style="color:#a31515;"  >"Bytes Sent: %ld\n"</span>, iResult); </code></pre><p> &nbsp;</p><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// When the client is done sending data to the server,  </span></code></pre><p></p><pre><code><span style="color:green;"  >// the shutdown function can be called specifying SD_SEND to shutdown the sending side of the socket.  </span></code></pre><p></p><pre><code><span style="color:green;"  >// This allows the server to release some of the resources for this socket.  </span></code></pre><p></p><pre><code><span style="color:green;"  >// The client application can still receive data on the socket. </span></code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// shutdown the connection for sending since no more data will be sent</span>    </code></pre><p></p><pre><code><span style="color:green;"  >// the client can still use the ConnectSocket for receiving data </span></code></pre><p></p><pre><code>iResult = shutdown(ConnectSocket, SD_SEND); </code></pre><p></p><pre><code><span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>    printf(<span style="color:#a31515;"  >"shutdown failed: %d\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>    closesocket(ConnectSocket); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>} </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Receive data until the server closes the connection</span>    </code></pre><p></p><pre><code><span style="color:blue;"  >do</span> { </code></pre><p></p><pre><code>    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (iResult &gt; 0) </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"Bytes received: %d\n"</span>, iResult); </code></pre><p></p><pre><code>     <span style="color:blue;"  >else</span>     <span style="color:blue;"  >if</span> (iResult == 0) </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"Connection closed\n"</span>); </code></pre><p></p><pre><code>     <span style="color:blue;"  >else</span>    </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"recv failed: %d\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>} <span style="color:blue;"  >while</span> (iResult &gt; 0); </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// cleanup </span></code></pre><p></p><pre><code><span style="color:green;"  >// When the client application is done receiving data, the closesocket function is called to close the socket.</span>    </code></pre><p></p><pre><code>closesocket(ConnectSocket); </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// When the client application is completed using the Windows Sockets DLL, the WSACleanup function is called to release resources. </span></code></pre><p></p><pre><code>WSACleanup(); </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >return</span> 0; </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The <strong>send</strong> and <strong>recv</strong> functions both return an integer value of the number of bytes sent or received, respectively, or an error. Each function also takes the same parameters: the active socket, a char buffer, the number of bytes to send or receive, and any flags to use. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Creating a Socket for the Server  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >After initialization, a <strong>SOCKET</strong> object must be instantiated for use by the server. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>getaddrinfo</strong></span></a> function is used to determine the values in the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms740496%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>sockaddr</strong></span></a> structure: </span></p><ul><li><span style="font-family:宋体; font-size:12pt;"  ><strong>AF_INET</strong> is used to specify the IPv4 address family. </span></li><li><span style="font-family:宋体; font-size:12pt;"  ><strong>SOCK_STREAM</strong> is used to specify a stream socket. </span></li><li><span style="font-family:宋体; font-size:12pt;"  ><strong>IPPROTO_TCP</strong> is used to specify the TCP protocol . </span></li><li><span style="font-family:宋体; font-size:12pt;"  ><strong>AI_PASSIVE</strong> flag indicates the caller intends to use the returned socket address structure in a call to the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms737550%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>bind</strong></span></a> function. When the <strong>AI_PASSIVE</strong> flag is set and <em>nodename</em> parameter to the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>getaddrinfo</strong></span></a> function is a <strong>NULL</strong> pointer, the IP address portion of the socket address structure is set to <strong>INADDR_ANY</strong> for IPv4 addresses or <strong>IN6ADDR_ANY_INIT</strong> for IPv6 addresses. </span></li><li><span style="font-family:宋体; font-size:12pt;"  >27015 is the port number associated with the server that the client will connect to. </span></li></ul><p><span style="font-family:宋体; font-size:12pt;"  >The <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms737530%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>addrinfo</strong></span></a> structure is used by the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>getaddrinfo</strong></span></a> function. </span></p><p></p><pre><code>=======================================================================<span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#define</span> DEFAULT_PORT "27015" </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >struct</span> addrinfo *result = NULL, *ptr = NULL, hints; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >ZeroMemory(&amp;hints, <span style="color:blue;"  >sizeof</span> (hints)); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >hints.ai_family = AF_INET; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >hints.ai_socktype = SOCK_STREAM; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >hints.ai_protocol = IPPROTO_TCP; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >hints.ai_flags = AI_PASSIVE; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Resolve the local address and port to be used by the server</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> (iResult != 0) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf(<span style="color:#a31515;"  >"getaddrinfo failed: %d\n"</span>, iResult); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >SOCKET ListenSocket = INVALID_SOCKET; </span></p><p></p><pre><code>=======================================================================<span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  >Call the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms740506%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>socket</strong></span></a> function and return its value to the ListenSocket variable. For this server application, use the first IP address returned by the call to <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>getaddrinfo</strong></span></a> that matched the address family, socket type, and protocol specified in the <em>hints</em> parameter. In this example, a TCP stream socket for IPv4 was requested with an address family of IPv4, a socket type of SOCK_STREAM and a protocol of IPPROTO_TCP. So an IPv4 address is requested for the ListenSocket.  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >If the server application wants to listen on IPv6, then the address family needs to be set to AF_INET6 in the <em>hints</em> parameter. If a server wants to listen on both IPv6 and IPv4, two listen sockets must be created, one for IPv6 and one for IPv4. These two sockets must be handled separately by the application. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Windows&nbsp;Vista and later offer the ability to create a single IPv6 socket that is put in dual stack mode to listen on both IPv6 and IPv4. For more information on this feature, see <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb513665%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  >Dual-Stack Sockets</span></a>. </span></p><p></p><pre><code>=======================================================================<span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Create a SOCKET for the server to listen for client connections</span>   </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol); </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> (ListenSocket == INVALID_SOCKET) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf(<span style="color:#a31515;"  >"Error at socket(): %ld\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    freeaddrinfo(result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p> &nbsp;</p><p></p><pre><code>=======================================================================<span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Binding a Socket  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >For a server to accept client connections, it must be bound to a network address within the system. The following code demonstrates how to bind a socket that has already been created to an IP address and port. Client applications use the IP address and port to connect to the host network. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >The sockaddr structure holds information regarding the address family, IP address, and port number. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Call the bind function, passing the created socket and sockaddr structure returned from the getaddrinfo function as parameters. Check for general errors. </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Setup the TCP listening socket</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >iResult = bind( ListenSocket, result-&gt;ai_addr, (<span style="color:blue;"  >int</span>)result-&gt;ai_addrlen); </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >   printf(<span style="color:#a31515;"  >"bind failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >   freeaddrinfo(result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >   closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >   WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p> &nbsp;</p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// Once the bind function is called, the address information returned by the getaddrinfo function is no longer needed.  </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// The freeaddrinfo function is called to free the memory allocated by the getaddrinfo function for this address information. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >freeaddrinfo(result); </span></p><p> &nbsp;</p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Listening on a Socket  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >After the socket is bound to an IP address and port on the system, the server must then listen on that IP address and port for incoming connection requests. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >Call the <a rel="nofollow" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms739168%28v=vs.85%29.aspx"  ><span style="color:blue; text-decoration:underline;"  ><strong>listen</strong></span></a> function, passing as parameters the created socket and a value for the <em>backlog</em>, maximum length of the queue of pending connections to accept. In this example, the <em>backlog</em> parameter was set to <strong>SOMAXCONN</strong>. This value is a special constant that instructs the Winsock provider for this socket to allow a maximum reasonable number of pending connections in the queue. Check the return value for general errors. </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> ( listen( ListenSocket, SOMAXCONN ) == SOCKET_ERROR ) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf( <span style="color:#a31515;"  >"Listen failed with error: %ld\n"</span>, WSAGetLastError() ); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p> &nbsp;</p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Accepting a Connection  </strong></span></p><p></p><pre><code>Normally a server application would be designed to listen for connections from multiple clients. For high-performance servers, multiple threads are commonly used to handle the multiple client connections. </code></pre><p> &nbsp;</p><p></p><pre><code>There are several different programming techniques using Winsock that can be used to listen for multiple client connections. One programming technique is to create a continuous loop that checks for connection requests using the listen function (see Listening on a Socket). If a connection request occurs, the application calls the accept, AcceptEx, or WSAAccept function and passes the work to another thread to handle the request. Several other programming techniques are possible. </code></pre><p> &nbsp;</p><p></p><pre><code>Note that this basic example is very simple and does not use multiple threads. The example also just listens for and accepts only a single connection. </code></pre><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  >SOCKET ClientSocket; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >ClientSocket = INVALID_SOCKET; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Accept a client socket</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >ClientSocket = accept(ListenSocket, NULL, NULL); </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> (ClientSocket == INVALID_SOCKET) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf(<span style="color:#a31515;"  >"accept failed: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  >When the client connection has been accepted, a server application would normally pass the accepted client socket (the ClientSocket variable in the above sample code) to a worker thread or an I/O completion port and continue accepting additional connections. In this basic example, the server continues to the next step. </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >There are a number of other programming techniques that can be used to listen for and accept multiple connections. These include using the select or WSAPoll functions. Examples of some of these various programming techniques are illustrated in the Advanced Winsock Samples included with the Microsoft Windows Software Development Kit (SDK). </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >Note  On Unix systems, a common programming technique for servers was for an application to listen for connections. When a connection was accepted, the parent process would call the fork function to create a new child process to handle the client connection, inheriting the socket from the parent. This programming technique is not supported on Windows, since the fork function is not supported. This technique is also not usually suitable for high-performance servers, since the resources needed to create a new process are much greater than those needed for a thread. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Receiving and Sending Data on the Server  </strong></span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#define</span> DEFAULT_BUFLEN 512 </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >char</span> recvbuf[DEFAULT_BUFLEN]; </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >int</span> iResult, iSendResult; </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >int</span> recvbuflen = DEFAULT_BUFLEN; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Receive until the peer shuts down the connection</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >do</span> { </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = recv(ClientSocket, recvbuf, recvbuflen, 0); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult &gt; 0) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"Bytes received: %d\n"</span>, iResult); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Echo the buffer back to the sender</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        iSendResult = send(ClientSocket, recvbuf, iResult, 0); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iSendResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            printf(<span style="color:#a31515;"  >"send failed: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        } </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"Bytes sent: %d\n"</span>, iSendResult); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } <span style="color:blue;"  >else</span>    <span style="color:blue;"  >if</span> (iResult == 0) </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"Connection closing...\n"</span>); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >else</span> { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"recv failed: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >} <span style="color:blue;"  >while</span> (iResult &gt; 0); </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="font-family:宋体; font-size:12pt;"  >The send and recv functions both return an integer value of the number of bytes sent or received, respectively, or an error. Each function also takes the same parameters: the active socket, a char buffer, the number of bytes to send or receive, and any flags to use. </span></p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Disconnecting the Server  </strong></span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// When the server is done sending data to the client,  </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// the shutdown function can be called specifying SD_SEND to shutdown the sending side of the socket.  </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// This allows the client to release some of the resources for this socket.  </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// The server application can still receive data on the socket. </span></p><p> &nbsp;</p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// shutdown the send half of the connection since no more data will be sent </span></p><p><span style="font-family:宋体; font-size:12pt;"  >iResult = shutdown(ClientSocket, SD_SEND); </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    printf(<span style="color:#a31515;"  >"shutdown failed: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// cleanup </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// When the client application is done receiving data, the closesocket function is called to close the socket. </span></p><p><span style="color:green; font-family:宋体; font-size:12pt;"  >// When the client application is completed using the Windows Sockets DLL, the WSACleanup function is called to release resources. </span></p><p><span style="font-family:宋体; font-size:12pt;"  >closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >WSACleanup(); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >return</span> 0; </span></p><p></p><pre><code>=======================================================================    <span style="color:blue;"  >     </span></code></pre><p> &nbsp;</p><p> &nbsp;</p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Complete Winsock Client Code </strong></span></p><p></p><pre><code>=======================================================================<span style="color:blue;"  >     </span></code></pre><p></p><pre><code><span style="color:blue;"  >#define</span> WIN32_LEAN_AND_MEAN </code></pre><p> &nbsp;</p><p></p><pre><code>#include &lt;windows.h&gt; </code></pre><p></p><pre><code>#include &lt;winsock2.h&gt; </code></pre><p></p><pre><code>#include &lt;ws2tcpip.h&gt; </code></pre><p></p><pre><code>#include &lt;stdlib.h&gt; </code></pre><p></p><pre><code>#include &lt;stdio.h&gt; </code></pre><p> &nbsp;</p><p> &nbsp;</p><p></p><pre><code><span style="color:green;"  >// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib</span>    </code></pre><p></p><pre><code><span style="color:blue;"  >#pragma</span> comment (lib, "Ws2_32.lib") </code></pre><p></p><pre><code><span style="color:blue;"  >#pragma</span> comment (lib, "Mswsock.lib") </code></pre><p></p><pre><code><span style="color:blue;"  >#pragma</span> comment (lib, "AdvApi32.lib") </code></pre><p> &nbsp;</p><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >#define</span> DEFAULT_BUFLEN 512 </code></pre><p></p><pre><code><span style="color:blue;"  >#define</span> DEFAULT_PORT "27015" </code></pre><p> &nbsp;</p><p></p><pre><code><span style="color:blue;"  >int</span> __cdecl main(<span style="color:blue;"  >int</span> argc, <span style="color:blue;"  >char</span> **argv)  </code></pre><p></p><pre><code>{ </code></pre><p></p><pre><code>    WSADATA wsaData; </code></pre><p></p><pre><code>    SOCKET ConnectSocket = INVALID_SOCKET; </code></pre><p></p><pre><code>     <span style="color:blue;"  >struct</span> addrinfo *result = NULL, </code></pre><p></p><pre><code>                    *ptr = NULL, </code></pre><p></p><pre><code>                    hints; </code></pre><p></p><pre><code>     <span style="color:blue;"  >char</span> *sendbuf = <span style="color:#a31515;"  >"this is a test"</span>; </code></pre><p></p><pre><code>     <span style="color:blue;"  >char</span> recvbuf[DEFAULT_BUFLEN]; </code></pre><p></p><pre><code>     <span style="color:blue;"  >int</span> iResult; </code></pre><p></p><pre><code>     <span style="color:blue;"  >int</span> recvbuflen = DEFAULT_BUFLEN; </code></pre><p>     &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Validate the parameters</span>    </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (argc != 2) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"usage: %s server-name\n"</span>, argv[0]); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Initialize Winsock</span>    </code></pre><p></p><pre><code>    iResult = WSAStartup(MAKEWORD(2,2), &amp;wsaData); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (iResult != 0) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"WSAStartup failed with error: %d\n"</span>, iResult); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>    ZeroMemory( &amp;hints, <span style="color:blue;"  >sizeof</span>(hints) ); </code></pre><p></p><pre><code>    hints.ai_family = AF_UNSPEC; </code></pre><p></p><pre><code>    hints.ai_socktype = SOCK_STREAM; </code></pre><p></p><pre><code>    hints.ai_protocol = IPPROTO_TCP; </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Resolve the server address and port</span>    </code></pre><p></p><pre><code>    iResult = getaddrinfo(argv[1], DEFAULT_PORT, &amp;hints, &amp;result); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> ( iResult != 0 ) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"getaddrinfo failed with error: %d\n"</span>, iResult); </code></pre><p></p><pre><code>        WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Attempt to connect to an address until one succeeds</span>    </code></pre><p></p><pre><code>     <span style="color:blue;"  >for</span>(ptr=result; ptr != NULL ;ptr=ptr-&gt;ai_next) { </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Create a SOCKET for connecting to server</span>    </code></pre><p></p><pre><code>        ConnectSocket = socket(ptr-&gt;ai_family, ptr-&gt;ai_socktype,  </code></pre><p></p><pre><code>            ptr-&gt;ai_protocol); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (ConnectSocket == INVALID_SOCKET) { </code></pre><p></p><pre><code>            printf(<span style="color:#a31515;"  >"socket failed with error: %ld\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>            WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>        } </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Connect to server.</span>    </code></pre><p></p><pre><code>        iResult = connect( ConnectSocket, ptr-&gt;ai_addr, (<span style="color:blue;"  >int</span>)ptr-&gt;ai_addrlen); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>            closesocket(ConnectSocket); </code></pre><p></p><pre><code>            ConnectSocket = INVALID_SOCKET; </code></pre><p></p><pre><code>     <span style="color:blue;"  >continue</span>; </code></pre><p></p><pre><code>        } </code></pre><p></p><pre><code>     <span style="color:blue;"  >break</span>; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>    freeaddrinfo(result); </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:blue;"  >if</span> (ConnectSocket == INVALID_SOCKET) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"Unable to connect to server!\n"</span>); </code></pre><p></p><pre><code>        WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Send an initial buffer</span>    </code></pre><p></p><pre><code>    iResult = send( ConnectSocket, sendbuf, (<span style="color:blue;"  >int</span>)strlen(sendbuf), 0 ); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"send failed with error: %d\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>        closesocket(ConnectSocket); </code></pre><p></p><pre><code>        WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>    printf(<span style="color:#a31515;"  >"Bytes Sent: %ld\n"</span>, iResult); </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// shutdown the connection since no more data will be sent</span>    </code></pre><p></p><pre><code>    iResult = shutdown(ConnectSocket, SD_SEND); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </code></pre><p></p><pre><code>        printf(<span style="color:#a31515;"  >"shutdown failed with error: %d\n"</span>, WSAGetLastError()); </code></pre><p></p><pre><code>        closesocket(ConnectSocket); </code></pre><p></p><pre><code>        WSACleanup(); </code></pre><p></p><pre><code>     <span style="color:blue;"  >return</span> 1; </code></pre><p></p><pre><code>    } </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// Receive until the peer closes the connection</span>    </code></pre><p></p><pre><code>     <span style="color:blue;"  >do</span> { </code></pre><p> &nbsp;</p><p></p><pre><code>        iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0); </code></pre><p></p><pre><code>     <span style="color:blue;"  >if</span> ( iResult &gt; 0 ) </code></pre><p></p><pre><code>            printf(<span style="color:#a31515;"  >"Bytes received: %d\n"</span>, iResult); </code></pre><p></p><pre><code>     <span style="color:blue;"  >else</span>     <span style="color:blue;"  >if</span> ( iResult == 0 ) </code></pre><p></p><pre><code>            printf(<span style="color:#a31515;"  >"Connection closed\n"</span>); </code></pre><p></p><pre><code>     <span style="color:blue;"  >else</span>    </code></pre><p></p><pre><code>            printf(<span style="color:#a31515;"  >"recv failed with error: %d\n"</span>, WSAGetLastError()); </code></pre><p> &nbsp;</p><p></p><pre><code>    } <span style="color:blue;"  >while</span>( iResult &gt; 0 ); </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:green;"  >// cleanup</span>    </code></pre><p></p><pre><code>    closesocket(ConnectSocket); </code></pre><p></p><pre><code>    WSACleanup(); </code></pre><p> &nbsp;</p><p></p><pre><code>     <span style="color:blue;"  >return</span> 0; </code></pre><p></p><pre><code>} </code></pre><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:18pt;"  ><strong>Complete Winsock Server Code  </strong></span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#undef</span> UNICODE </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#define</span> WIN32_LEAN_AND_MEAN </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;windows.h&gt; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;winsock2.h&gt; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;ws2tcpip.h&gt; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;stdlib.h&gt; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >#include &lt;stdio.h&gt; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// Need to link with Ws2_32.lib</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#pragma</span> comment (lib, "Ws2_32.lib") </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:green;"  >// #pragma comment (lib, "Mswsock.lib")</span>   </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#define</span> DEFAULT_BUFLEN 512 </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >#define</span> DEFAULT_PORT "27015" </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  ><span style="color:blue;"  >int</span> __cdecl main(<span style="color:blue;"  >void</span>)  </span></p><p><span style="font-family:宋体; font-size:12pt;"  >{ </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSADATA wsaData; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >int</span> iResult; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    SOCKET ListenSocket = INVALID_SOCKET; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    SOCKET ClientSocket = INVALID_SOCKET; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >struct</span> addrinfo *result = NULL; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >struct</span> addrinfo hints; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >int</span> iSendResult; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >char</span> recvbuf[DEFAULT_BUFLEN]; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >int</span> recvbuflen = DEFAULT_BUFLEN; </span></p><p>     &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Initialize Winsock</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = WSAStartup(MAKEWORD(2,2), &amp;wsaData); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult != 0) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"WSAStartup failed with error: %d\n"</span>, iResult); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    ZeroMemory(&amp;hints, <span style="color:blue;"  >sizeof</span>(hints)); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    hints.ai_family = AF_INET; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    hints.ai_socktype = SOCK_STREAM; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    hints.ai_protocol = IPPROTO_TCP; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    hints.ai_flags = AI_PASSIVE; </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Resolve the server address and port</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> ( iResult != 0 ) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"getaddrinfo failed with error: %d\n"</span>, iResult); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Create a SOCKET for connecting to server</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (ListenSocket == INVALID_SOCKET) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"socket failed with error: %ld\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        freeaddrinfo(result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Setup the TCP listening socket</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = bind( ListenSocket, result-&gt;ai_addr, (<span style="color:blue;"  >int</span>)result-&gt;ai_addrlen); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"bind failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        freeaddrinfo(result); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    freeaddrinfo(result); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = listen(ListenSocket, SOMAXCONN); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"listen failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Accept a client socket</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    ClientSocket = accept(ListenSocket, NULL, NULL); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (ClientSocket == INVALID_SOCKET) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"accept failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        closesocket(ListenSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// No longer need server socket</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    closesocket(ListenSocket); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Receive until the peer shuts down the connection</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >do</span> { </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >        iResult = recv(ClientSocket, recvbuf, recvbuflen, 0); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult &gt; 0) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            printf(<span style="color:#a31515;"  >"Bytes received: %d\n"</span>, iResult); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// Echo the buffer back to the sender</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            iSendResult = send( ClientSocket, recvbuf, iResult, 0 ); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iSendResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >                printf(<span style="color:#a31515;"  >"send failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >                closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >                WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            } </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            printf(<span style="color:#a31515;"  >"Bytes sent: %d\n"</span>, iSendResult); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        } </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >else</span>    <span style="color:blue;"  >if</span> (iResult == 0) </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            printf(<span style="color:#a31515;"  >"Connection closing...\n"</span>); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >else</span>  { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            printf(<span style="color:#a31515;"  >"recv failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >            WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    } <span style="color:blue;"  >while</span> (iResult &gt; 0); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// shutdown the connection since we're done</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    iResult = shutdown(ClientSocket, SD_SEND); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >if</span> (iResult == SOCKET_ERROR) { </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        printf(<span style="color:#a31515;"  >"shutdown failed with error: %d\n"</span>, WSAGetLastError()); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >        WSACleanup(); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 1; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    } </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:green;"  >// cleanup</span>   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    closesocket(ClientSocket); </span></p><p><span style="font-family:宋体; font-size:12pt;"  >    WSACleanup(); </span></p><p> &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >    <span style="color:blue;"  >return</span> 0; </span></p><p><span style="font-family:宋体; font-size:12pt;"  >} </span></p><p><span style="font-family:宋体; font-size:12pt;"  >======================================================================= </span></p>
</body></html>