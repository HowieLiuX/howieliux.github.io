<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：结构体对齐详解</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>结构体对齐详解</h2>
<p align="right">发布时间：2014-1-16 17:28
<br>分类名称：C++</p><br>
 
<p style="BACKGROUND: white;"   >From: <a rel="nofollow" href="http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html"   >http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html</a> </p>
<p style="BACKGROUND: white;"   >注释：本文通过仔细阅读，还是发现一些问题。在此，我总结出更加精炼的法则：</p>
<p style="BACKGROUND: white;"   >1. 对齐数据成员，对齐模数为：#pragma pack指定的数值以及该数据成员自身长度中数值较小者。对齐成员有两种，一种是普通数据类型，一种的结构体类型。<font face="宋体"   >结构体的长度计算为：结构体内部最大的基本数据类型成员长度。所以即便是结构体类型，</font><font face="Arial"   >对齐模数也同样适用。如果觉得复杂，可以先将所有的结构体平铺展开，再计算。</font></p>
<p style="BACKGROUND: white;"   >2. 所有的数据成员对齐后，再对齐最外层的结构体，如何对齐？还是参加第一条。再一次声明：<font face="宋体"   >结构体的长度计算为：结构体内部最大的基本数据类型成员长度。取该长度和</font><font face="Arial"   >#pragma pack指定的数值中数值较小者。</font></p>
<p style="BACKGROUND: white;"   >还要记住一文章中的那张表：</p>
<p style="BACKGROUND: white;"   >
<table border="0"   >
<colgroup>
<col>
<col>
<col>
<col>
<col>
<col>
<col>
<col>
<tbody valign="top"   >
<tr>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >&nbsp;&nbsp;</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >&nbsp;&nbsp;</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >char</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >short</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >int</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >long</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >double</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >long <br></p><p style="TEXT-INDENT: 2em;"   >double</p></td></tr>
<tr>
<td rowspan="2"   valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >Windows</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >长</p><p style="TEXT-INDENT: 2em;"   >度</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >1</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >2</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >8</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >8</p></td></tr>
<tr>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >模</p><p style="TEXT-INDENT: 2em;"   >数</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >1</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >2</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >8</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >8</p></td></tr>
<tr>
<td rowspan="2"   valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >Linux</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >长</p><p style="TEXT-INDENT: 2em;"   >度</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >1</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >2</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >8</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >12</p></td></tr>
<tr>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >模数</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >1</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >2</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td>
<td valign="middle"   >
<p style="TEXT-INDENT: 2em;"   >4</p></td></tr></table></p>
<p style="BACKGROUND: white;"   >就OK了。</p>
<p style="BACKGROUND: white;"   >&nbsp;</p>
<p style="BACKGROUND: white;"   >以下是原文：</p>
<p style="BACKGROUND: white;"   ><span style="FONT-SIZE: 11pt;"   ><span style="COLOR: #e3940b;"   ><span style="FONT-FAMILY: Courier;"   >1 -- </span><span style="FONT-FAMILY: 宋体;"   >结构体数据成员对齐的意义</span><span style="FONT-FAMILY: Courier;"   ><br></span></span><span style="FONT-FAMILY: 宋体;"   >许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的起始地址的值是某个数</span><span style="FONT-FAMILY: Courier;"   >k</span><span style="FONT-FAMILY: 宋体;"   >的倍数，这就是所谓的内存对齐，而这个</span><span style="FONT-FAMILY: Courier;"   >k</span><span style="FONT-FAMILY: 宋体;"   >则被称为该数据类型的对齐模数</span><span style="FONT-FAMILY: Courier;"   >(alignment modulus)</span><span style="FONT-FAMILY: 宋体;"   >。这种强制的要求一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度。比如这么一种处理器，它每次读写内存的时候都从某个</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >倍数的地址开始，一次读出或写入</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >个字节的数据，假如软件能保证</span><span style="FONT-FAMILY: Courier;"   >double</span><span style="FONT-FAMILY: 宋体;"   >类型的数据都从</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >倍数地址开始，那么读或写一个</span><span style="FONT-FAMILY: Courier;"   >double</span><span style="FONT-FAMILY: 宋体;"   >类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >字节内存块上。</span><span style="FONT-FAMILY: Courier;"   ><br><span style="COLOR: #e3940b;"   >2 -- </span></span><span style="FONT-FAMILY: 宋体;"   >结构体对齐包括两个方面的含义</span><span style="FONT-FAMILY: Courier; COLOR: #e3940b;"   ><br></span><span style="FONT-FAMILY: Courier;"   >1)</span><span style="FONT-FAMILY: 宋体;"   >结构体总长度</span><span style="FONT-FAMILY: Courier;"   > <br>2)</span><span style="FONT-FAMILY: 宋体;"   >结构体内各数据成员的内存对齐，即该数据成员相对结构体的起始位置</span><span style="FONT-FAMILY: Courier;"   > <br><span style="COLOR: #e3940b;"   >3 -- </span></span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier; COLOR: #e3940b;"   ><br></span><span style="FONT-FAMILY: Courier;"   >1)</span><span style="FONT-FAMILY: 宋体;"   >将结构体内所有数据成员的长度值相加，记为</span><span style="FONT-FAMILY: Courier;"   >sum_a</span><span style="FONT-FAMILY: 宋体;"   >；</span><span style="FONT-FAMILY: Courier;"   > <br>2)</span><span style="FONT-FAMILY: 宋体;"   >将各数据成员为了内存对齐，按各自对齐模数而填充的字节数累加到和</span><span style="FONT-FAMILY: Courier;"   >sum_a</span><span style="FONT-FAMILY: 宋体;"   >上，记为</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >。对齐模数是</span><span style="FONT-FAMILY: Courier;"   >#pragma pack</span><span style="FONT-FAMILY: 宋体;"   >指定的数值以及该数据成员自身长度中数值较小者。该数据相对起始位置应该是对齐模式的整数倍</span><span style="FONT-FAMILY: Courier;"   >; <br>3)</span><span style="FONT-FAMILY: 宋体;"   >将和</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >向结构体模数对齐，该模数是</span><span style="FONT-FAMILY: Courier;"   >#pragma pac</span><span style="FONT-FAMILY: 宋体;"   >指定的数值和结构体内部最大的基本数据类型成员长度中数值较小者。结构体的长度应该是该模数的整数倍。</span><span style="FONT-FAMILY: Courier;"   > <br><span style="COLOR: #e3940b;"   >4 -- </span></span><span style="FONT-FAMILY: 宋体;"   >结构体大小计算举例</span><span style="FONT-FAMILY: Courier; COLOR: #e3940b;"   ><br></span><span style="FONT-FAMILY: 宋体;"   >在计算之前，我们首先需要明确的是各个数据成员的对齐模数，对齐模数和数据成员本身的长度以及</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >编译参数有关，其值是二者中最小数。如果程序没有明确指出，就需要知道编译器默认的对齐模数值。下表是</span><span style="FONT-FAMILY: Courier;"   >Windows XP/DEV-C++</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Linux/GCC</span><span style="FONT-FAMILY: 宋体;"   >中基本数据类型的长度和默认对齐模数。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: Cambria;"   >&nbsp;</span></span> </p>
<div>
<table style="BORDER-COLLAPSE: collapse;"   border="0"   >
<colgroup>
<col style="WIDTH: 87px;"   >
<col style="WIDTH: 45px;"   >
<col style="WIDTH: 53px;"   >
<col style="WIDTH: 64px;"   >
<col style="WIDTH: 42px;"   >
<col style="WIDTH: 53px;"   >
<col style="WIDTH: 76px;"   >
<col style="WIDTH: 133px;"   >
<tbody valign="top"   >
<tr>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: silver 0.75pt solid; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Cambria;"   >&nbsp;</span>&nbsp;</p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Cambria;"   >&nbsp;</span>&nbsp;</p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >char</span></p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >short</span></p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >int</span></p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >long</span></p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >double</span></p></td>
<td style="BORDER-TOP: silver 0.75pt solid; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >long double</span></p></td></tr>
<tr>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: silver 0.75pt solid; PADDING-RIGHT: 3px;"   rowspan="2"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >Windows</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: 宋体;"   >长度</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >1</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >2</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >8</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >8</span></p></td></tr>
<tr>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: silver 0.75pt solid; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: 宋体;"   >模数</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >1</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >2</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >8</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >8</span></p></td></tr>
<tr>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: silver 0.75pt solid; PADDING-RIGHT: 3px;"   rowspan="2"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >Linux</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: 宋体;"   >长度</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >1</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >2</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >8</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >12</span></p></td></tr>
<tr>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: silver 0.75pt solid; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: 宋体;"   >模数</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >1</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >2</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td>
<td style="BORDER-TOP: medium none; BORDER-RIGHT: silver 0.75pt solid; BORDER-BOTTOM: silver 0.75pt solid; PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 3px; BORDER-LEFT: medium none; PADDING-RIGHT: 3px;"   valign="middle"   >
<p><span style="FONT-SIZE: 11pt; FONT-FAMILY: Courier;"   >4</span></p></td></tr></table></div>
<p><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Cambria;"   >&nbsp;</span><span style="FONT-FAMILY: Courier;"   ><br></span><span style="COLOR: red;"   ><strong><span style="FONT-FAMILY: 宋体;"   >例子</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：</span></strong></span><span style="FONT-FAMILY: Courier;"   > <br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >struct my_struct <br>{ <br>char a; <br>long double b; <br>};<br></span><span style="FONT-SIZE: 11pt;"   >此例子</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >计算方法有些许不一致。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 8B = 9B --&gt; sum_a = 9B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >7</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 7 = 16B --&gt; sum_b = 16 B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >的</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >倍，不需再次对齐。</span><span style="FONT-FAMILY: Courier;"   > <font color="#ff00ff"   >（这里我觉得有问题，4是怎么来的，我觉得应该是8，下来还是16）</font><br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >16B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >1-1</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 12B = 13B --&gt; sum_a = 13B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 3 = 16B --&gt; sum_b = 16 B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >12</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >的</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >倍，不需再次对齐。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >16B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >1-2</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br><a rel="nofollow" href="http://www.cnblogs.com/motadou/admin/$1-1%5b13%5d.jpg"   ><img title="结构体对齐详解 - Howie - Dspace"   alt=""   src="pic/img0.ph.126.net_Uprbdqt5DcB_BopqHmHdzg==_6608250700398969750.jpg"   border="0"   ></a><br><br></span><span style="COLOR: red;"   ><strong><span style="FONT-FAMILY: 宋体;"   >例子</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：</span></strong></span><span style="FONT-FAMILY: Courier;"   > <br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >#pragma pack(2) <br>struct my_struct <br>{ <br>char a; <br>long double b; <br>}; <br>#pragma pack()<br></span><span style="FONT-SIZE: 11pt;"   >例子</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >和例子</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >不同之处在于例子</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >中使用了</span><span style="FONT-FAMILY: Courier;"   >#pragma pack(2)</span><span style="FONT-FAMILY: 宋体;"   >编译参数，它强制指定对齐模数是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >。此例子</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >计算方法有些许不一致。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 8B = 13B --&gt; sum_a = 9B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 1 = 10B --&gt; sum_b = 10 B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >的</span><span style="FONT-FAMILY: Courier;"   >5</span><span style="FONT-FAMILY: 宋体;"   >倍，不需再次对齐。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >10B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >2-1</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 12B = 13B --&gt; sum_a = 13B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 1 = 14B --&gt; sum_b = 14 B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >的</span><span style="FONT-FAMILY: Courier;"   >7</span><span style="FONT-FAMILY: 宋体;"   >倍，不需再次对齐。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >14B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >2-2</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br><a rel="nofollow" href="http://www.cnblogs.com/motadou/admin/$2%5b4%5d.jpg"   ><img title="结构体对齐详解 - Howie - Dspace"   alt=""   src="pic/img2.ph.126.net_Dr5ih39zOs6fOpqOdFP2ng==_3306486551520264233.jpg"   border="0"   ></a><br><br></span><span style="COLOR: red;"   ><strong><span style="FONT-FAMILY: 宋体;"   >例子</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：</span></strong></span><span style="FONT-FAMILY: Courier;"   > <br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >struct my_struct <br>{ <br>char a; <br>double b; <br>char c; <br>}; <br></span><span style="FONT-SIZE: 11pt;"   >前两例中，数据成员在</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >下都相同，例</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >中</span><span style="FONT-FAMILY: Courier;"   >double</span><span style="FONT-FAMILY: 宋体;"   >的对齐模数在</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >中是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，在</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >下是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，针对这种模数不相同的情况加以分析。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 8B + 1B = 10B --&gt; sum_a = 10B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >7</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 7 = 17B --&gt; sum_b = 17B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >应该是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >的整数倍，所以要在结构体后填充</span><span style="FONT-FAMILY: Courier;"   >8*3 - 17 = 7</span><span style="FONT-FAMILY: 宋体;"   >个字节。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >24B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >3-1</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >中计算步骤如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >1B + 8B + 1B = 10B</span><span style="FONT-FAMILY: 宋体;"   >，</span><span style="FONT-FAMILY: Courier;"   >sum_a = 10B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_b = sum_a + 3 = 13B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma <br>pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >应该是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >的整数倍，所以要在结构体后填充</span><span style="FONT-FAMILY: Courier;"   >4*4 - 13 = 3</span><span style="FONT-FAMILY: 宋体;"   >个字节。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >16B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >3-2</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br><a rel="nofollow" href="http://www.cnblogs.com/motadou/admin/$3%5b6%5d.jpg"   ><img title="结构体对齐详解 - Howie - Dspace"   alt=""   src="pic/img0.ph.126.net_vmGcFvyEf8Qs9r04DsCGlw==_3673529921150809077.jpg"   border="0"   ></a><br><br></span><span style="COLOR: red;"   ><strong><span style="FONT-FAMILY: 宋体;"   >例子</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >：</span></strong></span><span style="FONT-FAMILY: Courier;"   > <br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >struct my_struct <br>{ <br>char a[11]; <br>int b; <br>char c; <br>}; <br></span><span style="FONT-SIZE: 11pt;"   >此例子</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >计算方法一样，如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >11B + 4B + 1B = 16B --&gt; sum_a = 16B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >a</span><span style="FONT-FAMILY: 宋体;"   >放在相对偏移</span><span style="FONT-FAMILY: Courier;"   >0</span><span style="FONT-FAMILY: 宋体;"   >处，之前不需要填充字节；数据成员</span><span style="FONT-FAMILY: Courier;"   >b</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_a + 1 = 17B --&gt; sum_b = 17B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >的整数倍，需在结构体后填充</span><span style="FONT-FAMILY: Courier;"   >4*5 - 17 = 1</span><span style="FONT-FAMILY: 宋体;"   >个字节。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >20B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br><a rel="nofollow" href="http://www.cnblogs.com/motadou/admin/$4%5b5%5d.jpg"   ><img title="结构体对齐详解 - Howie - Dspace"   alt=""   src="pic/img0.ph.126.net_a4_5z0BogSVvwfF4XJhwQA==_870320628089412090.jpg"   border="0"   ></a><br><br></span><span style="COLOR: red;"   ><strong><span style="FONT-FAMILY: 宋体;"   >例子</span><span style="FONT-FAMILY: Courier;"   >5</span><span style="FONT-FAMILY: 宋体;"   >：</span></strong></span><span style="FONT-FAMILY: Courier;"   > <br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >struct my_test <br>{ <br>int my_test_a; <br>char my_test_b; <br>}; <br>struct my_struct <br>{ <br>struct my_test a; <br>double my_struct_a; <br>int my_struct_b; <br>char my_struct_c; <br>}; <br></span><span style="FONT-SIZE: 11pt;"   >例子</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >5</span><span style="FONT-FAMILY: 宋体;"   >和前几个例子均不同，在此例子中我们要计算</span><span style="FONT-FAMILY: Courier;"   >struct my_struct</span><span style="FONT-FAMILY: 宋体;"   >的大小，而</span><span style="FONT-FAMILY: Courier;"   >my_struct</span><span style="FONT-FAMILY: 宋体;"   >中嵌套了一个</span><span style="FONT-FAMILY: Courier;"   >my_test</span><span style="FONT-FAMILY: 宋体;"   >结构体。这种结构体应该如何计算呢？原则是将</span><span style="FONT-FAMILY: Courier;"   >my_test</span><span style="FONT-FAMILY: 宋体;"   >在</span><span style="FONT-FAMILY: Courier;"   >my_struct</span><span style="FONT-FAMILY: 宋体;"   >中先展开，然后再计算，即是展开成如下结构体：</span><span style="FONT-FAMILY: Courier;"   ><br></span></span><span style="FONT-FAMILY: 宋体;"   ><span style="FONT-SIZE: 12pt;"   >struct my_struct<br>{<br>int my_test_a;<br>char my_test_b;<br>double my_struct_a;<br>int my_struct_b;<br>char my_struct_c;<br>}; <br></span><span style="FONT-SIZE: 11pt;"   >此例子</span></span><span style="FONT-SIZE: 11pt;"   ><span style="FONT-FAMILY: Courier;"   >Windows</span><span style="FONT-FAMILY: 宋体;"   >中的计算方法如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >4B + 1B + 8B + 4B + 1B= 18B --&gt; sum_a = 18B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >my_struct_a</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >个字节：</span><span style="FONT-FAMILY: Courier;"   >sum_a + 3 = 21B --&gt; sum_b = 21B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >8</span><span style="FONT-FAMILY: 宋体;"   >的整数倍，需在结构体后填充</span><span style="FONT-FAMILY: Courier;"   >3*8 - 21 = 3</span><span style="FONT-FAMILY: 宋体;"   >个字节。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >24B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >5</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br></span><span style="FONT-FAMILY: 宋体;"   >此例子</span><span style="FONT-FAMILY: Courier;"   >Linux</span><span style="FONT-FAMILY: 宋体;"   >中的计算方法如下：</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >1</span><span style="FONT-FAMILY: 宋体;"   >：所有数据成员自身长度和：</span><span style="FONT-FAMILY: Courier;"   >4B + 1B + 8B + 4B + 1B= 18B</span><span style="FONT-FAMILY: 宋体;"   >，</span><span style="FONT-FAMILY: Courier;"   >sum_a = 18B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >2</span><span style="FONT-FAMILY: 宋体;"   >：数据成员</span><span style="FONT-FAMILY: Courier;"   >my_struct_a</span><span style="FONT-FAMILY: 宋体;"   >为了内存对齐，根据</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >结构体大小的计算方法和步骤</span><span style="FONT-FAMILY: Courier;"   >"</span><span style="FONT-FAMILY: 宋体;"   >中第二条原则，其对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，之前需填充</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >个字节，</span><span style="FONT-FAMILY: Courier;"   >sum_b = sum_a + 3 = 21B <br></span><span style="FONT-FAMILY: 宋体;"   >步骤</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >：按照定义，结构体对齐模数是结构体内部最大数据成员长度和</span><span style="FONT-FAMILY: Courier;"   >pragma <br>pack</span><span style="FONT-FAMILY: 宋体;"   >中较小者，前者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >后者为</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >，所以结构体对齐模数是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >。</span><span style="FONT-FAMILY: Courier;"   >sum_b</span><span style="FONT-FAMILY: 宋体;"   >是</span><span style="FONT-FAMILY: Courier;"   >4</span><span style="FONT-FAMILY: 宋体;"   >的整数倍，需在结构体后填充</span><span style="FONT-FAMILY: Courier;"   >6*4 - 21 = 3</span><span style="FONT-FAMILY: 宋体;"   >个字节。</span><span style="FONT-FAMILY: Courier;"   > <br></span><span style="FONT-FAMILY: 宋体;"   >综上</span><span style="FONT-FAMILY: Courier;"   >3</span><span style="FONT-FAMILY: 宋体;"   >步，可知结构体的长度是</span><span style="FONT-FAMILY: Courier;"   >24B</span><span style="FONT-FAMILY: 宋体;"   >，各数据成员在内存中的分布如图</span><span style="FONT-FAMILY: Courier;"   >5</span><span style="FONT-FAMILY: 宋体;"   >所示。</span><span style="FONT-FAMILY: Courier;"   > <br><br><a rel="nofollow" href="http://www.cnblogs.com/motadou/admin/$5%5b5%5d.jpg"   ><img title="结构体对齐详解 - Howie - Dspace"   alt=""   src="pic/img1.ph.126.net_1Udtz2N_U31luljbPdZVTA==_4946922715789908649.jpg"   border="0"   ></a><br><span style="COLOR: #e3940b;"   >5 -- </span></span><span style="FONT-FAMILY: 宋体;"   >源代码附录</span><span style="FONT-FAMILY: Courier; COLOR: #e3940b;"   ><br></span><span style="FONT-FAMILY: 宋体;"   >上面的例子均在</span><span style="FONT-FAMILY: Courier;"   >Windows(VC++6.0)</span><span style="FONT-FAMILY: 宋体;"   >和</span><span style="FONT-FAMILY: Courier;"   >Linux(GCC4.1.0)</span><span style="FONT-FAMILY: 宋体;"   >上测试验证。下面是测试程序。</span><span style="FONT-FAMILY: Courier;"   ><br></span></span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   >#include &lt;iostream&gt;<br><br>int main()<br>{<br>//////////////////////////////////////////////////////////////////////////////////////////<br>// 例子1<br>{<br>struct my_struct <br>{ <br>char a; <br>long double b; <br>};<br>std::cout &lt;&lt; "exapmle-1: sizeof(my_struct) = " &lt;&lt; sizeof(my_struct) &lt;&lt; std::endl;<br><br>struct my_struct data;<br><br>printf("my_struct-&gt;a: %u\n"<br>"my_struct-&gt;b: %u\n"<br>"sizeof(long double): %u\n", &amp;data.a, &amp;data.b, sizeof(long double));<br><br>}<br>//////////////////////////////////////////////////////////////////////////////////////////<br>// 例子2<br>{<br>#pragma pack(2) <br>struct my_struct <br>{ <br>char a; <br>long double b; <br>}; <br>#pragma pack()<br>struct my_struct data;<br><br>std::cout &lt;&lt; "exapmle-2: sizeof(my_struct) = " &lt;&lt; sizeof(my_struct) &lt;&lt; std::endl;<br><br>printf("my_struct-&gt;a: %u\n"<br>"my_struct-&gt;b: %u\n"<br>"sizeof(long double): %u\n", &amp;data.a, &amp;data.b, sizeof(long double));<br>}<br>//////////////////////////////////////////////////////////////////////////////////////////<br>// 例子3<br>{<br>struct my_struct <br>{ <br>char a; <br>double b; <br>char c; <br>}; <br><br>struct my_struct data;<br><br>std::cout &lt;&lt; "exapmle-3: sizeof(my_struct) = " &lt;&lt; sizeof(my_struct) &lt;&lt; std::endl;<br><br>printf("my_struct-&gt;a: %u\n"<br>"my_struct-&gt;b: %u\n"<br>"my_struct-&gt;c: %u\n", &amp;data.a, &amp;data.b, &amp;data.c);<br>}<br><br>//////////////////////////////////////////////////////////////////////////////////////////<br>// 例子4<br>{<br>struct my_struct <br>{ <br>char a[11]; <br>int b; <br>char c; <br>};<br><br>std::cout &lt;&lt; "example-4: sizeof(my_struct) = " &lt;&lt; sizeof(struct my_struct) &lt;&lt; std::endl;<br><br>struct my_struct data;<br>printf("my_struct-&gt;a: %u\n"<br>"my_struct-&gt;b: %u\n"<br>"my_struct-&gt;c: %u\n", &amp;data, &amp;data.b, &amp;data.c);<br>}<br><br>//////////////////////////////////////////////////////////////////////////////////////////<br>// 例子5 <br>{<br>struct my_test <br>{ <br>int my_test_a; <br>char my_test_b; <br>}; <br>struct my_struct <br>{ <br>struct my_test a; <br>double my_struct_a; <br>int my_struct_b; <br>char my_struct_c; <br>}; <br>std::cout &lt;&lt; "example-5: sizeof(my_struct) = " &lt;&lt; sizeof(struct my_struct) &lt;&lt; std::endl;<br><br>struct my_struct data;<br>printf("my_struct-&gt;my_test_a : %u\n"<br>"my_struct-&gt;my_test_b : %u\n"<br>"my_struct-&gt;my_struct_a: %u\n"<br>"my_struct-&gt;my_struct_b: %u\n"<br>"my_struct-&gt;my_struct_c: %u\n", &amp;data.a.my_test_a, &amp;data.a.my_test_b, <br>&amp;data.my_struct_a, &amp;data.my_struct_b, &amp;data.my_struct_c);<br><br>}<br><br><br>return 0;<br>}<br></span><br><br></p>
</body></html>