<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：How the System Finds and Loads (WDM) Drivers</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>How the System Finds and Loads (WDM) Drivers</h2>
<p align="right">发布时间：2014-5-12 20:14
<br>分类名称：Driver</p><br>
<ol><li>A <strong>Plug and Play device</strong> has an <strong>electronic signature</strong> that the system can detect. For Plug and Play devices, a system bus driver detects the existence of the hardware and reads the signature to determine what kind of hardware it is. Thereafter, an automatic process based on the <strong>registry and INF files </strong>allows the system to load the right driver.
</li><li>A<strong> legacy device</strong> does not have any electronic signature, so the system can't detect it automatically. The end user must therefore initiate the "<strong>detection</strong>" <strong>process</strong> by invoking the <strong>Add New Hardware Wizard</strong>, which ends with the system knowing that a certain new piece of hardware exists. Thereafter, the system uses the same automatic <strong>registry-and-INF-file</strong> process that's used for Plug and Play devices to load the right driver.
</li></ol><p>
&nbsp;</p><p><span style="font-size:12pt;"   ><strong><em>Installing a Plug and Play device</em>
</strong></span></p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img1.ph.126.net_G6bppYHzEiz94jP4V1BDpQ==_6599327064029136433.jpg"   alt=""   >
</p><p>
&nbsp;</p><p>When a <strong>bus driver</strong> detects the <strong>insertion</strong> or <strong>removal</strong> of hardware, it calls <strong><em>IoInvalidateDeviceRelations</em></strong> to notify the <strong>PnP Manager</strong> that the bus's population of child devices has changed. To obtain an updated list of the PDOs for the child devices, the PnP Manager sends an IRP to the bus driver. The major function code for this IRP is <em>IRP_MJ_PNP</em>, and the minor function code is <strong><em>IRP_MN_QUERY_DEVICE_RELATIONS</em></strong>, with a code indicating that the PnP Manager is looking for the so-called "bus" relations.
</p><p>In response to the bus relations query, the <strong>bus driver returns its list of PDOs</strong>. The PnP Manager can easily determine which of the PDOs represent devices that it hasn't yet initialized. Let's focus on the PDO for your hardware for the time being and see what happens next.
</p><p>The PnP Manager will send another IRP to the bus driver, this time with the minor function code<strong> IRP_MN_QUERY_ID</strong>. This is point 3 in Figure. In fact, the PnP Manager sends several such IRPs, each with an operand that instructs the bus driver to return a particular type of identifier. One of the identifiers, the device identifier, uniquely specifies the type of device. A device identifier is just a string, and it might look like one of these examples:
</p><p><strong>PCI\VEN_102C&amp;DEV_00E0&amp;SUBSYS_00000000<br>USB\VID_0547&amp;PID_2125&amp;REV_0002<br>PCMCIA\MEGAHERTZ-CC10BT/2-BF05
</strong></p><p>The PnP Manager uses the device identifier to locate a <em>hardware key</em> in the system registry.
</p><p>If this is the first time your particular device has been plugged into the computer：
</p><ol><li>Invocating the setup program to locate INF file. (<strong>How to find the INF? See later.</strong>)
</li><li>Carrying out instructions you provide in an install section.
</li></ol><p>If this is not the first time your particular device has been plugged into the computer：
</p><ol><li>Skip driver Installing.
</li></ol><p>Then:
</p><p>PnP Manager calls the Memory Manager to map driver in. 
</p><p>Call DriverEntry.
</p><p>Call AddDevice
</p><p>Then the PnP Manager sends an IRP to the bus driver with the minor function code <strong><em>IRP_MN_QUERY_RESOURCE_REQUIREMENTS</em></strong>. This IRP is basically asking the bus driver to describe the requirements your device has for an<strong> interrupt request line</strong>, for<strong> I/O port addresses</strong>, for <strong>I/O memory addresses</strong>, and for <strong>system DMA channels</strong>. The bus driver constructs a list of these resource requirements and reports them back.
</p><p>Finally the PnP Manager is ready to configure the hardware. It works with a set of resource arbitrators to assign resources to your device. If that can be done—and it usually can be—the PnP Manager sends an <em>IRP_MJ_PNP</em> to your driver with the minor function code <strong><em>IRP_MN_START_DEVICE</em>.</strong> Your driver handles this IRP by configuring and connecting various kernel resources, following which your hardware is ready to use.
</p><p>
&nbsp;</p><p><span style="font-size:14pt;"   ><strong>Legacy Devices
</strong></span></p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img1.ph.126.net_CAdLqUE4d0NaA_lCw4E5xA==_6608803754747640046.jpg"   alt=""   >
</p><p>Finally the setup program instructs the end user to restart the system. Following the restart (or following the end user's decision to bypass the restart), the root enumerator will scan the registry and find the newly added device. Thereafter, the process of loading your driver is nearly identical to that for a Plug and Play device.
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_kHpBcDwh021eZWKBOV8x2A==_1816920974767807724.jpg"   alt=""   >
</p><p>
&nbsp;</p><p><span style="color:black; font-family:Segoe UI;"   ><span style="font-size:14pt;"   >Order of Driver Loading</span><span style="font-size:15pt;"   ><br></span></span>The order of calls to the <em>AddDevice</em> functions in the various drivers.
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img1.ph.126.net_BjpUix14tHfJHTN5HH6W8g==_6608869725445305988.jpg"   alt=""   >
</p><p>
&nbsp;</p><p>
&nbsp;</p><ol><li>The system first calls the AddDevice functions in any lower filter drivers specified in the device key for the device, in the order in which they appear in the LowerFilters value.
</li><li>Then the system calls AddDevice in any lower filter drivers specified in the class key. Again, the calls occur in the order in which the drivers appear in the LowerFilters string.
</li><li>The system calls AddDevice in the driver specified by the Service value in the device key. This is the function driver.
</li><li>The system calls AddDevice for any upper filter drivers specified in the device key, in the order in which they appear in the UpperFilters data string.
</li><li>Finally the system calls AddDevice for any upper filter drivers specified in the class key, in the order in which they appear in the UpperFilters data string.
</li></ol><p>As I explain later in this chapter, each <em>AddDevice</em> function creates a kernel <em>DEVICE_OBJECT</em> and links it into the stack rooted in the PDO. Therefore, the order of calls to <em>AddDevice</em> governs the order of device objects in the stack and, ultimately, the order in which drivers see IRPs.
</p><p><strong>Situation 1
</strong></p><p>Such a request would flow first to the upper FiDO and then to the function driver for the device. (That driver is the one for the device object marked FDO<sub>dev</sub> in the figure.) The function driver calls the HAL directly to perform its work, so none of the other drivers in the figure will see the IRP.
</p><p><em>The flow of a read request for a device on a secondary bus</em>
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img0.ph.126.net_5ahqf6QuvLxiqJmPzmL0Cw==_6608949989794134309.jpg"   alt=""   >
</p><p><strong>Situation 2
</strong></p><p>Here we have a read request for a device plugged into a <strong>USB hub that itself is plugged into the host controller</strong>. The complete device tree therefore contains <strong>stacks</strong> for <strong>the device</strong>, for the <strong>hub</strong>, and for the <strong>host controller</strong>. The <em>IRP_MJ_READ</em> flows through the FiDO to the function driver, which then<strong> sends one or more IRPs of a different kind downward to its own PDO</strong>. The PDO driver for a USB device is USBHUB.SYS, and it forwards the IRPs to the topmost driver in the host controller device stack, skipping the two-driver stack for the USB hub in the middle of the figure.<strong>
</strong></p><p><em>The flow of a read request for a USB device.</em><strong>
</strong></p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_hLwwViHRqVan1GZH2-gnOQ==_6608197923841564139.jpg"   alt=""   >
</p><p><strong>Situation 3
</strong></p><p>The third example is similar to the first except that the IRP in question is a notification concerning whether a disk drive on a PCI bus will be used as the repository for a system paging file. You'll learn in Chapter 6 that this notification takes the form of an <em>IRP_MJ_PNP</em> request with the minor function code <em>IRP_MN_DEVICE_USAGE_NOTIFICATION</em>. In this case, the FiDO driver passes the request to the FDO<sub>dev</sub> driver, which takes note of it and passes it further down the stack to the PDO<sub>dev</sub> driver. This particular notification has implications about how other I/O requests that concern the PnP system or power management will be handled, so the PDO<sub>dev</sub> driver sends an identical notification to the stack within which is the FDO<sub>bus</sub>, as illustrated in Figure 2-10. (Not all bus drivers work this way, but the PCI bus does.)
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img1.ph.126.net_kIKnBFJL6UNZiWo01NijvA==_6608698201631373031.jpg"   alt=""   >
</p><p>
&nbsp;</p><p><span style="font-size:12pt;"   ><strong>The Role of the Registry
</strong></span></p><p>The PnP Manager and setup subsystems rely heavily on <strong>four keys</strong> in the <strong><em>HKEY_LOCAL_MACHINE</em></strong> branch of the registry. These are called the <strong><em>hardware key</em></strong>, <strong>the <em>class key</em>, the <em>driver key</em>, and the <em>service key</em></strong>. (See Figure) To be clear, these are not the proper names of specific subkeys: they are generic names of four keys whose pathnames depend on the device to which they belong. Broadly speaking, <strong>the hardware and driver keys contain information about a single device</strong>, <strong>the class key concerns all devices of the same type</strong>, <strong>and the service key contains information about the driver</strong>. People sometimes use the name<strong>
<em>instance key</em> to refer to the hardware key</strong> and <strong><em>software key</em> to refer to the driver key</strong>. The multiplicity of names derives from the fact that Windows 95/98/Me and Windows XP were written (mostly) by different people. <strong>A fifth key, the <em>hardware parameters</em> key, might also exist; it contains nonstandard parameter information about the device.</strong>
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_ZHJLVCbJtVBsw7HHWRSg3g==_6608765271840667625.jpg"   alt=""   >
</p><p>You should plan to use those APIs instead of directly tampering with the registry. In fact, even administrator accounts lack permission to write to some of these keys.
</p><p><strong>The Hardware (Instance) Key
</strong></p><p>Device hardware keys appear in the <strong><em>\System\CurrentControlSet\Enum</em> subkey of the local machine</strong> branch of the registry. 
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img1.ph.126.net_ovgqBsAFrL-8fePZ8ayXww==_6608526677817440104.jpg"   alt=""   ><strong>
</strong></p><p>Some of the values in the hardware key provide <strong>descriptive information</strong> that user-mode components such as the <strong>Device Manager</strong> can use. Figure 15-3 shows how the Device Manager portrays the properties of USB42. If you compare the two figures, you'll notice some common things. In particular, the <strong><em>DeviceDesc</em></strong> string in the hardware key is the <strong>title of the device</strong> (unless there happens to be a <strong><em>FriendlyName</em></strong> property in the registry, which isn't the case here), and the <strong><em>Mfg</em></strong> property appears as the <strong>Manufacturer name</strong> in the property page. 
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_SICL3YBWv_NIaglXzTyGgw==_6608420025190380698.jpg"   alt=""   >
</p><p>
&nbsp;</p><p>The hardware key also contains several values that identify the class of device to which the device belongs and the drivers for the device. <strong><em>ClassGUID</em></strong> is the ASCII representation of a globally unique identifier (GUID) that uniquely identifies a <strong>device setup class</strong>; in effect, it's a pointer to the class key for this device. <em>Class</em> is the name of the setup class. <strong><em>Driver</em> names the driver key</strong>, <strong>which is a subkey of the class key</strong>. <strong><em>Service</em> is a pointer to the service key in <em>HKLM\System\CurrentControlSet\Services</em></strong>. Optional values (which USB42 doesn't have) named <em>LowerFilters</em> and <em>UpperFilters</em>, if present, would identify the service names for any lower or upper filter drivers.
</p><p>A hardware key might have overriding values named <strong><em>Security</em>, <em>Exclusive</em>, <em>DeviceType</em>, and <em>DeviceCharacteristics</em></strong> that force the device object the driver will create to have certain attributes. USB42 doesn't have these overrides.
</p><p>Finally, the hardware key might contain a subkey named<strong>
<em>Device Parameters</em></strong>, which contains<strong> nonstandard configuration information</strong> about the hardware. See Figure . <em>SampleInfo</em>, the only property in the figure for USB42, specifies the help file for the sample driver. (The other values in the figure are artifacts of a failed run of one of the Hardware Compatibility Tests. Their presence does no harm.)
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_qkSLVIvqnVzLpmZWcEipJg==_6608263894539228542.jpg"   alt=""   ><strong>
</strong></p><p>
&nbsp;</p><p><strong>The Class Key
</strong></p><p>The class keys for all classes of device appear in the <em>HKLM\System\CurrentControlSet\Control\Class</em> key.
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img0.ph.126.net_pLyQdsUYvT8LGFUttK6OEA==_6608489294422095984.jpg"   alt=""   >
</p><p>
&nbsp;</p><ol><li>(Default) specifies the friendly name of the class. This is the class title that the Device Manager uses. 
</li><li>Class is the name of the class. The class name and the GUID go together here and in the hardware keys for devices belonging to this class.
</li><li>EnumPropPages32 specifies a property-page provider DLL that provides custom property pages for the Device Manager to use when displaying properties for this class of device. The provider for this class, samclass.dll, presents the page labeled "Sample Information." In general, this value can include a DLL name and the name of an entry point. If the entry point name is omitted, as in this example, the system assumes it is EnumPropPages.
</li><li>Install32 specifies the class installer DLL that the setup system uses whenever it performs setup actions on devices belonging to the class. This value can include a DLL name and the name of an entry point. If the DLL name is omitted, as in this example, the system assumes it is the same as the property-page DLL.
</li><li>Icon specifies the resource identifier for an icon in the class installer DLL. The Device Manager and the setup system use this icon whenever they display information about the class. The DDK suggests that an icon will be taken from the property page DLL if no class installer is present, but that was not the case in Windows 2000, and I've been in the habit of providing at least a degenerate class installer entry point just so I can have a custom icon.
</li></ol><p>The SAMPLE class lacks some of the optional values that might be present, such as the following:
</p><ol><li>NoInstallClass, if present and not equal to 0, indicates that some enumerator will automatically detect any device belonging to this class. If the class has this attribute, the hardware wizard won't include this class in the list of device classes it presents to the end user.
</li><li>SilentInstall, if present and not equal to 0, causes the PnP manager to install devices of this class without presenting any dialog boxes to the end user.
</li><li><strong>UpperFilters</strong> and <strong>LowerFilters</strong> specify service names for filter drivers. The PnP Manager loads these filters for every device belonging to the class. (You specify filter drivers that apply to just one device in the device's hardware key.)
</li><li>NoDisplayClass, if present and not equal to 0, suppresses devices of this class from the Device Manager display.
</li></ol><p>There can be a <em>Properties</em> subkey of the class key, which can contain values named <em>Security</em>, <em>Exclusive</em>, <em>DeviceType</em>, and <em>DeviceCharacteristics</em>. These values override default settings of certain device object parameters for all devices of this class
</p><p><strong>The Driver Key
</strong></p><p>Each device also has its own subkey below the class key. The name of this key (actually, the name of this key relative to <em>CurrentControlSet\Control\Class</em>) is the <em>Driver</em> value in the device's hardware key. Refer to Figure for an illustration of the contents of this subkey, the purpose of which is to correlate all these registry entries with the <strong>INF file used to install the device and to provide a repository for driver-specific configuration information</strong> that concerns this device.
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img2.ph.126.net_t-mhywQhGzBIZC6-HP7y7Q==_6608223212609001521.jpg"   alt=""   ><strong>
</strong></p><p>Both the driver key and the hardware parameters key can contain parameter information about a device. The difference between the two keys is a bit subtle. The DDK says that the driver key contains "driver-specific information," whereas the hardware parameters key contains "device-specific information." In both cases, the "information" in question pertains to a particular instance of the device. Microsoft's concept is that the driver-specific information would be peculiar to a given driver and not relevant to some other driver for the same hardware. I confess that this distinction pretty much escapes me, inasmuch as I'm used to thinking that any given device will have just one driver.<strong>
</strong></p><p><strong>The Service (Software) Key （这里和MSDN有出入，MSDN中将Software Key 和 Driver Key等价。所以以MSDN为主。）</strong></p><p>The last key that's important for a device driver is the service key. It indicates where the driver's executable file is on disk and contains some other parameters that govern the way the driver is loaded. Service keys appear in the <em>HKLM\System\CurrentControlSet\Services</em> key.
</p><p><img title="How the System Finds and Loads (WDM) Drivers - Howie - Dspace"   src="pic/img0.ph.126.net_9xrCL0JCB4xx2UH-CqfnKw==_6608199023353191876.jpg"   alt=""   ><strong>
</strong></p><p>
&nbsp;</p><p><span style=" font-size:15pt;color:black; font-family:Segoe UI;"   >Accessing the Registry from a Program
</span></p><p><strong>Accessing the Registry from a Driver (kernel mode)
</strong></p><div><table style="border-collapse:collapse;"   border="0"   ><colgroup><col style="width:170px;"   ><col style="width:846px;"   ><tbody valign="top"   ><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  solid 0.5pt;"   ><p><strong><em>Registry Key</em></strong></p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  solid 0.5pt;"   ><p><strong><em>Function to Use for Access</em></strong></p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Hardware</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p>Read individual standard properties via <em>IoGetDeviceProperty</em>. You can't change these properties from a driver, and you shouldn't try to figure out the name of this key in order to open it directly.</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Hardware Parameters</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>IoOpenDeviceRegistryKey</em> (<em>PLUGPLAY_REGKEY_DEVICE</em> option)</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Driver</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>IoOpenDeviceRegistryKey</em> (<em>PLUGPLAY_REGKEY_DRIVER</em> option)</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Class</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p>No access method provided, and you shouldn't try to figure out the name of this key in order to open it directly.</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Service</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>ZwOpenKey</em> using <em>RegistryPath</em> parameter to <em>DriverEntry</em>.</p></td></tr></table></div><p>
&nbsp;</p><p><strong>Example:
</strong></p><p><span style=" font-size:12pt;font-family:宋体;"   >WCHAR&nbsp;name[256];<br>ULONG&nbsp;junk;<br>status&nbsp;=&nbsp;IoGetDeviceProperty(pdo,&nbsp;<br>&nbsp;&nbsp;DevicePropertyDeviceDescription,&nbsp;sizeof(name),&nbsp;name,&nbsp;&amp;junk);<br>KdPrint((DRIVERNAME&nbsp;<br>&nbsp;&nbsp;"&nbsp;-&nbsp;AddDevice&nbsp;has&nbsp;succeeded&nbsp;for&nbsp;'%ws'&nbsp;device\n",&nbsp;name));<br></span><strong>
</strong></p><p><strong>Accessing the Registry from User Mode
</strong></p><div><table style="border-collapse:collapse;"   border="0"   ><colgroup><col style="width:109px;"   ><col style="width:467px;"   ><tbody valign="top"   ><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  solid 0.5pt;"   ><p><em>Registry Key</em></p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  solid 0.5pt;"   ><p><em>Function to Use for Access</em></p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Hardware</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p>Read or write individual standard properties via <em>SetupDiGetDeviceRegistryProperty</em> and <em>SetupDiSetDeviceRegistryProperty</em>.</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Hardware Parameters</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>SetupDiOpenDevRegKey</em> (<em>DIREG_DEV</em> option).</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Driver</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>SetupDiOpenDevRegKey</em> (<em>DIREG_DRV</em> option).</p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Class</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>SetupDiOpenClassRegKey</em>. Starting in Windows XP, read or write device object properties via <em>SetupDiGetClassRegistryProperty</em> and <em>SetupDiSetClassRegistryProperty</em>. </p></td></tr><tr><td style="padding-left: 7px; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>Service</em>
</p></td><td style="padding-left: 7px; border-left:  none; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt; padding-right: 7px; border-top:  none;"   ><p><em>QueryServiceConfig</em>, <em>ChangeServiceConfig</em>.</p></td></tr></table></div><p>
&nbsp;</p><p><strong>Example:
</strong></p><p><strong>[retrieve the friendly name]
</strong></p><p>HDEVINFO&nbsp;info&nbsp;=&nbsp;SetupDiGetClassDevs(...);<br>SP_DEVINFO_DATA&nbsp;did&nbsp;=&nbsp;{sizeof(SP_DEVINFO_DATA)};<br>SetupDiGetDeviceInterfaceDetail(info,&nbsp;...,&nbsp;&amp;did);<br><em>TCHAR&nbsp;fname[256];<br>SetupDiGetDeviceRegistryProperty(info,&nbsp;&amp;did,<br>&nbsp;&nbsp;SPDRP_FRIENDLYNAME,&nbsp;NULL,&nbsp;(PBYTE)&nbsp;fname,&nbsp;<br>&nbsp;&nbsp;sizeof(fname),&nbsp;NULL);</em><br><br><strong>[retrieve the various properties]</strong><br>LPCTSTR&nbsp;devname;&nbsp;&nbsp;&nbsp;//&nbsp;&lt;==&nbsp;someone&nbsp;gives&nbsp;you&nbsp;this<br>HDEVINFO&nbsp;info&nbsp;=&nbsp;SetupDiCreateDeviceInfoList(NULL,&nbsp;NULL);<br>SP_DEVICE_INTERFACE_DATA&nbsp;ifdata&nbsp;=&nbsp;{sizeof(SP_DEVICE_INTERFACE_DATA)};<br>SetupDiOpenDeviceInterface(info,&nbsp;devname,&nbsp;0,&nbsp;&amp;ifdata);<br>SP_DEVINFO_DATA&nbsp;did&nbsp;=&nbsp;{sizeof(SP_DEVINFO_DATA)};<br>SetupDiGetDeviceInterfaceDetail(info,&nbsp;&amp;ifdata,&nbsp;NULL,&nbsp;0,&nbsp;NULL,&nbsp;&amp;did);<br><strong>
</strong></p><p><strong>Device Object Properties 
</strong></p><p>As you know, you call <em>IoCreateDevice</em> to create a device object. In a WDM driver, your <em>AddDevice</em> function ordinarily creates a single device object and links it into the PnP driver stack by calling <em>IoAttachDeviceToDeviceStack</em>. Once the function driver and all filter drivers have finished these steps, the PnP Manager consults the registry to apply optional overrides to some of the settings in the device objects. The settings in question are these few:
</p><ul style="margin-left: 39pt;"   ><li>The security descriptor attached to the physical device object (PDO), which can be overridden by a <em>Security</em> value in the registry.
</li><li>The device type (<em>FILE_DEVICE_XXX</em>) for the PDO, which can be overridden by a <em>DeviceType</em> value in the registry.
</li><li>The device characteristics flags, which can be overridden by a <em>DeviceCharacteristics</em> value.
</li><li>The exclusivity option for the PDO, which can be overridden by an <em>Exclusive</em> value.
</li></ul><p>The PnP Manager looks first in the hardware key and then in the <em>Properties</em> subkey of the class key to find these overrides. After modifying the PDO, the PnP Manager then merges the characteristics flags from all device objects in the stack and sets certain ones (selected by the <em>FILE_CHARACTERISTICS_PROPAGATED</em> mask in ntddk.h) to be the same in all the device objects. At the present time, the characteristics flags that are propagated are these:
</p><ul style="margin-left: 39pt;"   ><li><em>FILE_REMOVABLE_MEDIA</em>
</li><li><em>FILE_READ_ONLY_DEVICE</em>
</li><li><em>FILE_FLOPPY_DISKETTE</em>
</li><li><em>FILE_WRITE_ONCE_MEDIA</em>
</li><li><em>FILE_DEVICE_SECURE_OPEN</em>
</li></ul><p>For the security and exclusivity overrides to be effective, none of the filter or function drivers in the PnP stack should name their device objects. They should instead use <em>IoRegisterDeviceInterface</em> as the only method of establishing a symbolic link. The registered interface approach forces the I/O and Object Managers to refer to the PDO when opening a handle to the device, thereby giving effect to these two overrides.
</p><p>The overriding values come to exist in the registry in one of two ways. You can specify them with special syntax in your INF file. Alternatively, you or some standard management application can use the <em>SetupDiSetXxxRegistryProperty</em> functions to change them in the hardware or class keys.
</p>
</body></html>