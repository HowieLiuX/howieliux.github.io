<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]FPO -frame pointer omit</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]FPO -frame pointer omit</h2>
<p align="right">发布时间：2012-6-5 16:07
<br>分类名称：Debug_Crack</p><br>
<p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: 11pt; font-family: 宋体;"  >原作者：</span><span style="font-size: 11pt;"  ><a rel="nofollow" href="http://blogs.msdn.com/larryosterman/default.aspx"  ><font color="#0000ff"  >Larry Osterman</font></a></span></p><p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: 11pt;"  ><a rel="nofollow" href="http://blogs.msdn.com/larryosterman/archive/2007/03/12/fpo.aspx"  ><span style="font-family: 宋体;"  ><span><font color="#0000ff"  >原文链接</font></span></span></a></span></p><p style="margin: 0cm 0cm 0pt;"  >&nbsp;</p><br><div><p>I was chatting with one  of the perf guys last week and he mentioned something that surprised me  greatly.&nbsp; Apparently he's having perf issues that appear to be  associated with a 3rd party driver.&nbsp; Unfortunately, he's having problems  figuring out what's going wrong because the vendor wrote the driver  used FPO (and hasn't provided symbols), so the perf guy can't track the  root cause of the problem.</p> <p>The reason I was surprised was that I didn't realize that ANYONE was using FPO any more.</p> <p>What's FPO?</p> <p>To know the answer, you have to go way back into prehistory.</p> <p>Intel's 8088 processor had an extremely limited set of registers (I'm ignoring the segment registers), they were:</p> <p> </p><table border="1"  cellpadding="2"  cellspacing="0"  width="400"  > <tbody> <tr> <td valign="top"  width="79"  >AX</td> <td valign="top"  width="79"  ><strong>BX</strong></td> <td valign="top"  width="79"  >CX</td> <td valign="top"  width="79"  >DX</td> <td valign="top"  width="82"  >IP</td></tr> <tr> <td valign="top"  width="78"  ><strong>SI</strong></td> <td valign="top"  width="79"  ><strong>DI</strong></td> <td valign="top"  width="79"  ><strong>BP</strong></td> <td valign="top"  width="79"  >SP</td> <td valign="top"  width="84"  >FLAGS</td></tr></table> <p>With such a limited set of registers, the registers were all assigned  specific purposes.&nbsp; AX, BX, CX, and DX were the "General Purpose"  registers, SI and DI were "Index" registers, SP was the "Stack Pointer",  BP was the "Frame Pointer", IP was the "Instruction Pointer", and FLAGS  was a read-only register that contained several bits that were  indicated information about the processors' current state (whether the  result of the previous arithmetic or logical instruction was 0, for  instance).</p> <p>The BX, SI, DI and BP registers were special because they could be  used as "Index" registers.&nbsp; Index registers are critically important to a  compiler, because they are used to access memory through a pointer.&nbsp; In  other words, if you have a structure that's located at offset 0x1234 in  memory, you can set an index register to the value 0x1234 and access  values relative to that location.&nbsp; For example:</p> <blockquote> <p>MOV&nbsp;&nbsp;&nbsp; BX, [Structure]<br>MOV&nbsp;&nbsp;&nbsp; AX, [BX]+4</p></blockquote> <p>Will set the BX register to the value of the memory pointed to by  [Structure] and set the value of AX to the WORD located at the 4th byte  relative to the start of that structure.</p> <p>One thing to note is that the SP register wasn't an index register.&nbsp;  That meant that to access variables on the stack, you needed to use a  different register, that's where the BP register came from&nbsp;- the BP  register was dedicated to accessing values on the stack.</p> <p>When the 386 came out, they stretched the various registers to  32bits, and they fixed the restrictions that only BX, SI, DI and BP  could be used as index registers.</p> <p> </p><table border="1"  cellpadding="2"  cellspacing="0"  width="400"  > <tbody> <tr> <td valign="top"  width="79"  ><strong>EAX</strong></td> <td valign="top"  width="79"  ><strong>EBX</strong></td> <td valign="top"  width="79"  ><strong>ECX</strong></td> <td valign="top"  width="79"  ><strong>EDX</strong></td> <td valign="top"  width="82"  >EIP</td></tr> <tr> <td valign="top"  width="78"  ><strong>ESI</strong></td> <td valign="top"  width="79"  ><strong>EDI</strong></td> <td valign="top"  width="79"  ><strong>EBP</strong></td> <td valign="top"  width="79"  ><strong>ESP</strong></td> <td valign="top"  width="84"  >FLAGS</td></tr></table> <p>This was a good thing, all of a sudden, instead of being constrained to 3 index registers, the compiler could use 6 of them.</p> <p>Since index registers are used for structure access, to a compiler  they're like gold - more of them is a good thing, and it's worth almost  any amount of effort to gain more of them.</p> <p>Some extraordinarily clever person realized that since ESP was now an  index register the EBP register no longer had to be dedicated for  accessing variables on the stack.&nbsp; In other words, instead of:</p> <blockquote> <p>MyFunction:<br>&nbsp;&nbsp;&nbsp; PUSH&nbsp;&nbsp;&nbsp; EBP<br>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; EBP, ESP<br>&nbsp;&nbsp;&nbsp; SUB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESP, &lt;LocalVariableStorage&gt;<br>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; EAX, [EBP+8]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<br>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESP, EBP<br>&nbsp;&nbsp;&nbsp; POP&nbsp; &nbsp;&nbsp;&nbsp; EBP<br>&nbsp;&nbsp;&nbsp; RETD</p></blockquote> <p>to access the 1st parameter on the stack (EBP+0 is the old value of EBP, EBP+4 is the return address), you can instead do:</p> <blockquote> <p>MyFunction:<br>&nbsp;&nbsp;&nbsp; SUB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP,&nbsp;&lt;LocalVariableStorage&gt;<br>&nbsp;&nbsp;&nbsp; MOV&nbsp;&nbsp;&nbsp;&nbsp; EAX, [ESP+4+&lt;LocalVariableStorage&gt;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<br>&nbsp;&nbsp;&nbsp; ADD&nbsp;&nbsp;&nbsp;&nbsp; SP, &lt;LocalVariableStorage&gt;<br>&nbsp;&nbsp;&nbsp; RETD</p></blockquote> <p>This works GREAT - all of a sudden, EBP can be repurposed and used as  another general purpose register!&nbsp; The compiler folks called this  optimization "Frame Pointer Omission", and it went by the acronym FPO.</p> <p>But there's one small problem with FPO.</p> <p>If you look at the pre-FPO example for MyFunction, you'd notice that  the first instruction in the routine was PUSH EBP followed by a MOV EBP,  ESP.&nbsp; That had an interesting and extremely useful side effect.&nbsp; It  essentially created a singly linked list that linked the frame pointer  for each of the callers to a function.&nbsp; From the EBP for a routine, you  could recover the entire call stack for a function.&nbsp; This was  unbelievably useful for debuggers - it meant that call stacks were quite  reliable, even if you didn't have symbols for all the modules being  debugged.&nbsp; Unfortunately, when FPO was enabled, that list of stack  frames was lost - the information simply wasn't being tracked.</p> <p>To solve the is problem, the compiler guys put the information that  was lost when FPO was enabled into the PDB file for the binary.&nbsp; Thus,  when you had symbols for the modules, you could recover all the stack  information.</p> <p>FPO was enabled for all Windows binaries in NT 3.51, but was turned  off for Windows binaries in Vista because it was no longer necessary -  machines got sufficiently faster since 1995 that the performance  improvements that were achieved by FPO weren't sufficient to counter the  pain in debugging and analysis that FPO caused.</p> <p>&nbsp;</p> <p>Edit: Clarified what I meant by "FPO was enabled in NT 3.51" and "was turned off in Vista", thanks Steve for pointing this out.</p><p><br></p><p>本来转载的是一篇中文翻译，发现翻译的意思有些出入，所以还是贴上英文原文。<br></p></div>
</body></html>