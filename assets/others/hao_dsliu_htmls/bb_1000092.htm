<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[原] COM 笔记 – 原理（高级）</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[原] COM 笔记 – 原理（高级）</h2>
<p align="right">发布时间：2012-12-16 20:23
<br>分类名称：COM</p><br>

<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><STRONG>重用性（包容、聚合） </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><STRONG>透明性（列集、散集） </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><STRONG>安全性 </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><STRONG>多线程特性（套间） </STRONG></SPAN></P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体;"   ><STRONG>重用性 (包容/聚合) </STRONG></SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img7.ph.126.net_MK--8EP0d8HzOIK3rnGC2A==_6597886703796162177.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P style="TEXT-ALIGN: center;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >包容 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img8.ph.126.net_ZTknAE6EclnbtwFiRW9CWA==_6597501874726333518.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P style="TEXT-ALIGN: center;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >聚合 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>对象A</STRONG>是已经被实现好的COM对象。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>包容</STRONG> </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >B实现ISomeInterface和IOtherInterface接口，然后在ISomeInterface的实现中调用A对象提供的服务。一般的，A的生存期在B生存期内。 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>聚合</STRONG> </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >B只实现了IOtherInterface，当客户要求B对象提供ISomeInterface时，由于A被聚合到了B中，B可以提供此服务。一般的，A的生存期在B生存期内。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >聚合的复杂性在于，B虽然知道A实现了什么接口，但A不知道B实现了什么接口。这样就导致通过B获取到A的实例指针后，通过此指针调用的QueryInterface是A的，也就无法Query出B中实现的接口来。而且A和B的接口继承于俩个不同的IUnknown，获取回的指针也不一样。这样就违背了QueryInterface需要遵循的原则。（什么原则？参考我的《COM笔记-原理（基础）》里面的内容） </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >解决聚合复杂性的办法，在A中留下一个IUnknown 指针（依赖抽象），通过外部（例如B）将其IUnknown传入给A，A就可以利用此接口来代理B 来做QueryInterface了。 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >实现： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >/************** B组件实现代码**************/ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >class CB : public IOtherInterface<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>private:<BR>&nbsp;&nbsp;&nbsp;&nbsp;IUnknown *m_pUnknownInner; // Point to A's IUnknown<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>}<BR>&nbsp;<BR>CB::QueryInterface(...)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (iid == IID_SomeInterface)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return m_pUnknownInner-&gt;QueryInterface(iid, ppv);<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>}<BR>/*********************************************/ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >A分被聚合和未被聚合俩种情况。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >如果被聚合，A就使用内部这个指针（即B传入的自己实例指针）来QueryInterface，相当于是B在Query Interface，获取的IUnknown都是B的。而且不存在A找不到B的Interface。&nbsp;而且可以看到，B组件中，如果Query是A的组件，又回回到A自己的QueryInterface中，去Query到自己的Interface。（看起来比较绕，） </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >如果未被聚合，那么就什么都不做，不使用这个指针。 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CoCreateInstance有一个参数，叫IUnknown *pUnknownOuter，这个指针，就是A中要保存的B实例指针。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >A内部，为了区分聚合和非聚合，定了了俩个IUnknown（delegating unknown, undelegating unknown).这个俩个委托和非委托名词，曾经困扰了我很久，后来发现是因为这俩个词语本身的语义对我的误导。如果要以我自己的方式区分，我将其区分为一个IUnknown是Proxy（代理），一个IUnknown是正常的IUnknown。代理只是个中转站，负责分发，其内部其实就是一个判断，如果A的pUnknownOuter为NULL，那么就转发给正常的IUnknown。如果pUnknownOuter不为NULL，那么就调用它自身的接口函数。 </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >class INondelegationUnknown<BR>{<BR>public:<BR>&nbsp;&nbsp;&nbsp;&nbsp;virtual HRESULT _stdcall NondelegationQueryInterface(...) = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;virtual ULONG _stdcall NondelegationAddRef() = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;virtual ULONG _stdcall NondelegationRelease() = 0;<BR>};<BR>class CA : <BR>public ISomeInterface, <BR>public INondelegationUnknown<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>public:<BR>&nbsp;&nbsp;&nbsp;&nbsp;NondelegationQueryInterface(...);<BR>&nbsp;&nbsp;&nbsp;&nbsp;NondelegationAddRef();<BR>&nbsp;&nbsp;&nbsp;&nbsp;NondelegationRelease();<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;QueryInterface(...);<BR>&nbsp;&nbsp;&nbsp;&nbsp;AddRef();<BR>&nbsp;&nbsp;&nbsp;&nbsp;Release();<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>private:<BR>&nbsp;&nbsp;&nbsp;&nbsp;IUnknown *m_pUnknownOuter;<BR>&nbsp;&nbsp;&nbsp;&nbsp;......<BR>}；<BR>&nbsp; </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::NondelegationQueryInterface(...) </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >{ 正常Query，就像什么都没发生过 } </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::NondelegationAddRef() </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >{ 正常AddRef，就像什么都没发生过 } </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::NondelegationRelease() </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >{ 正常Release，就像什么都没发生过 } </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::QueryInterface(...){ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;if (NULL == m_pUnknownOuter) // 转发 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call NondelegationQueryInterface </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;else </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call m_pUnknownOuter-&gt;QueryInterface </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >} </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::AddRef(){ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >if (NULL == m_pUnknownOuter) // 转发 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call NondelegationAddRef </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;else </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call m_pUnknownOuter-&gt;AddRef </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >} </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CA::Release(){ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >if (NULL == m_pUnknownOuter) // 转发 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call NondelegationRelease </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;else </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call m_pUnknownOuter-&gt;AddRef </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >} </SPAN></P>
<P>&nbsp; &nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >再看看B何时将它自己的指针传递给A： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >HRESULT CB::Init() </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >{ </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;IUnknown *pUnknownOuter = (IUnknown *) this; </SPAN></P>
<P style="MARGIN-LEFT: 24pt;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >HRESULT result = ::CoCreateInstance(CLSID_ComponetA, pUnknownOuter, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&amp;m_pUnknownInner); </SPAN></P>
<P style="MARGIN-LEFT: 24pt;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >...... </SPAN></P>
<P style="MARGIN-LEFT: 24pt;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >传入pUnknownOuter（既B的this），而且得到m_pUnknownInner（A的this）。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >} </SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img1.ph.126.net_giecBUX5xrOyzYYAjryX4Q==_6597406217216196561.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >UML图如下：ISomeInterface能由CB来Query,换句话说，Client不知道CA的存在。可以看到INondelegationUnknown是个的辅助接口。CA use IUnknown接口，就能接受任何COM对象， 在CoCreateInstance的时候，将CB的this传入，可以看到类厂的CreateInstance也有一个Outter接口，CreateInstance将CB的实例指针传入CA中的m_pUnknownOuter保存。类厂CreateInstance完毕， </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >将CA的实例由参数m_pUnknownInner获得。 </SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img6.ph.126.net_za-Yp5lEuOF1IyB2F-YwLA==_6597143433937077876.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >这里会有个奇怪的现象，B获取到的this指针指向的是INondelegationUnknown接口，而且B并不知道，他认为这个接口是IUnknown接口。更加奇怪的是，当你使用innter 指针调用AddRef，Release和QueryInterface的时候，你会惊奇的发现代码会跑到NondelegationAddRef/Release/QueryInterface，很神奇。这也就是INondelegationUnknown的作用，他和IKnown的接口布局完全相同，属于在汇编级的调用。那为什么CB获取的是INondelegationUnknown的接口，而不是IKnown的接口呢？如果是IKnown，那么当B调用A去Query的时候，调用的是A的QueryInterface，内部判断Outer指针不为NULL，转掉B的QueryInterface，然后B的QueryInterface，又去调用A的QueryInterface，这样以来，就成了死循环。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >INondelegationUnknown伪造了IKnown，在汇编一级的函数调用，只是一个this取偏移量而已。（详情参看: Inside C++ Object model 这本书）例如：m_pUnknownInner-&gt;AddRef()，汇编级别，会被转换为： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >( *m_pUnknownInner-&gt;vptr[1] ) ( m_pUnknownInner)，当得到的m_pUnknownInner指向的是INondelegationUnknown的时候，显然就调用到了NondelegationAddRef()里。 </SPAN></P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>进程透明性（列集、散集） </STRONG></SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img5.ph.126.net_XGxWFkXDB7Gj78EN-CvdMA==_6597727274610146375.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P style="TEXT-ALIGN: center;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >进程外组件与客户程序调用的基本模型图 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >代理对象和存根代码实际上存在于同一个DLL中，它们是被系统的COM库自动加载和调用的。如果自己没有实现代理对象和存根代码，默认使用MIDL编译IDL文件后，会生成*_i.c，*_p.c，*.def，dlldata.c，通过编译这几个文件，就能编译出一个DLL来。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >在客户端为何叫<STRONG>代理对象? </STRONG>在客户端通过QueryInterface获取到指定接口的对象，这个对象实际上并不是客户端想象到的C++层面的对象，客户端获取到的其实是个"代理对象"，这个代理对象是由COM库动态构造出来的。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >由于对虚函数的在汇编层面只是个对this-&gt;vptr索引调用，这种实现则完全有可行，当调试的时候会发现，自己的代理对象/存根代码模块（DLL）被动态加载，进入的函数是诸如：*<SPAN style="COLOR: #010001;"   >_Proxy<SPAN style="COLOR: #4c4c4c;"   >（在*_p.c文件实现），这个函数体就是代理对象的函数体，接着内部会将传入的参数做列集处理，然后通过LPC/RPC和组件对象中的存根代码通讯。 </SPAN></SPAN></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>客户端与组件通讯分为俩个部分： </STRONG></SPAN></P>
<OL>
<LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >建立连接（建立连接是在获取接口指针中建立起来的） </SPAN></DIV>
</LI><LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >使用连接跨进程调用（上面说的就是跨进程调用） </SPAN></DIV></LI></OL>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >COM整套通讯很复杂，剖析其更本也没有什么必要，我们只要明确我们需要做什么即可。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >列集分为自定义列集和标准列集两种。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>连接过程（获取接口指针的过程） </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >当客户端调用诸如QueryInterface此类接口，获取新的Interface的时候，由于客户端获取到的指针是指向"代理对象"，调用到的QueryInterface就会转到COM动态创建的对象内部实现的函数，此函数通过COM库中的一些操作后，在组件这边开始列集操作，列集函数为：CoMarshalInterface。此函数内部会做几件事情： </SPAN></P>
<OL>
<LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >向对象查询是否支持IMarshal接口。 </SPAN></DIV>
</LI><LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >如果支持，调用IMarshal::GetUnMashalClass，获取代理对象的CLSID。如果不支持，使用确认代理对象CLSID_StdMarshal。 </SPAN></DIV>
</LI><LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >调用IMarshal::MarshalInterface建立列集数据包（用于代理对象和组件对象跨进程连接必需的信息）。 </SPAN></DIV></LI></OL>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >然后COM库将CLSID和列集数据包传给客户端。传输过程由SCM控制，它知道客户和组件能够通讯的各种方式。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >客户端COM库这边接到数据后，调用ConUnMarshalInterface： </SPAN></P>
<OL>
<LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >根据CLSID创建代理对象（通常都是标准的代理对象，COM库已经实现，对我们则是透明的）。 </SPAN></DIV>
</LI><LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >从代理对象中，请求IMarshal接口。 </SPAN></DIV>
</LI><LI>
<DIV style="TEXT-ALIGN: justify;"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >使用IMarshal::UnmarshalInterface得到指针接口，返回给客户。 </SPAN></DIV></LI></OL>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >代理对象一定是进程内的组件（由COM库来搞定），所以客户端对COM对象的调用时直接进行的。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><SPAN style="COLOR: #010001;"   >IMarshal</SPAN> : <SPAN style="COLOR: blue;"   >public</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown<BR></SPAN>{<BR><SPAN style="COLOR: blue;"   >public</SPAN>:<BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >GetUnmarshalClass</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pv</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >dwDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pvDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >mshlflags</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >CLSID</SPAN> *<SPAN style="COLOR: #010001;"   >pCid</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >GetMarshalSizeMax</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pv</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >dwDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pvDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >mshlflags</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> *<SPAN style="COLOR: #010001;"   >pSize</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >MarshalInterface</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: #010001;"   >IStream</SPAN> *<SPAN style="COLOR: #010001;"   >pStm</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pv</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >dwDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pvDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >mshlflags</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >UnmarshalInterface</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: #010001;"   >IStream</SPAN> *<SPAN style="COLOR: #010001;"   >pStm</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> **<SPAN style="COLOR: #010001;"   >ppv</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >ReleaseMarshalData</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: #010001;"   >IStream</SPAN> *<SPAN style="COLOR: #010001;"   >pStm</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >DisconnectObject</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> <SPAN style="COLOR: #010001;"   >dwReserved</SPAN>) = 0;<BR><BR>};<SPAN style="COLOR: #4c4c4c;"   ><BR></SPAN></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>使用连接跨进程调用过程（调用一般函数） </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >客户端通过代理对象调用接口函数，会转到存根/代理模块的代码中（对应的是*_proxy函数），进而进行Marshal处理，通过RPC/LPC方式发送到组件端。组件端COM组件接受到消息和数据，同样也会转调入根/代理模块的代码中（对应的是*_stub函数），存根函数里面会保存组件真正的对象指针，回调回组件端真正的代码。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >调用的驱动方式为： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >客户 &lt;-&gt; COM库 &lt;-&gt; 存根/代理模块 &lt;-&gt; RPC &lt;-&gt; COM库 &lt;-&gt; 存根/代理模块 &lt;-&gt; 组件。 </SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="http://img6.ph.126.net/xU78ybbqI78UYjN8Q4UP_w==/6597654706842712346.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img3.ph.126.net_YCJipGPVIEXGIc78edgvQg==_6597522765447380213.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >标准列集中，每个代理对象（ITF*）不仅实现了它自身代理的接口（组件对象的接口），还实现了IRpcProxyBuffer， </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>COM管理器如何创建接口代理对象和接口存根？ </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >注册表中： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >Interface </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;+ {IID} </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ProxyStubClsid32 = {CLSID} //此CLSID对应的是存根/代理对象的CLSID </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >在HEKY_CLASS_ROOT\CLSID中，能够找到此CLSID， </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >{CLSID} </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >&nbsp;&nbsp;&nbsp;&nbsp;InProcServer32 会存储真正的路径 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >如图： </SPAN></P>
<P><IMG title="COM 笔记 – 原理（高级） - Howie - Dspace"   alt=""   src="pic/img5.ph.126.net_lbFjGE4Y5ysZDLXUlekXLQ==_6597153329541746065.jpg"   ><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   > </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >当客户调用QueryInterface的时候，代码管理器会用如下代码创建代理对象： </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >clsid = LookUpInRegister(iid); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CoGetClassObject(clsid, CLSCTX_SERVER, NULL, IID_IPSFactoryBuffer, &amp;pPSFactory); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >pPSFactory-&gt;CreateProxy(pUnkOuter, riid, &amp;pProxy, &amp;piid); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >存根得到IPSFactoryBuffer后，调用CreateStub，创建了接口存根。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >clsid = LookUpInRegister(iid); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >CoGetClassObject(clsid, CLSCTX_SERVER, NULL, IID_IPSFactoryBuffer, &amp;pPSFactory); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >pPSFactory-&gt;CreateStub(iid, pUnkServer, &amp;pStub); </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >代理存根中，并没有使用IClassFactory创建，而是使用IPSFactoryBuffer。（原因我觉得是这俩个组件很特殊，存在形式和一般对象也不一样）。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><SPAN style="COLOR: #010001;"   >IPSFactoryBuffer</SPAN> : <SPAN style="COLOR: blue;"   >public</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown<BR></SPAN>{<BR><SPAN style="COLOR: blue;"   >public</SPAN>:<BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >CreateProxy</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown</SPAN> *<SPAN style="COLOR: #010001;"   >pUnkOuter</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >IRpcProxyBuffer</SPAN> **<SPAN style="COLOR: #010001;"   >ppProxy</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> **<SPAN style="COLOR: #010001;"   >ppv</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >CreateStub</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown</SPAN> *<SPAN style="COLOR: #010001;"   >pUnkServer</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >IRpcStubBuffer</SPAN> **<SPAN style="COLOR: #010001;"   >ppStub</SPAN>) = 0;<BR><BR>};<BR></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><STRONG>PRC通讯 </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><SPAN style="COLOR: #010001;"   >IRpcChannelBuffer</SPAN> : <SPAN style="COLOR: blue;"   >public</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown<BR></SPAN>{<BR><SPAN style="COLOR: blue;"   >public</SPAN>:<BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >GetBuffer</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >RPCOLEMESSAGE</SPAN> *<SPAN style="COLOR: #010001;"   >pMessage</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >SendReceive</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [out][in] */</SPAN> <SPAN style="COLOR: #010001;"   >RPCOLEMESSAGE</SPAN> *<SPAN style="COLOR: #010001;"   >pMessage</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >ULONG</SPAN> *<SPAN style="COLOR: #010001;"   >pStatus</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >FreeBuffer</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >RPCOLEMESSAGE</SPAN> *<SPAN style="COLOR: #010001;"   >pMessage</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >GetDestCtx</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: #010001;"   >DWORD</SPAN> *<SPAN style="COLOR: #010001;"   >pdwDestContext</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [out] */</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> **<SPAN style="COLOR: #010001;"   >ppvDestContext</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >IsConnected</SPAN>( <SPAN style="COLOR: blue;"   >void</SPAN>) = 0;<BR><BR>};<BR></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   >接口代理和存根通讯时，&nbsp;&nbsp;&nbsp;&nbsp;首先调用<SPAN style="COLOR: #010001;"   >IRpcChannelBuffer::GetBuffer获取一个数据缓冲区，然后调用SendReceive后，组件进程中的RPC通道就会调用接口存根的IRpcStubBuffer的Invoke成员函数，Invoke则调用组件对象的成员函数，返回结果。再次使用GetBuffer获取缓冲区，存放返回结果。存根接口返回，最终代理的SendReceive返回最终结果。这个过程可以是同步的，也可以是异步的。 </SPAN></SPAN></P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体;"   ><SPAN style="COLOR: #010001;"   >IRpcProxyBuffer</SPAN> : <SPAN style="COLOR: blue;"   >public</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown<BR></SPAN>{<BR><SPAN style="COLOR: blue;"   >public</SPAN>:<BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >Connect</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [unique][in] */</SPAN> <SPAN style="COLOR: #010001;"   >IRpcChannelBuffer</SPAN> *<SPAN style="COLOR: #010001;"   >pRpcChannelBuffer</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >Disconnect</SPAN>( <SPAN style="COLOR: blue;"   >void</SPAN>) = 0;<BR><BR>};&nbsp;&nbsp;&nbsp;&nbsp;<BR><BR><SPAN style="COLOR: #010001;"   >IRpcStubBuffer</SPAN> : <SPAN style="COLOR: blue;"   >public</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown<BR></SPAN>{<BR><SPAN style="COLOR: blue;"   >public</SPAN>:<BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >Connect</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >IUnknown</SPAN> *<SPAN style="COLOR: #010001;"   >pUnkServer</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >Disconnect</SPAN>( <SPAN style="COLOR: blue;"   >void</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >Invoke</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >RPCOLEMESSAGE</SPAN> *<SPAN style="COLOR: #010001;"   >_prpcmsg</SPAN>,<BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >IRpcChannelBuffer</SPAN> *<SPAN style="COLOR: #010001;"   >_pRpcChannelBuffer</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >IRpcStubBuffer</SPAN> *<SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >IsIIDSupported</SPAN>( <BR><SPAN style="COLOR: green;"   >/* [in] */</SPAN> <SPAN style="COLOR: #010001;"   >REFIID</SPAN> <SPAN style="COLOR: #010001;"   >riid</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >ULONG</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >CountRefs</SPAN>( <SPAN style="COLOR: blue;"   >void</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: #010001;"   >HRESULT</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >DebugServerQueryInterface</SPAN>( <BR><SPAN style="COLOR: blue;"   >void</SPAN> **<SPAN style="COLOR: #010001;"   >ppv</SPAN>) = 0;<BR><BR><SPAN style="COLOR: blue;"   >virtual</SPAN> <SPAN style="COLOR: blue;"   >void</SPAN> <SPAN style="COLOR: #010001;"   >STDMETHODCALLTYPE</SPAN> <SPAN style="COLOR: #010001;"   >DebugServerRelease</SPAN>( <BR><SPAN style="COLOR: blue;"   >void</SPAN> *<SPAN style="COLOR: #010001;"   >pv</SPAN>) = 0;<BR><BR>};<BR><SPAN style="COLOR: #4c4c4c;"   ></SPAN></SPAN></P>
<P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>安全性 </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>激活安全 </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >COM如何被安全启动，如果安全建立连接，保护公共资源，系统注册表等。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>调用安全 </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >调用组件之间传输的数据如何保护等。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   ><STRONG>多线程特性（套间） </STRONG></SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >线程 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >UI线程（包含一个消息循环），所有的消息都是按照一定顺序执行的，对于消息可以不做同步处理。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >工作线程。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >COM中，和UI线程对应的是套间线程，和工作线程对应的是自由线程。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >套间线程 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >属于此线程的COM对象，通过消息循环调用函数，其他线程若要调用此COM对象，不能直接调用，必须通过消息循环分发调用。因此，套间线程以外的线程只能通过代理/存根调用此对象。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >自由线程 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >属于此线程的COM对象，同一进程中任何线程都可以调用此对象，因此此对象需要做同步处理，以保证线程安全。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >若是进程外组件，无论其运行在套间线程还是自由线程，都是间接调用的，列集和散集的结果是自动实现了同步，对象不必做处理。 </SPAN></P>
<P><SPAN style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; COLOR: #4c4c4c;"   >具体细节，需要大量篇幅来写，不是笔记能做的完的。 </SPAN></P>
</body></html>