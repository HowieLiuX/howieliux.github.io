<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：ATL Under the Hood 5</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>ATL Under the Hood 5</h2>
<p align="right">发布时间：2011-11-29 11:10
<br>分类名称：ATL</p><br>
<p><span style="font-family:Verdana;"  ><span style="color:#ff9900; font-size:13pt;"  ><strong>Introduction<br></strong></span><span style="font-size:10pt;"  >Lots of people thing that ATL is made only for making COM components. But in fact you can create full flash windows based application using ATL by using the Windowing classes of ATL. Although you can convert your MFC based project to ATL but there is very little support for UI component in ATL, so you have to write lots of code yourself. For instance there is no Document/View in ATL and if you want to make it then you have to implement it yourself. In this part we are going to explore the windowing classes. We also try to explore the techniques which ATL uses to do this. WTL (Window Template Library), was untill now unsupported by Microsoft and is in fact one step forward towards making graphical application. WTL is based on ATL Windowing classes. <br>Before starting the discussion of any ATL based program let's start our discussion with the classic Hello world program. This program is completely written in SDK and almost all of us are already familiar with it. <br><strong>Program 66</strong>     <br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br></span>LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);</span><br></span><br><span style="color:blue;"  >int</span> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, </span><br>                   LPSTR lpCmdLine,  <span style="color:blue;"  >int</span> nCmdShow)<br>{<br>    <span style="color:blue;"  >char</span> szAppName[] = <span style="color:purple;"  >"Hello world"</span>;<br>    HWND hWnd;<br>    MSG msg;<br>    WNDCLASS wnd;<br>    <br>    wnd.cbClsExtra    = NULL;<br>    wnd.cbWndExtra    = NULL;<br>    wnd.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);<br>    wnd.hCursor    = LoadCursor(NULL, IDC_ARROW);<br>    wnd.hIcon        = LoadIcon(NULL, IDI_APPLICATION);<br>    wnd.hInstance    = hInstance;<br>    wnd.lpfnWndProc    = WndProc;<br>    wnd.lpszClassName    = szAppName;<br>    wnd.lpszMenuName    = NULL;<br>    wnd.style        = CS_HREDRAW | CS_VREDRAW;<br>    <br>    <span style="color:blue;"  >if</span> (!RegisterClass(&amp;wnd))<br>    {<br>        MessageBox(NULL, <span style="color:purple;"  >"Can not register window class"</span>, <span style="color:purple;"  >"Error"</span>, <br>                   MB_OK | MB_ICONINFORMATION);<br>    <span style="color:blue;"  >return</span> -<span style="color:navy;"  >1</span>;<br>    }<br>    <br>    hWnd = CreateWindow(szAppName, <span style="color:purple;"  >"Hello world"</span>, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <br>        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);<br>    <br>    ShowWindow(hWnd, nCmdShow);<br>    UpdateWindow(hWnd);<br>    <br>    <span style="color:blue;"  >while</span> (GetMessage(&amp;msg, NULL, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >0</span>))<br>    {<br>        DispatchMessage(&amp;msg);<br>    }<br>    <br>    <span style="color:blue;"  >return</span> msg.wParam;<br>}<br><br>LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br>{<br>    HDC hDC;<br>    PAINTSTRUCT ps;<br>    RECT rect;<br><br>    <span style="color:blue;"  >switch</span> (uMsg)<br>    {<br>    <span style="color:blue;"  >case</span> WM_PAINT:<br>        hDC = BeginPaint(hWnd, &amp;ps);<br>        GetClientRect(hWnd, &amp;rect);<br>        DrawText(hDC, <span style="color:purple;"  >"Hello world"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<br>        EndPaint(hWnd, &amp;ps);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>        PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>    }<br>    <br>    <span style="color:blue;"  >return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >There is nothing new in this program. This program just displays a window and display Hello world at center of this. <br>ATL is object oriented library, means you are using classes to do your work. Let's try to do the same thing ourselves and make some small classes to make our work easier. Ok we are going to make some classes for our work, but what would be the criteria for making classes? In other words how many classes are should make, what are their relationship, method and properties. I am not planning to discuss the whole object oriented theory and the process here to make quality library. To make my task similar I make group of related API's and put those related API in one class. I put all the API's, which deals with window in one class and it can be repeated to other type of API's like for font, file, menu etc. So I made a small class and put the entire API's whose first parameter is </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  > in that class. This class is nothing more than a thing wrapper on the Windows API's. My class Name is </span><span style="color:#990000; font-family:Courier New;"  >ZWindow</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >, you are free to choose whatever name you like. This class is something like this. <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >class</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>};<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here I put only those API's which are required at the moment. You may add all the API's in this class. The only advantage of this class is that now you don't have to pass the </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  > parameter for windowing API's, this class will pass that parameter itself. <br>Well nothing special till now. But what about our Window CallBack function? Remember the first parameter of that call back function is also </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >, so it should be member of this class according to our criteria. So I add our callback function in this class too. Now this class should be something like this. <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >class</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>    LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >switch</span> (uMsg)<br>        {<br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>            PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>        }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>    }<br>};<br></span><span style="font-family:Verdana; font-size:10pt;"  >You have to give the address of callback function in one field of </span><span style="color:#990000; font-family:Courier New;"  >WNDCLASS</span><span style="font-family:Verdana; font-size:10pt;"  > or </span><span style="color:#990000; font-family:Courier New;"  >WNDCLASSEX</span><span style="font-family:Verdana; font-size:10pt;"  > structure. And you give it something like this after creating the object of </span><span style="color:#990000; font-family:Courier New;"  >ZWindow</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > class. <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >    ZWindow zwnd;<br>    WNDCLASS wnd;<br><br>    wnd.lpfnWndProc = wnd.WndProc;<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >But when you compile this program this will give error something like this. <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >cannot convert from <span style="color:purple;"  >'long (__stdcall ZWindow::*)(struct HWND__ *,<br>   unsigned int,unsigned int,long)'</span> to <span style="color:purple;"  >'long (__stdcall *)(struct HWND__ *,<br>   unsigned int, unsigned int,long)<br></span></span><span style="font-family:Verdana; font-size:10pt;"  >The reason is you can not pass member function as a call back function. Why? Because in case of member function compiler automatically passes one parameter to the function and that parameter is the pointer of that class or in other words this pointer. So it means when you pass n parameters in the member function then compiler will pass n+1 parameters and the additional parameter is this pointer. The error message from the compiler shows this too that compiler can't convert member function to global function. <br>So what should we do if we want to use member function as a call back function? If we tell the compiler to not pass first parameter to the function some how then we can use the member function as a call back function. In C++ if we declare member function as a static then compiler doesn't pass this pointer, this is in fact the difference between static and non static member function. <br>So we made </span><span style="color:#990000; font-family:Courier New;"  >WndProc</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > static in ZWindow class. This technique is also use in case of threading where you want to use member function as a thread function then you make static member function as a thread function. <br>Here is update program which use ZWindow class. <br><strong>Program 67</strong>     <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>class</span> ZWindow</span><br></span>{</span><br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>    LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >switch</span> (uMsg)<br>        {<br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>            PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>        }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>    }<br>};<br><br><span style="color:blue;"  >int</span> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,  <br>    <span style="color:blue;"  >int</span> nCmdShow)<br>{<br>    <span style="color:blue;"  >char</span> szAppName[] = <span style="color:purple;"  >"Hello world"</span>;<br>    HWND hWnd;<br>    MSG msg;<br>    WNDCLASS wnd;<br>    ZWindow zwnd;<br>    <br>    wnd.cbClsExtra    = NULL;<br>    wnd.cbWndExtra    = NULL;<br>    wnd.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);<br>    wnd.hCursor        = LoadCursor(NULL, IDC_ARROW);<br>    wnd.hIcon        = LoadIcon(NULL, IDI_APPLICATION);<br>    wnd.hInstance        = hInstance;<br>    wnd.lpfnWndProc    = ZWindow::WndProc;<br>    wnd.lpszClassName    = szAppName;<br>    wnd.lpszMenuName    = NULL;<br>    wnd.style        = CS_HREDRAW | CS_VREDRAW;<br>    <br>    <span style="color:blue;"  >if</span> (!RegisterClass(&amp;wnd))<br>    {<br>        MessageBox(NULL, <span style="color:purple;"  >"Can not register window class"</span>, <span style="color:purple;"  >"Error"</span>, <br>                   MB_OK | MB_ICONINFORMATION);<br>    <span style="color:blue;"  >return</span> -<span style="color:navy;"  >1</span>;<br>    }<br>    <br>    hWnd = CreateWindow(szAppName, <span style="color:purple;"  >"Hello world"</span>, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <br>        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);<br><br>    zwnd.Attach(hWnd);<br>    <br>    zwnd.ShowWindow(nCmdShow);<br>    zwnd.UpdateWindow();<br><br>    <span style="color:blue;"  >while</span> (GetMessage(&amp;msg, NULL, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >0</span>))<br>    {<br>        DispatchMessage(&amp;msg);<br>    }<br>    <br>    <span style="color:blue;"  >return</span> msg.wParam;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program just shows the usage of </span><span style="color:#990000; font-family:Courier New;"  >ZWindow</span><span style="font-family:Verdana; font-size:10pt;"  >. And to be very honest this class do nothing special. It is just wrapper on Window API, the only advantage you get from this is that now you don't need to pass </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > as a parameter, but instead of this now you have to type the object name when calling member function. <br>Like before this you call function like this </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >    ShowWindow(hWnd, nCmdShow);<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >And now you call something like this </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >    zwnd.ShowWindow(nCmdShow);<br></span><span style="font-family:Verdana; font-size:10pt;"  >Not a big advantage till now. <br>Let's see how we can handle window message in the </span><span style="color:#990000; font-family:Courier New;"  >WndProc</span><span style="font-family:Verdana; font-size:10pt;"  >. In the previous program we handle only one function i.e. </span><span style="color:#990000; font-family:Courier New;"  >WM_DESTROY</span><span style="font-family:Verdana; font-size:10pt;"  >. If we want to handle more messages then add more case in the switch statement. Let's modify the </span><span style="color:#990000; font-family:Courier New;"  >WndProc</span><span style="font-family:Verdana; font-size:10pt;"  > to handle </span><span style="color:#990000; font-family:Courier New;"  >WM_PAINT</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >. It would be something like this. </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >switch</span> (uMsg)<br>{<br><span style="color:blue;"  >case</span> WM_PAINT:<br>    hDC = ::BeginPaint(hWnd, &amp;ps);<br>    ::GetClientRect(hWnd, &amp;rect);<br>    ::DrawText(hDC, <span style="color:purple;"  >"Hello world"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, DT_CENTER | DT_VCENTER  DT_SINGLELINE);<br>    ::EndPaint(hWnd, &amp;ps);<br>    <span style="color:blue;"  >break</span>;<br><br><span style="color:blue;"  >case</span> WM_DESTROY:<br>    ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >This code is perfectly valid and print "Hello World" in center of Window. But why use API's </span><span style="color:#990000; font-family:Courier New;"  >BeginPaint</span><span style="font-family:Verdana; font-size:10pt;"  >, </span><span style="color:#990000; font-family:Courier New;"  >GetClientRect</span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:#990000; font-family:Courier New;"  >EndPaint</span><span style="font-family:Verdana; font-size:10pt;"  > when it all should be a member function of ZWindow class according to our criteria, because all of these have </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > as a first parameter. <br>Because all those function are not static. And you can't call non static member function from static member function. Why? Because the difference is this pointer, non static member function has this pointer and static function doesn't have it. If we somehow pass this pointer to static member function then we can call the non static member function from static member function. Let's take a look at the following program. <br><strong>Program 68</strong>     <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> C </span><br></span>{</span><br><span style="color:blue;"  >public</span>:<br>    <span style="color:blue;"  >void</span> NonStaticFunc() <br>    {    <br>        cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"NonStaticFun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    }<br><br>    <span style="color:blue;"  >static</span>    <span style="color:blue;"  >void</span> StaticFun(C* pC) <br>    {<br>        cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"StaticFun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>        pC-<span style="color:blue;"  >&gt;</span>NonStaticFunc();<br>    }<br>};<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    C objC;<br>    C::StaticFun(&amp;objC);<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >StaticFun<br>NonStaticFun<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >So we can use the same technique here i.e. store the address of ZWindow object in a global variable and then call non static member function from that pointer. Here is update version of the previous program in which we are not calling windowing API directly. <br><strong>Program 69</strong>     <br></span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>class</span> ZWindow;</span><br></span><br></span>ZWindow* g_pWnd = NULL;<br><br><span style="color:blue;"  >class</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>    <span style="color:blue;"  >inline</span> HDC BeginPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::BeginPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL EndPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::EndPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL GetClientRect(LPRECT rect)<br>    {  <span style="color:blue;"  >return</span> ::GetClientRect(m_hWnd, rect); }<br><br>    BOOL Create(LPCTSTR szClassName, LPCTSTR szTitle, HINSTANCE hInstance, <br>                HWND hWndParent = <span style="color:navy;"  >0</span>,    DWORD dwStyle = WS_OVERLAPPEDWINDOW, <br>                DWORD dwExStyle = <span style="color:navy;"  >0</span>, HMENU hMenu = <span style="color:navy;"  >0</span>)<br>    {<br>        m_hWnd = ::CreateWindowEx(dwExStyle, szClassName, szTitle, dwStyle, <br>                                  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>                                  CW_USEDEFAULT, hWndParent, hMenu, hInstance, NULL);<br><br>    <span style="color:blue;"  >return</span> m_hWnd != NULL;<br>    }<br><br>    <span style="color:blue;"  >static</span> LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)<br>    {<br>        ZWindow* pThis = g_pWnd;<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>    <span style="color:blue;"  >switch</span> (uMsg)<br>        {<br>    <span style="color:blue;"  >case</span> WM_PAINT:<br>            hDC = pThis-<span style="color:blue;"  >&gt;</span>BeginPaint(&amp;ps);<br>            pThis-<span style="color:blue;"  >&gt;</span>GetClientRect(&amp;rect);<br>            ::DrawText(hDC, <span style="color:purple;"  >"Hello world"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, <br>                       DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>            pThis-<span style="color:blue;"  >&gt;</span>EndPaint(&amp;ps);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>            ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>        }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>    }<br>};<br><br><span style="color:blue;"  >int</span> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine,   <span style="color:blue;"  >int</span> nCmdShow)<br>{<br>    <span style="color:blue;"  >char</span> szAppName[] = <span style="color:purple;"  >"Hello world"</span>;<br>    MSG msg;<br>    WNDCLASS wnd;<br>    ZWindow zwnd;<br>    <br>    wnd.cbClsExtra    = NULL;<br>    wnd.cbWndExtra    = NULL;<br>    wnd.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);<br>    wnd.hCursor    = LoadCursor(NULL, IDC_ARROW);<br>    wnd.hIcon        = LoadIcon(NULL, IDI_APPLICATION);<br>    wnd.hInstance    = hInstance;<br>    wnd.lpfnWndProc    = zwnd.WndProc;<br>    wnd.lpszClassName    = szAppName;<br>    wnd.lpszMenuName    = NULL;<br>    wnd.style        = CS_HREDRAW | CS_VREDRAW;<br>    <br>    <span style="color:blue;"  >if</span> (!RegisterClass(&amp;wnd))<br>    {<br>        MessageBox(NULL, <span style="color:purple;"  >"Can not register window class"</span>, <span style="color:purple;"  >"Error"</span>, <br>                   MB_OK | MB_ICONINFORMATION);<br>    <span style="color:blue;"  >return</span> -<span style="color:navy;"  >1</span>;<br>    }<br><br>    g_pWnd = &amp;zwnd;<br>    zwnd.Create(szAppName, <span style="color:purple;"  >"Hell world"</span>, hInstance);<br>    zwnd.ShowWindow(nCmdShow);<br>    zwnd.UpdateWindow();<br><br>    <span style="color:blue;"  >while</span> (GetMessage(&amp;msg, NULL, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >0</span>))<br>    {<br>        DispatchMessage(&amp;msg);<br>    }<br>    <br>    <span style="color:blue;"  >return</span> msg.wParam;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >So we finally we have working program. Now let's take the advantage of Object Oriented programming. If we call function on each message and made that function virtual then we can call those functions when we inherit class from ZWindow. So we can customize the default behavior of ZWindow. Now the </span><span style="color:#990000; font-family:Courier New;"  >WndProc</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > is something like this </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >static</span> LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, <br>                                LPARAM lParam)<br>{<br>    ZWindow* pThis = g_pWnd;<br><br>    <span style="color:blue;"  >switch</span> (uMsg)<br>    {<br>    <span style="color:blue;"  >case</span> WM_CREATE:<br>        pThis-<span style="color:blue;"  >&gt;</span>OnCreate(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_PAINT:<br>        pThis-<span style="color:blue;"  >&gt;</span>OnPaint(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>        ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>    }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here </span><span style="color:#990000; font-family:Courier New;"  >OnCreate</span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:#990000; font-family:Courier New;"  >OnPaint</span><span style="font-family:Verdana; font-size:10pt;"  > are virtual function. And when we inherit the class from ZWindow then we can override all those function which we want to customize. Here is a complete program which shows the usage of </span><span style="color:#990000; font-family:Courier New;"  >WM_PAINT</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > message in the drive class. <br><strong>Program 70</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>class</span> ZWindow;</span><br></span><br></span>ZWindow* g_pWnd = NULL;<br><br><span style="color:blue;"  >class</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>    <span style="color:blue;"  >inline</span> HDC BeginPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::BeginPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL EndPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::EndPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL GetClientRect(LPRECT rect)<br>    {  <span style="color:blue;"  >return</span> ::GetClientRect(m_hWnd, rect); }<br><br>    BOOL Create(LPCTSTR szClassName, LPCTSTR szTitle, HINSTANCE hInstance, <br>                HWND hWndParent = <span style="color:navy;"  >0</span>, DWORD dwStyle = WS_OVERLAPPEDWINDOW, <br>                DWORD dwExStyle = <span style="color:navy;"  >0</span>, HMENU hMenu = <span style="color:navy;"  >0</span>)<br>    {<br>        m_hWnd = ::CreateWindowEx(dwExStyle, szClassName, szTitle, dwStyle, <br>                                  CW_USEDEFAULT,CW_USEDEFAULT, CW_USEDEFAULT, <br>                                  CW_USEDEFAULT, hWndParent, hMenu, hInstance, NULL);<br>    <span style="color:blue;"  >return</span> m_hWnd != NULL;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnPaint(WPARAM wParam, LPARAM lParam)<br>    {<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>        hDC = BeginPaint(&amp;ps);<br>        GetClientRect(&amp;rect);<br>        ::DrawText(hDC, <span style="color:purple;"  >"Hello world"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, <br>                   DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>        EndPaint(&amp;ps);<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnCreate(WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >static</span> LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, <br>                                    LPARAM lParam)<br>    {<br>        ZWindow* pThis = g_pWnd;<br><br>    <span style="color:blue;"  >switch</span> (uMsg)<br>        {<br>    <span style="color:blue;"  >case</span> WM_CREATE:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnCreate(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_PAINT:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnPaint(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>            ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>        }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>    }<br>};<br><br><span style="color:blue;"  >class</span> ZDriveWindow : <span style="color:blue;"  >public</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    LRESULT OnPaint(WPARAM wParam, LPARAM lParam)<br>    {<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>        hDC = BeginPaint(&amp;ps);<br>        GetClientRect(&amp;rect);<br>        SetBkMode(hDC, TRANSPARENT);<br>        DrawText(hDC, <span style="color:purple;"  >"Hello world From Drive"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, <br>                 DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>        EndPaint(&amp;ps);<br><br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br>};<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is a message "Hello world from Drive" in a window. Everything works fine until we work on one drive class. The problem started when we drive more than one class from ZWindow. Then all the message goes to the last drive class of ZWindow. Let's take a look at the following program. <br><strong>Program 71</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br></span><br>class</span> ZWindow;</span><br></span><br></span>ZWindow* g_pWnd = NULL;<br><br><span style="color:blue;"  >class</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    HWND m_hWnd;<br><br>    ZWindow(HWND hWnd = <span style="color:navy;"  >0</span>) : m_hWnd(hWnd) { }<br><br>    <span style="color:blue;"  >inline</span>    <span style="color:blue;"  >void</span> Attach(HWND hWnd)<br>    { m_hWnd = hWnd; }<br><br>    <span style="color:blue;"  >inline</span> BOOL ShowWindow(<span style="color:blue;"  >int</span> nCmdShow)<br>    { <span style="color:blue;"  >return</span> ::ShowWindow(m_hWnd, nCmdShow); }<br><br>    <span style="color:blue;"  >inline</span> BOOL UpdateWindow()<br>    {  <span style="color:blue;"  >return</span> ::UpdateWindow(m_hWnd); }<br><br>    <span style="color:blue;"  >inline</span> HDC BeginPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::BeginPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL EndPaint(LPPAINTSTRUCT ps)<br>    {  <span style="color:blue;"  >return</span> ::EndPaint(m_hWnd, ps); }<br><br>    <span style="color:blue;"  >inline</span> BOOL GetClientRect(LPRECT rect)<br>    {  <span style="color:blue;"  >return</span> ::GetClientRect(m_hWnd, rect); }<br><br>    BOOL Create(LPCTSTR szClassName, LPCTSTR szTitle, HINSTANCE hInstance, <br>                HWND hWndParent = <span style="color:navy;"  >0</span>, DWORD dwStyle = WS_OVERLAPPEDWINDOW, <br>                DWORD dwExStyle = <span style="color:navy;"  >0</span>, HMENU hMenu = <span style="color:navy;"  >0</span>, <span style="color:blue;"  >int</span> x = CW_USEDEFAULT, <br>    <span style="color:blue;"  >int</span> y = CW_USEDEFAULT, <span style="color:blue;"  >int</span> nWidth = CW_USEDEFAULT, <br>    <span style="color:blue;"  >int</span> nHeight = CW_USEDEFAULT)<br>    {<br>        m_hWnd = ::CreateWindowEx(dwExStyle, szClassName, szTitle, dwStyle, <br>                                   x, y, nWidth, nHeight, hWndParent, hMenu, <br>                                   hInstance, NULL);<br>    <span style="color:blue;"  >return</span> m_hWnd != NULL;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnPaint(WPARAM wParam, LPARAM lParam)<br>    {<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>        hDC = BeginPaint(&amp;ps);<br>        GetClientRect(&amp;rect);<br>        ::DrawText(hDC, <span style="color:purple;"  >"Hello world"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, <br>                   DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>        EndPaint(&amp;ps);<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnLButtonDown(WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnCreate(WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >virtual</span> LRESULT OnKeyDown(WPARAM wParam, LPARAM lParam)<br>    {<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    <span style="color:blue;"  >static</span> LRESULT CALLBACK StartWndProc(HWND hWnd, UINT uMsg, <br>                                          WPARAM wParam, LPARAM lParam)<br>    {<br>        ZWindow* pThis = g_pWnd;<br><br>    <span style="color:blue;"  >if</span> (uMsg == WM_NCDESTROY)<br>            ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br><br>    <span style="color:blue;"  >switch</span> (uMsg)<br>        {<br>    <span style="color:blue;"  >case</span> WM_CREATE:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnCreate(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_PAINT:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnPaint(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_LBUTTONDOWN:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnLButtonDown(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_KEYDOWN:<br>            pThis-<span style="color:blue;"  >&gt;</span>OnKeyDown(wParam, lParam);<br>    <span style="color:blue;"  >break</span>;<br><br>    <span style="color:blue;"  >case</span> WM_DESTROY:<br>            ::PostQuitMessage(<span style="color:navy;"  >0</span>);<br>    <span style="color:blue;"  >break</span>;<br>        }<br><br>    <span style="color:blue;"  >return</span> ::DefWindowProc(hWnd, uMsg, wParam, lParam);<br>    }<br>};<br><br><span style="color:blue;"  >class</span> ZDriveWindow1 : <span style="color:blue;"  >public</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    LRESULT OnPaint(WPARAM wParam, LPARAM lParam)<br>    {<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>        hDC = BeginPaint(&amp;ps);<br>        GetClientRect(&amp;rect);<br>        ::SetBkMode(hDC, TRANSPARENT);<br>        ::DrawText(hDC, <span style="color:purple;"  >"ZDriveWindow1"</span>, -<span style="color:navy;"  >1</span>, &amp;rect, <br>                   DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>        EndPaint(&amp;ps);<br><br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    LRESULT OnLButtonDown(WPARAM wParam, LPARAM lParam)<br>    {<br>        ::MessageBox(NULL, <span style="color:purple;"  >"ZDriveWindow1::OnLButtonDown"</span>, <span style="color:purple;"  >"Msg"</span>, MB_OK);<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>};<br><br><span style="color:blue;"  >class</span> ZDriveWindow2 : <span style="color:blue;"  >public</span> ZWindow<br>{<br><span style="color:blue;"  >public</span>:<br>    LRESULT OnPaint(WPARAM wParam, LPARAM lParam)<br>    {<br>        HDC hDC;<br>        PAINTSTRUCT ps;<br>        RECT rect;<br><br>        hDC = BeginPaint(&amp;ps);<br>        GetClientRect(&amp;rect);<br>        ::SetBkMode(hDC, TRANSPARENT);<br>        ::Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);<br>        ::DrawText(hDC, <span style="color:purple;"  >"ZDriveWindow2"</span>, -<span style="color:navy;"  >1</span>, &amp;rect,<br>                   DT_CENTER | DT_VCENTER | DT_SINGLELINE);<br>        EndPaint(&amp;ps);<br><br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>    LRESULT OnLButtonDown(WPARAM wParam, LPARAM lParam)<br>    {<br>        ::MessageBox(NULL, <span style="color:purple;"  >"ZDriveWindow2::OnLButtonDown"</span>, <span style="color:purple;"  >"Msg"</span>, MB_OK);<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>    }<br><br>};<br><br><span style="color:blue;"  >int</span> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                    LPSTR lpCmdLine,   <span style="color:blue;"  >int</span> nCmdShow)<br>{<br>    <span style="color:blue;"  >char</span> szAppName[] = <span style="color:purple;"  >"Hello world"</span>;<br>    MSG msg;<br>    WNDCLASS wnd;<br>    ZDriveWindow1 zwnd1;<br>    ZDriveWindow2 zwnd2;<br>    <br>    wnd.cbClsExtra        = NULL;<br>    wnd.cbWndExtra        = NULL;<br>    wnd.hbrBackground        = (HBRUSH)GetStockObject(GRAY_BRUSH);<br>    wnd.hCursor        = LoadCursor(NULL, IDC_ARROW);<br>    wnd.hIcon            = LoadIcon(NULL, IDI_APPLICATION);<br>    wnd.hInstance        = hInstance;<br>    wnd.lpfnWndProc        = ZWindow::StartWndProc;<br>    wnd.lpszClassName        = szAppName;<br>    wnd.lpszMenuName        = NULL;<br>    wnd.style            = CS_HREDRAW | CS_VREDRAW;<br>    <br>    <span style="color:blue;"  >if</span> (!RegisterClass(&amp;wnd))<br>    {<br>        MessageBox(NULL, <span style="color:purple;"  >"Can not register window class"</span>, <span style="color:purple;"  >"Error"</span>, <br>                     MB_OK | MB_ICONINFORMATION);<br>    <span style="color:blue;"  >return</span> -<span style="color:navy;"  >1</span>;<br>    }<br><br>    g_pWnd = &amp;zwnd1;<br>    zwnd1.Create(szAppName, <span style="color:purple;"  >"Hell world"</span>, hInstance);<br><br>    zwnd1.ShowWindow(nCmdShow);<br>    zwnd1.UpdateWindow();<br><br>    g_pWnd = &amp;zwnd2;<br><br>    zwnd2.Create(szAppName, <span style="color:purple;"  >"Hello world"</span>, hInstance, zwnd1.m_hWnd, <br>        WS_VISIBLE | WS_CHILD | ES_MULTILINE, NULL, NULL, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >150</span>, <span style="color:navy;"  >150</span>);<br><br>    <span style="color:blue;"  >while</span> (GetMessage(&amp;msg, NULL, <span style="color:navy;"  >0</span>, <span style="color:navy;"  >0</span>))<br>    {<br>        DispatchMessage(&amp;msg);<br>    }<br>    <br>    <span style="color:blue;"  >return</span> msg.wParam;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program shows the same message box no matter on which window you click. <br><img title="ATL Under the Hood 5 - Dsliu - Dspace"  src="pic/img8.ph.126.net_dPaKiBiJP21l4uXf3tQiZg==_2713981725461253188.jpg"  alt=""  ><br>You get the same message box no matter you click on any window. This means message is not properly propagate to appropriate window. In fact each window has their own window procedure, which handles all the messages of that window. But here we use the call back function of second drive class with the first window, so we can't executer the message handler of first window. <br>Here our main problem is to associate the callback function of window with appropriate window. Means </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  > should be associated with appropriate Drive class. So message should be go to right window. There can be more than one solution of this problem, let's take a look at each solution one by one. <br>The first obvious solution come in mind, which can be easily implemented is to make a global structure, which stores the </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  > with appropriate Drive class address. But there are two main problems with this approach. Fist the structure becomes larger and larger when more and more window will be added in the program. And second problem is that there is of course searching time involve in that global structure and it is time consuming to search it when that structure becomes very large. <br>The main purpose of ATL is to make as small as possible and as fast as possible. And this technique fails on both criteria. This method is not only slow but also consumes lots of memory when there are lots of window involves in the program. <br>The other possible solution is to use </span><span style="color:#990000; font-family:Courier New;"  >cbWndExtra</span><span style="font-family:Verdana; font-size:10pt;"  > field of </span><span style="color:#990000; font-family:Courier New;"  >WNDCLASS</span><span style="font-family:Verdana; font-size:10pt;"  > or </span><span style="color:#990000; font-family:Courier New;"  >WNDCLASSEX</span><span style="font-family:Verdana; font-size:10pt;"  > structure. There is still one question why not use </span><span style="color:#990000; font-family:Courier New;"  >cbClsExtra</span><span style="font-family:Verdana; font-size:10pt;"  > instead of </span><span style="color:#990000; font-family:Courier New;"  >cbWndExtra</span><span style="font-family:Verdana; font-size:10pt;"  >? The answer is simple </span><span style="color:#990000; font-family:Courier New;"  >cbClsExtra</span><span style="font-family:Verdana; font-size:10pt;"  > store the extra bytes for each class and </span><span style="color:#990000; font-family:Courier New;"  >cbWndExtra</span><span style="font-family:Verdana; font-size:10pt;"  > store extra byes for each window from the class. And you can create more than one window from the same class so if you use </span><span style="color:#990000; font-family:Courier New;"  >cbClsExtra</span><span style="font-family:Verdana; font-size:10pt;"  > then you can't distinguish the different window call back function from </span><span style="color:#990000; font-family:Courier New;"  >cbClsExtra</span><span style="font-family:Verdana; font-size:10pt;"  > because it is same of all those window which are create by the same class. And store the address of appropriate drive class in this field. <br>It seems good solution at lest seems better then the first one. But there are still two problems in this solution. The first one is that if user wants to use </span><span style="color:#990000; font-family:Courier New;"  >cbWndExtra</span><span style="font-family:Verdana; font-size:10pt;"  > then he/she might overwrite the data which is written by using this technique. So client of this class has to be careful not to lose that information when using </span><span style="color:#990000; font-family:Courier New;"  >cbWndExtra</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >. Ok fine, you have decided and documented that not use cbWndExtra when using your library, but there is still one more problem. This method is not very much fast, again against the rule of ATL, that ATL should be as small and as fast as possible. <br>ATL neither use first method nor second. The method which ATL used is called Thunk. Thunk is a small set of code to do some work and this term is used in different context. It may be possible that you have listen two type of Thunking <br><strong>Universal Thunking</strong>     <br>Universal Thunking enables to call 32-bit function from 16-bit code. Available on both Win 9x and Win NT/2000/XP. This is also known as Generic Thunking. <br><strong>General Thunking</strong>     <br>Generic Thunking enables to call 16-bit function from 32-bit code. It is available only on Win 9x because Win NT/2000/XP are true 32 bit operating system so there is no logical reason to call 16 bit function from 32 bit code. This is also known as Flat Thunking. <br>ATL doesn't use any of this, because you are not going to mix 16-bit and 32-bit code in ATL. In fact ATL insert a small code to call the correct Window procedure. <br>Lets star some basic concepts before the study of thunking of ATL. Take a look at the following simple program. <br><strong>Program 72</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >struct</span> S</span><br></span>{</span><br>    <span style="color:blue;"  >char</span> ch;<br>    <span style="color:blue;"  >int</span> i;<br>};<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of character = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(<span style="color:blue;"  >char</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of integer = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(<span style="color:blue;"  >int</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of structure = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(S) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >Size of character = <span style="color:navy;"  >1</span><br>Size of integer = <span style="color:navy;"  >4</span><br>Size of structure = <span style="color:navy;"  >8</span><br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The sum of the sizes of integer and character should be 5 not 8. Ok lets change a program little bit and add one more member variable into the program to see what's going on. <br><strong>Program 73</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >struct</span> S</span><br></span>{</span><br>    <span style="color:blue;"  >char</span> ch1;<br>    <span style="color:blue;"  >char</span> ch2;<br>    <span style="color:blue;"  >int</span> i;<br>};<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of character = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(<span style="color:blue;"  >char</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of integer = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(<span style="color:blue;"  >int</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of structure = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(S) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is same as previous one. So what is going on here? Change a program little bit more to see what is going on Under the Hood. <br><strong>Program 74</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >struct</span> S</span><br></span>{</span><br>    <span style="color:blue;"  >char</span> ch1;<br>    <span style="color:blue;"  >char</span> ch2;<br>    <span style="color:blue;"  >int</span> i;<br>}s;<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of ch1 = "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>)&amp;s.ch1 <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of ch2 = "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>)&amp;s.ch2 <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Address of int = "</span>    <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>)&amp;s.i <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >Address of ch1 = <span style="color:navy;"  >4683576</span><br>Address of ch2 = <span style="color:navy;"  >4683577</span><br>Address of <span style="color:blue;"  >int</span> = <span style="color:navy;"  >4683580</span><br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This is due to word alignment of structure and union members. If you notice carefully then you can conclude this that each variable which is outside the structure is store at address which is dividable of 4. The reason of this is to increase the performance. So here structure allocate at the multiple of 4 i.e. at memory location 4683576 i.e. ch1 has the same address. Member ch2 store just next to this memory location and int I store at memory location 4683580, why not at 4683578, because this is not dividable of 4. Now there is a question what is at memory location 4683578 and 4683579? The answer is garbage if variable is made local and zero if it is made static or global. Let's take a look at the following program to better understand this. <br><strong>Program 75</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >struct</span> S</span><br></span>{</span><br>    <span style="color:blue;"  >char</span> ch1;<br>    <span style="color:blue;"  >char</span> ch2;<br>    <span style="color:blue;"  >int</span> i;<br>};<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    S s = { <span style="color:purple;"  >'A'</span>, <span style="color:purple;"  >'B'</span>, <span style="color:navy;"  >10</span>};<br><br>    <span style="color:blue;"  >void</span>* pVoid = (<span style="color:blue;"  >void</span>*)&amp;s;<br>    <span style="color:blue;"  >char</span>* pChar = (<span style="color:blue;"  >char</span>*)pVoid;<br><br>    cout <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >char</span>)*(pChar + <span style="color:navy;"  >0</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >char</span>)*(pChar + <span style="color:navy;"  >1</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >char</span>)*(pChar + <span style="color:navy;"  >2</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >char</span>)*(pChar + <span style="color:navy;"  >3</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    cout <span style="color:blue;"  >&lt;&lt;</span> (<span style="color:blue;"  >int</span>)*(pChar + <span style="color:navy;"  >4</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-size:9pt;"  ><span style="font-family:Courier New;"  >A<br>B<br></span><span style="font-family:Tahoma;"  >?</span><span style="font-family:Courier New;"  ><br></span><span style="font-family:Tahoma;"  >?</span><span style="font-family:Courier New;"  ><br><span style="color:navy;"  >10</span><br></span></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Out put of this program clearly shows that those spaces contain garbage as show in the diagram. <br><img title="ATL Under the Hood 5 - Dsliu - Dspace"  src="pic/img3.ph.126.net_Up0lgIM-1Wh_if5cge5hLQ==_2713981725461253193.jpg"  alt=""  ><br>Now if we want to avoid waste those space then what should we do? We have two option, either use the compiler switch /Zp or use #pragma statement before declare the structure. <br><strong>Program 76</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:navy;"  >#pragma</span> pack(push, <span style="color:navy;"  >1</span>)</span><br>struct</span> S</span><br>{<br>    <span style="color:blue;"  >char</span> ch;<br>    <span style="color:blue;"  >int</span> i;<br>};<br><span style="color:navy;"  >#pragma</span> pack(pop)<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Size of structure = "</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:blue;"  >sizeof</span>(S) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >Size of structure = <span style="color:navy;"  >5</span><br><img title="ATL Under the Hood 5 - Dsliu - Dspace"  src="pic/img9.ph.126.net_nDs_EGOPHV4Bf1zsf9Hx_g==_59109745126350759.jpg"  alt=""  ></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  ><br>It means now there is no space for word alignment. In fact ATL use this technique to make thunk. ATL use one structure, which are not using word alignment and use it to store direct machine code of microprocessor. </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#pragma</span> pack(push,<span style="color:navy;"  >1</span>)<br><span style="color:green;"  ><em>// structure to store the machine code<br></em><span style="color:blue;"  >struct</span> Thunk</span><br>{<br>    <span style="color:#339999;"  >BYTE</span>    m_jmp;          <span style="color:green;"  ><em>// op code of jmp instruction<br></em></span>    DWORD   m_relproc;      <span style="color:green;"  ><em>// relative jmp<br></em></span>};<br><span style="color:navy;"  >#pragma</span> pack(pop)<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This type of structure can contain then thunk code, which can be executed on the fly. Let's take a look at the simple case in which we are going to execute our required function by thunk. <br><strong>Program 77</strong>    </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br>#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >windows.h<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>             <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> C;</span><br></span><br></span>C* g_pC = NULL;</span><br></span><br>typedef</span>     <span style="color:blue;"  >void</span>(*pFUN)();</span><br><br><span style="color:navy;"  >#pragma</span> pack(push,<span style="color:navy;"  >1</span>)<br><span style="color:green;"  ><em>// structure to store the machine code<br></em><span style="color:blue;"  >struct</span> Thunk</span><br>{<br>    <span style="color:#339999;"  >BYTE</span>    m_jmp;          <span style="color:green;"  ><em>// op code of jmp instruction<br></em></span>    DWORD   m_relproc;      <span style="color:green;"  ><em>// relative jmp<br></em></span>};<br><span style="color:navy;"  >#pragma</span> pack(pop)<br><br><span style="color:blue;"  >class</span> C<br>{<br><span style="color:blue;"  >public</span>:<br>    Thunk    m_thunk;<br><br>    <span style="color:blue;"  >void</span> Init(pFUN pFun, <span style="color:blue;"  >void</span>* pThis)<br>    {<br>    <span style="color:green;"  ><em>// op code of jump instruction<br></em></span>        m_thunk.m_jmp = 0xe9;<br>    <span style="color:green;"  ><em>// address of the appripriate function<br></em></span>        m_thunk.m_relproc = (<span style="color:blue;"  >int</span>)pFun - ((<span style="color:blue;"  >int</span>)this+sizeof(Thunk));<br><br>        FlushInstructionCache(GetCurrentProcess(), <br>                                &amp;m_thunk, <span style="color:blue;"  >sizeof</span>(m_thunk));<br>    }<br><br>    <span style="color:green;"  ><em>// this is cour call back function<br></em></span>    <span style="color:blue;"  >static</span>    <span style="color:blue;"  >void</span> CallBackFun()<br>    {<br>        C* pC = g_pC;<br><br>    <span style="color:green;"  ><em>// initilize the thunk<br></em></span>        pC-<span style="color:blue;"  >&gt;</span>Init(StaticFun, pC);<br><br>    <span style="color:green;"  ><em>// get the address of thunk code<br></em></span>        pFUN pFun = (pFUN)&amp;(pC-<span style="color:blue;"  >&gt;</span>m_thunk);<br><br>    <span style="color:green;"  ><em>// start executing thunk code which will call StaticFun<br></em></span>        pFun();<br><br>        cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"C::CallBackFun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    }<br><br>    <span style="color:blue;"  >static</span>    <span style="color:blue;"  >void</span> StaticFun()<br>    {<br>        cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"C::StaticFun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>    }<br>};<br><br><span style="color:blue;"  >int</span> main()<br>{<br>    C objC;<br>    g_pC = &amp;objC;<br>    C::CallBackFun();<br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  >C::StaticFun<br>C::CallBackFun<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here StaticFun is called through the thunk, which is initialized in the Init member function. The execution of program is something like this <br>CallBackFun<br>Init (to initialize the thunk)<br>Get the address of thunk<br>Execute thunk<br>Thunk code call StaticFun<br><img title="ATL Under the Hood 5 - Dsliu - Dspace"  src="pic/img3.ph.126.net_VjEIcrD59eTYqn-IezkBNQ==_2777313595221157353.jpg"  alt=""  ><br>ATL use the same technique to call the correct Callback function but did one more thing before calling the function. Now ZWindow has one more virtual function </span><span style="color:#990000; font-family:Courier New;"  >ProcessWindowMessage</span><span style="font-family:Verdana; font-size:10pt;"  > which doesn't do anything in this class. But every drive class of ZWindow override this to handle their own message. The process is same we store the address of ZWindow's drive class in one pointer to call the drive class virtual function, but now the </span><span style="color:#990000; font-family:Courier New;"  >WindowProc</span><span style="font-family:Verdana; font-size:10pt;"  > name is </span><span style="color:#990000; font-family:Courier New;"  >StartWndProc</span><span style="font-family:Verdana; font-size:10pt;"  >. Here ATL use the technique to replace the </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  > with this pointer. But what about </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  >, do we loose it? In fact we have already store the </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > in ZWindow class member variable. <br>To achieve this we ATL use little bit bigger structure as compare to previous program. </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#pragma</span> pack(push,<span style="color:navy;"  >1</span>)<br><span style="color:blue;"  >struct</span> _WndProcThunk<br>{<br>    DWORD   m_mov;    <span style="color:green;"  ><em>// mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)<br></em></span>    DWORD   m_this;<br>    <span style="color:#339999;"  >BYTE</span>    m_jmp;    <span style="color:green;"  ><em>// jmp WndProc<br></em></span>    DWORD   m_relproc;    <span style="color:green;"  ><em>// relative jmp<br></em></span>};<br><span style="color:navy;"  >#pragma</span> pack(pop)<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >And at the time of initialization write the op code of "mov dword ptr [esp +4], pThis". It is something like this. </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >void</span> Init(WNDPROC proc, <span style="color:blue;"  >void</span>* pThis)<br>{<br>    thunk.m_mov = 0x042444C7;  <span style="color:green;"  ><em>//C7 44 24 04<br></em></span>    thunk.m_this = (DWORD)pThis;<br>    thunk.m_jmp = 0xe9;<br>    thunk.m_relproc = (<span style="color:blue;"  >int</span>)proc - ((<span style="color:blue;"  >int</span>)this+sizeof(_WndProcThunk));<br><br>    FlushInstructionCache(GetCurrentProcess(), &amp;thunk, <span style="color:blue;"  >sizeof</span>(thunk));<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >And after initialize the thunk code, get the address of thunk and set the new call back function to thunk code. And then thunk code will call </span><span style="color:#990000; font-family:Courier New;"  >WindowProc</span><span style="font-family:Verdana; font-size:10pt;"  >, but now the first parameter is not </span><span style="color:#990000; font-family:Courier New;"  >HWND</span><span style="font-family:Verdana; font-size:10pt;"  >, in fact it is this pointer. So we can safely cast it into ZWindow* and call the </span><span style="color:#990000; font-family:Courier New;"  >ProcessWindowMessage</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > function. </span><span style="font-size:8pt;"  ><br></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >static</span> LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, <br>                                   WPARAM wParam, LPARAM lParam)<br>{<br>    ZWindow* pThis = (ZWindow*)hWnd;<br><br>    <span style="color:blue;"  >if</span> (uMsg == WM_NCDESTROY)<br>        PostQuitMessage(<span style="color:navy;"  >0</span>);<br><br>    <span style="color:blue;"  >if</span> (!pThis-<span style="color:blue;"  >&gt;</span>ProcessWindowMessage(pThis-<span style="color:blue;"  >&gt;</span>m_hWnd, uMsg, wParam, lParam))<br>    <span style="color:blue;"  >return</span> ::DefWindowProc(pThis-<span style="color:blue;"  >&gt;</span>m_hWnd, uMsg, wParam, lParam);<br>    <span style="color:blue;"  >else</span><br>    <span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now the correct window procedure will be called for each window. The whole process is shown in the following diagram. <br><img title="ATL Under the Hood 5 - Dsliu - Dspace"  src="pic/img4.ph.126.net_2eiFLCYB8TlKFyPMRmhn5g==_1286059168608105594.jpg"  alt=""  ><br>The complete code of the following program is attached with the following article due to the length of code. Hope to explore the other mysterious of ATL in coming part of this series. </span></p>
</body></html>