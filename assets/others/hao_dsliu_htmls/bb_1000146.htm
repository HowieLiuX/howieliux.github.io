<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] source insight分析WRK源码</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] source insight分析WRK源码</h2>
<p align="right">发布时间：2012-6-4 01:10
<br>分类名称：WRK</p><br>
<p><span style="font-family:宋体; font-size:12pt;"  >出处：http://blog.csdn.net/better0332/article/details/5689193 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >source insight是一个出色的程序编辑器和代码浏览器，利用好它会给编写和阅读源代码带来极大的方便。想要配置好source insight可不是一件轻松的事，我比较喜欢深色背景有利于保护眼睛，但同时也必须更改代码颜色来匹配背景色，source insight的很多窗口、选项都可以指定字体、颜色，实在让人犯晕！最麻烦的是源码窗口的配置了，这里简单提一下，source insight的最终配色是由Style Properties决定的（右键菜单--&gt;Style Properties） </span></p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img1.ph.126.net_Zg82saqfQ-r1GAb9DU-JOw==_1300132917444115401.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >左边一栏是风格名，选中的是当前光标下的风格名，这些风格之间是有继承关系的，可以看到有很多=号，这代表继承了父风格（Parent Style），pick则是让你单独设置，最右边还可以导入、导出、添加风格等。所有风格最终由Default Text继承而来的，Font Name是灰的，它由Document Options（Alt+T）中的<span style="color:red;"  >当前文档类型</span> Screen Fonts决定的（所以不同的文件类型，如C，Python，Java它们的字体可以不同的）。Background是由 Options--&gt;Preferences--&gt;Colors中的Window Background决定的，其实Default Text的背景就是源码窗口的背景。Foreground也一样，pick了它等于设置了 Options--&gt;Preferences--&gt;Colors中的Default Text。我也晕了，汗…… </span></p><p><span style="font-family:宋体; font-size:12pt;"  >正是这些风格让source insight五彩缤纷： </span></p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img3.ph.126.net_Oe1vcf_Qf6HhVxOcRaCcHQ==_2720455649926082473.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p><span style="font-family:宋体; font-size:12pt;"  >还要提一句，<span style="color:black; background-color:white;"  >source</span><span style="background-color:white;"  >    </span>insight中还有一个Draft View（Alt+F12），在这个模式中会忽略Style Properties中字体部分设置，统一改用Draft View（见左边栏）中设置的字体。我制作了一个背景为深黑色，字体为Fixdays的配置文件（包含其它设置）让大家下载：<a rel="nofollow" href="http://download.csdn.net/source/2480193"  ><span style="color:blue; text-decoration:underline;"  >http://download.csdn.net/source/2480193</span></a>   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >罗嗦了半天，WRK还没说呢，关于如何使用请看<a rel="nofollow" href="http://www.sourceinsight.com.cn/tech3.htm"  ><span style="color:blue; text-decoration:underline;"  >中文官网的文章</span></a> 。source insight分析完WRK后大家肯定会发现连IRP、DEVICE_OBJECT这样的结构都没法解析，其实罪魁祸首就是那些函数宏，比如_IRP前面 的DECLSPEC_ALIGN（），如果用我前面的配置文件调过颜色的话一眼就可以看出，source insight把它当成了Declare Function了，这些宏大多起修饰作用并无实质影响，但一样的宏在MS的代码中数不胜数（如非vc6的crt，头文件，连printf都解析不来）。 可以看看这个帖子<a rel="nofollow" href="http://topic.csdn.net/u/20100613/16/b32fc799-c7f2-4648-9d91-cc933f9ffeb8.html"  ><span style="color:blue; text-decoration:underline;"  >http://topic.csdn.net/u/20100613/16/b32fc799-c7f2-4648-9d91-cc933f9ffeb8.html</span></a> ，我一开始以为是BUG，但source insight提供了解决方案，那就是Token Macro。Token Macro就是source insight的预处理器，它可以像C预处理器那样展开宏，正是为了对抗那些混淆source insight的宏而设计的。Token Macro是一个以.tom结尾的文件，对C/C++来说是C.tom，只要把它放在source insight创建工程的目录下，就可以立马起作用（不用重新parse一遍，不过有些时候还是parse一遍好），它会跟程序目录下的全局C.tom结 合去展开宏。Token Macro编写非常简单，跟#define语法差不多（但没它强大）。大家看看我针对WRK做的C.tom就明白了，由于大多数函数宏只起修饰作用不会影 响代码的解析，所以我把大多数宏做成了空宏。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >下载：<a rel="nofollow" href="http://download.csdn.net/source/2480426"  ><span style="color:blue; text-decoration:underline;"  >http://download.csdn.net/source/2480426</span></a>   </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >另外条件编译也是一个可能让source insight分析出错的地方，默认它会分析所有的条件分支。但碰到这样的情形就糟糕了： </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>[cpp]</strong>    <a title="view plain" rel="nofollow" href="http://blog.csdn.net/better0332/article/details/5689193"  ><span style="color:blue; text-decoration:underline;"  >view plain</span></a><a title="copy" rel="nofollow" href="http://blog.csdn.net/better0332/article/details/5689193"  ><span style="color:blue; text-decoration:underline;"  >copy</span></a>   </span></p><ol><li><span style="font-family:宋体; font-size:12pt;"  >void&nbsp;MyFunc&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#ifdef&nbsp;XYZ&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;(int&nbsp;param1,&nbsp;int&nbsp;param2)&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#else&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;(long&nbsp;param1,&nbsp;long&nbsp;param2)&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#endif&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >{&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;…&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >}&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >void&nbsp;DoThing(&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;param1,&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#ifdef&nbsp;ABC&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;param2)&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#else&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;param2,&nbsp;param3)&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >#endif&nbsp;&nbsp; </span></li></ol><p><span style="font-family:宋体; font-size:12pt;"  >很不幸，WRK中也有这样的问题，这个可以通过添加Condition的方法解决。 </span></p><p><span style="font-family:宋体; font-size:12pt;"  >我在Global Conditons中添加了; </span></p><ul><li><span style="font-family:宋体; font-size:12pt;"  >MIDL_PASS&nbsp;&nbsp;&nbsp; 0 </span></li><li><span style="font-family:宋体; font-size:12pt;"  >__midl&nbsp;&nbsp;&nbsp; 0 </span></li></ul><p><span style="font-family:宋体; font-size:12pt;"  >Project-Specific conditions添加了： </span></p><ul><li><span style="font-family:宋体; font-size:12pt;"  >_AMD64_&nbsp;&nbsp;&nbsp; 0 </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_MSC_VER&nbsp;&nbsp;&nbsp; 1300 </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_NDIS_&nbsp;&nbsp;&nbsp; 1  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_NTDDK_&nbsp;&nbsp;&nbsp; 1  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_NTIFS_&nbsp;&nbsp;&nbsp; 1  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_WIN64&nbsp;&nbsp;&nbsp; 0  </span></li><li><span style="font-family:宋体; font-size:12pt;"  >_X86_&nbsp;&nbsp;&nbsp; 1 </span></li></ul><p><span style="font-family:宋体; font-size:12pt;"  >这样不符合条件的分支代码会不进行解析，用灰色表示。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >另外，<span style="color:black; background-color:white;"  >source</span><span style="background-color:white;"  >    </span>insight还有一个小BUG，用typedef定义函数指针类型时，当函数指针返回类型（也用typedef定义）和函数指针类型定义在同一行时，函数指针返回类型无法解析。如： </span></p><p><span style="font-family:宋体; font-size:12pt;"  ><strong>[cpp]</strong>    <a title="view plain" rel="nofollow" href="http://blog.csdn.net/better0332/article/details/5689193"  ><span style="color:blue; text-decoration:underline;"  >view plain</span></a><a title="copy" rel="nofollow" href="http://blog.csdn.net/better0332/article/details/5689193"  ><span style="color:blue; text-decoration:underline;"  >copy</span></a>   </span></p><ol><li><span style="font-family:宋体; font-size:12pt;"  >typedef&nbsp;&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >NTSTATUS&nbsp;(*WMIENTRY)(&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >……)；//NTSTATUS无法解析&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >typedef&nbsp;NTSTATUS&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >(*WMIENTRY)(&nbsp;&nbsp; </span></li><li><span style="font-family:宋体; font-size:12pt;"  >……)；//NTSTATUS可以解析&nbsp;&nbsp; </span></li></ol><p><span style="font-family:宋体; font-size:12pt;"  >还有typedef定义函数指针类型时，函数的参数也都是不染色！这个问题似乎没有什么解决方法，用Custom Parsing也无济于事。 </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >还有一种情况会让source insight解析出错，比如IopfCompleteRequest、NtQueryEaFile函数，在函数名和{之间有一段多行宏，这样 source insight就解析的有问题了。这应该是个BUG，不知道大家有什么解决办法，我迫不得已只好挪动一下宏的位置！ </span></p><p>&nbsp; &nbsp;</p><p><span style="font-family:宋体; font-size:12pt;"  >现在几乎所有的问题都解决了，代码中都染上颜色了吧，呵呵…… </span></p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img1.ph.126.net_cTHgWCErbOoCeGrNKzsuqA==_606860049805768311.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img9.ph.126.net_NOVlZLhR7AXYNUnq34E60A==_1280992619027779789.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img5.ph.126.net_Qot8BQjXY1VPe7D9SVRNgA==_1559652845971338405.jpg"  alt=""  ><span style="font-family:宋体; font-size:12pt;"  >   </span></p><p>&nbsp; &nbsp;</p><p><img title="[转] source insight分析WRK源码 - Howie - Dspace"  src="pic/img8.ph.126.net_O13_mK_jkQ568L4_DMxgug==_6597257783144447758.jpg"  alt=""  ></p>更新一下Project-Specific conditions：<br>AMD64 0<br>_AMD64_ 0<br>__BUILDMACHINE__ WRK1.2(university)<br>CONDITION_HANDLING 1<br>DBG 0<br>DEVL 1<br>FPO 0<br>_MSC_VER 1300<br>NDEBUG 1<br>_NDIS_ 0<br>_NT1X_ 100<br>_NTDDK_ 1<br>_NTIFS_ 0<br>NTOS_KERNEL_RUNTIME 1<br>_NTSYSTEM_ 1<br>NT_INST 0<br>NT_SMT 1<br>STD_CALL 1<br>WIN32 100<br>_WIN32_IE 0x0603<br>WIN32_LEAN_AND_MEAN 1<br>_WIN32_WINNT 0x0502<br>_WIN64 0<br>WINNT 1<br>WINVER 0x0502<br>_X86_ 1<br>i386 1
</body></html>