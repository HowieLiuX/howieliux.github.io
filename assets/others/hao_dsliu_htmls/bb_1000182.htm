<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：ATL Under the Hood 3</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>ATL Under the Hood 3</h2>
<p align="right">发布时间：2011-11-29 10:47
<br>分类名称：ATL</p><br>
<p><span style="font-family:Verdana;"  ><span style="color:#ff9900; font-size:13pt;"  ><strong>Introduction<br></strong></span><span style="font-size:10pt;"  >One can enjoy the study of ATL if he/she is black belt in Templates. In this episode I will try to explain some of the template techniques which ATL uses. I don't guarantee that you will become a black belt in templates after reading this episode, but I am trying my best that you will feel more comfortable with ATL source code after reading this. <br></span><span style="color:#ff9900;"  ><strong>Program 35<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br></span>T Maximum(const</span> T&amp; a, <span style="color:blue;"  >const</span> T&amp; b) {</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a <span style="color:blue;"  >&gt;</span> b ? a : b;<br>}<br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum(<span style="color:purple;"  >'A'</span>, <span style="color:purple;"  >'B'</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >10<br>B<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Here we don't need to overload the function for int and char data type due to template function. Here one thing is important that both parameter of the function should have the same data type. But if we want to pass different data type then we have to tell the compiler that which data type will be considered.<br></span><span style="color:#ff9900;"  ><strong>Program 36<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br></span>T Maximum(const</span> T&amp; a, <span style="color:blue;"  >const</span> T&amp; b) {</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a <span style="color:blue;"  >&gt;</span> b ? a : b;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum<span style="color:blue;"  >&lt;int&gt;</span>(<span style="color:navy;"  >5</span>, <span style="color:purple;"  >'B'</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum<span style="color:blue;"  >&lt;char&gt;</span>(<span style="color:navy;"  >5</span>, <span style="color:purple;"  >'B'</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >66<br>B<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >We can make the class template too. Here is simplified version of template stack class.<br></span><span style="color:#ff9900;"  ><strong>Program 37<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Stack {</span><br>private</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;T* m_pData;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iTop;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack(<span style="color:blue;"  >int</span> p_iSize = <span style="color:navy;"  >0</span>) : m_iTop(<span style="color:navy;"  >0</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_pData = <span style="color:blue;"  >new</span> T[p_iSize];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Push(T p_iData) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_pData[m_iTop++] = p_iData;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Pop() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[--m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Top() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;~Stack() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >if</span> (m_pData) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >delete</span> [] m_pData;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack(<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; <span style="color:blue;"  >operator</span> = (<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;int&gt;</span> a(<span style="color:navy;"  >10</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >20</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >30</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >There isn't any robust error checking in this program, but the purpose of this program is to show the usage of template not making a stack class used professionally.<br>The output of this program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >30<br>20<br>10<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >We can also pass the data type as a template argument and assign a default value to it. Let's change program 36 little bit and pass the size of stack as a template parameter rather than constructor parameter.<br></span><span style="color:#ff9900;"  ><strong>Program 38<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T, <span style="color:blue;"  >int</span> iSize = <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Stack {</span><br><span style="color:blue;"  >private</span>:</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;T m_pData[iSize];</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iTop;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack() : m_iTop(<span style="color:navy;"  >0</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Push(T p_iData) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_pData[m_iTop++] = p_iData;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Pop() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[--m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Top() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack(<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; <span style="color:blue;"  >operator</span> = (<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;int</span>, <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span> a;</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >10</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >20</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.Push(<span style="color:navy;"  >30</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> a.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is same as pervious program. The important part of this program is.<br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T, <span style="color:blue;"  >int</span> iSize = <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span><br></span></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Now there is a question which approach is better?<strong> Passing template parameter is always faster then passing parameter by constructor.</strong> Why? Because when you pass stack size in template parameter then the array of given data type is created automatic (i.e. created on stack), however passing parameter by constructor means constructor has to allocate memory during run time by new or malloc family of functions. If we are sure that we are not going to change the size of stack once we made this, as we have done in above program by making copy constructor and assignment operator private, then use template parameter is better approach.<br>You can also pass user define class as a parameter in place of type parameter, but be sure that class have all the overloaded operators which is used in that template function or template class. <br>E.g. take a look at Maximum function of program 35. This program use one operator &gt;, so if we pass our own class then that class must have overloaded &gt; operator. Here is a program which shows this. <br></span><span style="color:#ff9900;"  ><strong>Program 39<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br></span>T Maximum(const</span> T&amp; a, <span style="color:blue;"  >const</span> T&amp; b) {</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a <span style="color:blue;"  >&gt;</span> b ? a : b;<br>}<br><br><span style="color:blue;"  >class</span> Point {<br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_x, m_y;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Point(<span style="color:blue;"  >int</span> p_x = <span style="color:navy;"  >0</span>, <span style="color:blue;"  >int</span> p_y = <span style="color:navy;"  >0</span>) : m_x(p_x), m_y(p_y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >bool</span>    <span style="color:blue;"  >friend</span>    <span style="color:blue;"  >operator</span>    <span style="color:blue;"  >&gt;</span> (<span style="color:blue;"  >const</span> Point&amp; lhs, <span style="color:blue;"  >const</span> Point&amp; rhs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> lhs.m_x <span style="color:blue;"  >&gt;</span> rhs.m_x &amp;&amp; lhs.m_y <span style="color:blue;"  >&gt;</span> rhs.m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >friend</span> ostream&amp; <span style="color:blue;"  >operator</span>    <span style="color:blue;"  >&lt;&lt;</span> (ostream&amp; os, <span style="color:blue;"  >const</span> Point&amp; p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> os <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"("</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_x <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >", "</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_y  <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >")"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Point a(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>), b(<span style="color:navy;"  >15</span>, <span style="color:navy;"  >20</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum(a, b) <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >(15, 20)<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >We can also pass the template class as a template parameter. Let's make this Point class template and pass it as a template parameter to Stack template class.<br></span><span style="color:#ff9900;"  ><strong>Program 40<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Point {</span><br>private</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;T m_x, m_y;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Point(T p_x = <span style="color:navy;"  >0</span>, T p_y = <span style="color:navy;"  >0</span>) : m_x(p_x), m_y(p_y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >bool</span>    <span style="color:blue;"  >friend</span>    <span style="color:blue;"  >operator</span>    <span style="color:blue;"  >&gt;</span> (<span style="color:blue;"  >const</span> Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; lhs, <span style="color:blue;"  >const</span> Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; rhs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> lhs.m_x <span style="color:blue;"  >&gt;</span> rhs.m_x &amp;&amp; lhs.m_y <span style="color:blue;"  >&gt;</span> rhs.m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >friend</span> ostream&amp; <span style="color:blue;"  >operator</span>    <span style="color:blue;"  >&lt;&lt;</span> (ostream&amp; os, <span style="color:blue;"  >const</span> Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> os <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"("</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_x <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >", "</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_y  <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >")"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T, <span style="color:blue;"  >int</span> iSize = <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Stack {</span><br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;T m_pData[iSize];<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int</span> m_iTop;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack() : m_iTop(<span style="color:navy;"  >0</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Push(T p_iData) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_pData[m_iTop++] = p_iData;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Pop() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[--m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T Top() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pData[m_iTop];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack(<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; <span style="color:blue;"  >operator</span> = (<span style="color:blue;"  >const</span> Stack<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp;);<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Stack<span style="color:blue;"  >&lt;</span>Point<span style="color:blue;"  >&lt;int&gt;</span>    <span style="color:blue;"  >&gt;</span> st;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;st.Push(Point<span style="color:blue;"  >&lt;int&gt;</span>(<span style="color:navy;"  >5</span>, <span style="color:navy;"  >10</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;st.Push(Point<span style="color:blue;"  >&lt;int&gt;</span>(<span style="color:navy;"  >15</span>, <span style="color:navy;"  >20</span>));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> st.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> st.Pop() <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >(15, 20)<br>(5, 10)<br></span><span style="font-family:Verdana; font-size:10pt;"  >The most important part of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >Stack<span style="color:blue;"  >&lt;</span>Point<span style="color:blue;"  >&lt;int&gt;</span>    <span style="color:blue;"  >&gt;</span> st;<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here you have to pass the space between the two angle brackets, other wise compiler treat it &gt;&gt; (shift right operator) and generate error.<br>There is one more thing we can do with this program. We can pass the default type value of template parameter too. We can change <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T, <span style="color:blue;"  >int</span> iSize = <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span><br></span></span><span style="font-family:Verdana; font-size:10pt;"  >to <br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T = <span style="color:blue;"  >int</span>, <span style="color:blue;"  >int</span> iSize = <span style="color:navy;"  >10<span style="color:blue;"  >&gt;</span><br></span></span><span style="font-family:Verdana; font-size:10pt;"  >Now we don't have to pass the data type at the time of creating the object from Stack class. But you have to write the blank angle brackets at the time of creating the object to order the compiler to use default data type. You will create object something like this.<br></span><span style="font-family:Courier New; font-size:9pt;"  >Stack<span style="color:blue;"  >&lt;&gt;</span> st;<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >When you declare template class member function outside the class then you have to give the complete name of template class with its Template parameter.<br></span><span style="color:#ff9900;"  ><strong>Program 41<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Point {</span><br>private</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;T m_x, m_y;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Point(T p_x = <span style="color:navy;"  >0</span>, T p_y = <span style="color:navy;"  >0</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Setxy(T p_x, T p_y);<br>&nbsp;&nbsp;&nbsp;&nbsp;T getX() <span style="color:blue;"  >const</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;T getY() <span style="color:blue;"  >const</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >friend</span> ostream&amp; <span style="color:blue;"  >operator</span>    <span style="color:blue;"  >&lt;&lt;</span> (ostream&amp; os, <span style="color:blue;"  >const</span> Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>&amp; p) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> os <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"("</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_x <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >", "</span>    <span style="color:blue;"  >&lt;&lt;</span> p.m_y  <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >")"</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br>Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>::Point(T p_x, T p_y) : m_x(p_x), m_y(p_y) {<br>}<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >void</span> Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>::Setxy(T p_x, T p_y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;m_x = p_x;<br>&nbsp;&nbsp;&nbsp;&nbsp;m_y = p_y;<br>}<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br>T Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>::getX() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_x;<br>}<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br>T Point<span style="color:blue;"  >&lt;</span>T<span style="color:blue;"  >&gt;</span>::getY() <span style="color:blue;"  >const</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_y;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Point<span style="color:blue;"  >&lt;int&gt;</span> p;<br>&nbsp;&nbsp;&nbsp;&nbsp;p.Setxy(<span style="color:navy;"  >20</span>, <span style="color:navy;"  >30</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> p <span style="color:blue;"  >&lt;&lt;</span> endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >(20, 30)<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Lets change program 35 little bit and pass string value rather than int or float and see the result.<br></span><span style="color:#ff9900;"  ><strong>Program 42<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br></span>T Maximum(T a, T b)</span> {</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a <span style="color:blue;"  >&gt;</span> b ? a : b;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum(<span style="color:purple;"  >"Pakistan"</span>, <span style="color:purple;"  >"Karachi"</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >The output of this program is Karachi. Why? Because here char* is passed as a template parameter. Karachi is stored at higher memory location so the &gt; operator just compare the value of address rather then the string itself.<br>What should we do if we want the comparison on the basis of length of string not on the basis of their address?<br>The solution is to specialized the template on char* data type. Here is an example of template specialization.<br></span><span style="color:#ff9900;"  ><strong>Program 43<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br></span>T Maximum(T a, T b) {</span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> a <span style="color:blue;"  >&gt;</span> b ? a : b;<br>}<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;&gt;</span><br><span style="color:blue;"  >char</span>* Maximum(<span style="color:blue;"  >char</span>* a, <span style="color:blue;"  >char</span>* b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> strlen(a) <span style="color:blue;"  >&gt;</span> strlen(b) ? a : b;<br>}<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> Maximum(<span style="color:purple;"  >"Pakistan"</span>, <span style="color:purple;"  >"Karachi"</span>) <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >Classes can be specialized in the same way. <br>. <br></span><span style="color:#ff9900;"  ><strong>Program 44<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> TestClass {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> F(T pT) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"T version"</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >'\t'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> pT <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;&gt;</span><br><span style="color:blue;"  >class</span> TestClass<span style="color:blue;"  >&lt;int&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> F(<span style="color:blue;"  >int</span> pT) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"int version"</span>    <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >'\t'</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span> pT <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;TestClass<span style="color:blue;"  >&lt;char&gt;</span> obj1;<br>&nbsp;&nbsp;&nbsp;&nbsp;TestClass<span style="color:blue;"  >&lt;int&gt;</span> obj2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;obj1.F(<span style="color:purple;"  >'A'</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;obj2.F(<span style="color:navy;"  >10</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >T version&nbsp;&nbsp;&nbsp;&nbsp;A<br>int version&nbsp;&nbsp;&nbsp;&nbsp;10<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >ATL has several classes which have specialized version like this, such as CComQIPtr define in ATLBASE.H<br>Template can also be used in different design patter. E.g. Strategy design pattern can be implemented by using template.<br></span><span style="color:#ff9900;"  ><strong>Program 45<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Round1 {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Play() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Round1::Play"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Round2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Play() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Round2::Play"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Strategy {<br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;T objT;<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Play() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objT.Play();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Strategy<span style="color:blue;"  >&lt;</span>Round1<span style="color:blue;"  >&gt;</span> obj1;<br>&nbsp;&nbsp;&nbsp;&nbsp;Strategy<span style="color:blue;"  >&lt;</span>Round2<span style="color:blue;"  >&gt;</span> obj2;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;obj1.Play();<br>&nbsp;&nbsp;&nbsp;&nbsp;obj2.Play();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here Round1 and Round2 are classes of different round of a game and Strategy class decide what do to do depend on the template parameter pass to this class.<br>The output of the program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >Round1::Play<br>Round2::Play<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >ATL implement threading using Strategy design pattern.<br>Proxy design pattern can also be implemented using template. Smart pointer is an example of proxy design pattern. Here is an example of simplified version of smart pointer without using template.<br></span><span style="color:#ff9900;"  ><strong>Program 46<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Inner {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Inner::Fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Outer {<br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Inner* m_pInner;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Outer(Inner* p_pInner) : m_pInner(p_pInner) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Inner* <span style="color:blue;"  >operator</span> -<span style="color:blue;"  >&gt;</span> () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pInner;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Inner objInner;<br>&nbsp;&nbsp;&nbsp;&nbsp;Outer objOuter(&amp;objInner);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;objOuter-<span style="color:blue;"  >&gt;</span>Fun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >Inner::Fun()<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >For simplicity, we just overload the -&gt; operator, but in real smart pointer all the necessary operators such as =, ==, !, &amp;, * are overloaded. There is one big problem with this smart pointer; this can only contain pointer to Inner object. We can remove this restriction by making OuterClass template. Let's change program little bit.<br></span><span style="color:#ff9900;"  ><strong>Program 47<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Inner {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> Fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Inner::Fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Outer {<br><span style="color:blue;"  >private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;T* m_pInner;<br><br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Outer(T* p_pInner) : m_pInner(p_pInner) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;T* <span style="color:blue;"  >operator</span> -<span style="color:blue;"  >&gt;</span> () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span> m_pInner;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Inner objInner;<br>&nbsp;&nbsp;&nbsp;&nbsp;Outer<span style="color:blue;"  >&lt;</span>Inner<span style="color:blue;"  >&gt;</span> objOuter(&amp;objInner);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;objOuter-<span style="color:blue;"  >&gt;</span>Fun();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is same as previous one but now OuterClass can contain any class whose type is passed as a template parameter.<br>ATL has two smart pointer classes. </span><span style="color:#990000; font-family:Courier New;"  >CComPtr</span><span style="font-family:Verdana; font-size:10pt;"  > and </span><span style="color:#990000; font-family:Courier New;"  >CComQIPtr</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >.<br>You can do some interesting work with the help of template. E.g. your class can be child of different base class depend on different situation.<br></span><span style="color:#ff9900;"  ><strong>Program 48<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base1 {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;Base1() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base1::Base1"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Base2 {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Base2() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base2::Base2"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >template</span>    <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> T {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::Drive"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Drive<span style="color:blue;"  >&lt;</span>Base1<span style="color:blue;"  >&gt;</span> obj1;<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive<span style="color:blue;"  >&lt;</span>Base2<span style="color:blue;"  >&gt;</span> obj2;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this program is<br></span><span style="font-family:Courier New; font-size:9pt;"  >Base1::Base1<br>Drive::Drive<br>Base2::Base2<br>Drive::Drive<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here the Drive class is inherited from Base1 and Base2 depend on the parameter passed to the template at the time of creation of object.<br>ATL use this technique. When you make a COM component using ATL then </span><span style="color:#990000; font-family:Courier New;"  >CComObject</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > is inherit from your class. Here ATL take advantage of template, because ATL doesn't know in advance the name of the class which you create to make COM component. CComObject class is define in ATLCOM.h file<br>We can simulate virtual functions too with the help of template. Let's recall virtual function once again. Here is a simple program to recall the virtual function.<br></span><span style="color:#ff9900;"  ><strong>Program 49<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual</span>    <span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;obj.doSomething();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is <br></span><span style="font-family:Courier New; font-size:9pt;"  >Drive::fun<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >We can get the same behavior with the help of template.<br></span><span style="color:#ff9900;"  ><strong>Program 50<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pT-<span style="color:blue;"  >&gt;</span>fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Drive obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;obj.doSomething();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of the program is same as previous one. So we can simulate the behavior of virtual function with the help of template.<br>The interesting parts of this program are<br></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span> {<br></span><span style="font-family:Verdana; font-size:10pt;"  >This shows that we can pass the Drive class as a template parameter. The other interesting part of the program is the </span><span style="color:#990000; font-family:Courier New;"  >doSomething</span><span style="font-family:Verdana; font-size:10pt;"  > function of base class.<br></span><span style="font-family:Courier New; font-size:9pt;"  >T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>pT-<span style="color:blue;"  >&gt;</span>fun();<br></span><span style="font-family:Verdana; font-size:10pt;"  >Here the base class pointer is converted into drive class pointer, because drive class is passed as a template parameter of Base class. Then function is executed from that pointer, Now that pointer points to drive class object, so the drive class object is called.<br>But there is very good question, why should we do this? And there is very good answer of this question so save the extra byes of virtual pointer, virtual table and save the extra time to call virtual function. This is the main philosophy of ATL to make component as small as possible and as fast as possible.<br>Now there is one more question may arise in the mind. If due to this technique you can simulate virtual function with less memory and faster then original virtual function then why should we call virtual function? Shouldn't we replace all virtual function with this technique? The short answer of this question is no, we can not replace all virtual function with this technique. <br>There are some problems with this technique. First you can not further inherit any class from </span><span style="color:#990000; font-family:Courier New;"  >Drive</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > class. If you try to do so then that function will no more act as a virtual function. It doesn't happen in the case of virtual function; once you declare function virtual then it becomes virtual in all of drive class no matter how deep in inheritance chain. Let's take a look at a program what happen when we inherit one more class from Drive.<br></span><span style="color:#ff9900;"  ><strong>Program 51<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pT-<span style="color:blue;"  >&gt;</span>fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> MostDrive : <span style="color:blue;"  >public</span> Drive {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"MostDrive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;MostDrive obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;obj.doSomething();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >The output of this is program as same as previous one. In case of virtual function the output should be<br></span><span style="font-family:Courier New; font-size:9pt;"  >MostDrive::fun<br></span><span style="font-family:Verdana; font-size:10pt;"  >There is one more problem with this technique, when we want to take pointer of </span><span style="color:#990000; font-family:Courier New;"  >Base</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > class and want to store address of drive class.<br></span><span style="color:#ff9900;"  ><strong>Program 52<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pT-<span style="color:blue;"  >&gt;</span>fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Base* pBase = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase = <span style="color:blue;"  >new</span> Drive;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  >This program gives an error, because we couldn't pass the template parameter of the base class. Now change program little bit and pass the template parameter. <br></span><span style="color:#ff9900;"  ><strong>Program 53<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pT-<span style="color:blue;"  >&gt;</span>fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Base<span style="color:blue;"  >&lt;</span>Drive<span style="color:blue;"  >&gt;</span>* pBase = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase = <span style="color:blue;"  >new</span> Drive;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase-<span style="color:blue;"  >&gt;</span>doSomething();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >Now this program works fine and gives the same output as we expected i.e. <br></span><span style="font-family:Courier New; font-size:9pt;"  >Drive::fun<br></span><span style="font-family:Verdana; font-size:10pt;"  >But there is a problem when you inherit more then one class from </span><span style="color:#990000; font-family:Courier New;"  >Base</span><span style="font-family:Verdana;"  ><span style="font-size:10pt;"  > class. To better understand it, take a look at the following program.<br></span><span style="color:#ff9900;"  ><strong>Program 54<br></strong></span></span><span style="font-family:Courier New; font-size:9pt;"  ><span style="color:navy;"  >#include <span style="color:blue;"  >&lt;<span style="color:maroon;"  >iostream<span style="color:blue;"  >&gt;<span style="color:navy;"  ><br><span style="color:blue;"  >using</span>         <span style="color:blue;"  >namespace</span> std;</span><br></span><br><span style="color:blue;"  >template</span>       <span style="color:blue;"  >&lt;typename</span> T<span style="color:blue;"  >&gt;</span><br><span style="color:blue;"  >class</span> Base {</span><br>public</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Base::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T* pT = <span style="color:blue;"  >static_cast&lt;</span>T*<span style="color:blue;"  >&gt;</span>(<span style="color:blue;"  >this</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pT-<span style="color:blue;"  >&gt;</span>fun();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive1 : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive1<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive1::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >class</span> Drive2 : <span style="color:blue;"  >public</span> Base<span style="color:blue;"  >&lt;</span>Drive2<span style="color:blue;"  >&gt;</span> {<br><span style="color:blue;"  >public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void</span> fun() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout <span style="color:blue;"  >&lt;&lt;</span>    <span style="color:purple;"  >"Drive2::fun"</span>    <span style="color:blue;"  >&lt;&lt;</span> endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><span style="color:blue;"  >int</span> main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Base<span style="color:blue;"  >&lt;</span>Drive1<span style="color:blue;"  >&gt;</span>* pBase = NULL;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase = <span style="color:blue;"  >new</span> Drive1;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase-<span style="color:blue;"  >&gt;</span>doSomething();<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >delete</span> pBase;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;pBase = <span style="color:blue;"  >new</span> Drive2;<br>&nbsp;&nbsp;&nbsp;&nbsp;pBase-<span style="color:blue;"  >&gt;</span>doSomething();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return</span>    <span style="color:navy;"  >0</span>;<br>}<br></span><span style="font-family:Verdana; font-size:10pt;"  >This program gives error at <br></span><span style="font-family:Courier New; font-size:9pt;"  >pBase = <span style="color:blue;"  >new</span> Drive2;<br></span><span style="font-family:Verdana; font-size:10pt;"  >Because </span><span style="color:#990000; font-family:Courier New;"  >pBase</span><span style="font-family:Verdana; font-size:10pt;"  > is a pointer to </span><span style="color:#990000;"  ><span style="font-family:Courier New;"  >Base<span style="color:blue;"  >&lt;<span style="color:#990000;"  >Drive1<span style="color:blue;"  >&gt;<span style="color:#990000;"  >        </span></span></span></span></span><span style="font-family:Verdana; font-size:10pt;"  >not </span><span style="font-family:Courier New;"  >Base<span style="color:blue;"  >&lt;<span style="color:#990000;"  >Drive2<span style="color:blue;"  >&gt;</span></span></span></span><span style="font-family:Verdana; font-size:10pt;"  >. In short you can't make pointer of </span><span style="font-family:Courier New;"  >Base</span></span><span style="font-family:Verdana; font-size:10pt;"  > class and store address of different Drive class in it. In other words you cant make an array of Base pointer and store address of different drive class in it, which you can do in case of virtual function.<br>Hope to explore some other mysterious of ATL in next article.<br></span><span style="font-family:宋体; font-size:8pt;"  ></span></p>
</body></html>