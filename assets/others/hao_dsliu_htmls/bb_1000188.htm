<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：【转】Visual C++ 8.0对象布局的奥秘：虚函数、多继承、虚拟继承</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>【转】Visual C++ 8.0对象布局的奥秘：虚函数、多继承、虚拟继承</h2>
<p align="right">发布时间：2011-11-23 15:22
<br>分类名称：C++</p><br>
<p><span style="font-family:宋体; font-size:12pt;"  >出自：http://www.cnblogs.com/neoragex2002/archive/2007/11/01/vc8_object_layout_secret.html </span></p><p><span style="font-family:宋体; font-size:12pt;"  >从M$ Visual C++ Team的<a rel="nofollow" href="http://blogs.msdn.com/vcblog/archive/2007/05/17/diagnosing-hidden-odr-violations-in-visual-c-and-fixing-lnk2022.aspx"  ><span style="color:blue; text-decoration:underline;"  >Andy Rich</span></a>那里又偷学到一招：VC8的隐含编译项<strong>/d1reportSingleClassLayout</strong>和<strong>/d1reportAllClassLayout </strong>。看个复杂的例子吧(如下)，现在假设我们想知道Derived类的对象布局，怎么办? 在Project Properties-&gt;C++-&gt;Command Line-&gt;Additional Options里面加上<strong>/d1reportSingleClassLayoutDerived</strong>吧！ </span></p><p><span style="color:blue; font-family:宋体; font-size:12pt;"  >class<span style="color:black;"  >&nbsp;CommonBase<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int<span style="color:black;"  >&nbsp;co;<br>};<br><br><span style="color:blue;"  >class<span style="color:black;"  >&nbsp;Base1:&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >public<span style="color:black;"  >&nbsp;CommonBase<br>{<br><span style="color:blue;"  >public<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;print1()&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;print2()&nbsp;{}<br><span style="color:blue;"  >private<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int<span style="color:black;"  >&nbsp;b1;<br>};<br><br><span style="color:blue;"  >class<span style="color:black;"  >&nbsp;Base2:&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >public<span style="color:black;"  >&nbsp;CommonBase<br>{<br><span style="color:blue;"  >public<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;dump1()&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >virtual<span style="color:black;"  >&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;dump2()&nbsp;{}<br><span style="color:blue;"  >private<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int<span style="color:black;"  >&nbsp;b2;<br>};<br><br><span style="color:blue;"  >class<span style="color:black;"  >&nbsp;Derived:&nbsp;<span style="color:blue;"  >public<span style="color:black;"  >&nbsp;Base1,&nbsp;<span style="color:blue;"  >public<span style="color:black;"  >&nbsp;Base2<br>{<br><span style="color:blue;"  >public<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;print2()&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >void<span style="color:black;"  >&nbsp;dump2()&nbsp;{}<br><span style="color:blue;"  >private<span style="color:black;"  >:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >int<span style="color:black;"  >&nbsp;d;<br>};<br><br><span style="color:blue;"  >int<span style="color:black;"  >&nbsp;_tmain(<span style="color:blue;"  >int<span style="color:black;"  >&nbsp;argc,&nbsp;_TCHAR*&nbsp;argv[])<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;"  >return<span style="color:black;"  >&nbsp;0;<br>}</span>                                                                   </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family:宋体; font-size:12pt;"  ><br>F5编译之，你会惊奇地发现，Output里面有如下字样： </span></p><p><font size="2"  face="宋体"  ><span style="font-family: 宋体; font-size: 12pt;"  >class Derived size(32):<br>+---<br>| +--- (base class Base1)<br>0 | | {vfptr}<br>4 | | {vbptr}<br>8 | | b1<br>| +---<br>| +--- (base class Base2)<br>12 | | {vfptr}<br>16 | | {vbptr}<br>20 | | b2<br>| +---<br>24 | d<br>+---<br>+--- (virtual base CommonBase)<br>28 | co<br>+---</span></font></p><p><font size="2"  face="宋体"  ><span style="font-family: 宋体; font-size: 12pt;"  ><br></span></font></p><p><font size="2"  face="宋体"  ><span style="font-family:宋体; font-size:12pt;"  >Derived::$vftable@Base1@:<br>| &amp;Derived_meta<br>|  0<br>0 | &amp;Base1::print1<br>1 | &amp;Derived::print2<br>Derived::$vftable@Base2@:<br>| -12<br>0 | &amp;Base2::dump1<br>1 | &amp;Derived::dump2<br>Derived::$vbtable@Base1@:<br>0 | -4<br>1 | 24 (Derivedd(Base1+4)CommonBase)<br>Derived::$vbtable@Base2@:<br>0 | -4<br>1 | 12 (Derivedd(Base2+4)CommonBase)<br>Derived::print2 this adjustor: 0<br>Derived::dump2 this adjustor: 12<br>vbi:    class  offset o.vbptr  o.vbte fVtorDisp</span></font><span style="font-family: 宋体; font-size: 12pt;"  ><font size="2"  face="宋体"  ><br>CommonBase      28       4       4 0 </font><br></span></p><p><span style="font-family:宋体; font-size:12pt;"  ><br>看到了吗? VC8居然输出了Derived对象的完整布局! 我们终于可以不必两眼一抹黑般的去peek/poke了....第1行表明，Derived对象总占用了32字节；其由三部分组成，分别是行3-行7、行 8-行12、行13、行28；其中前二者分别是基类Base1、Base2的布局，最后的行28为虚拟基类Common的布局。<br><br>以基类Base1部分为例，可发现其由一个虚函数表指针vftable和虚基表指针vbtable构成，先看Base1部分的vftable所指向的虚 表$vftable@Base1(行19)，不难发现，其中的表项2已经被Derived::print2给override了；再来看Base2部分的 vftable所指向的虚表$vftable@Base2(行23)，可发现，同样的，Base2::dump2被Derived::dump2给 override了。这不明摆着就是虚函数机制嘛，heh~<br><br>值得注意的是，这个例子同时说明，多继承场合下，其实在单一对象中是存在多个this指针的....行35-36给出了如何将Derived的this指 针校正为其基类子对象this指针的偏移量，也就是说，根据行36，假设有个Derived d，那么d.dump1()实际上应该理解成通过虚表$vftable@Base2对((Base2*) (((char*)&amp;d)+12))-&gt;dump1()的调用....即传递给所有Base2成员函数的this指针应该是 (Base2*)((char*)(&amp;d)+12)，这里可能我写得恐怖了点，意思到了就成....这不，普通继承、多继承、对象Slicing 的语义都在这个布局里面了，看仔细了哈~<br><br>OK，多继承看完了，继续看虚拟基类是如何布局的。虚基Common在Derived的布局中，位于Derived本身数据成员之后的位置。Base1、 Base2中均保存了一个vbtable指针，其分别指向各自所使用的虚基表$vbtable@Base1和$vbtable@Base2，为什么要指向 一个虚基表? 很简单，因为Base1、Base2有可能会同时继承多个不同的虚拟基类.....这充分体现了C++对象布局的复杂性....在每个虚基表中，保存了所 继承的虚拟基类部分相对于子类部分vbtable指针的偏移值，以Base2为例，我们知道Base2的vbtable在Derived中的偏移值为 16(行10)，则根据$vbtable@Base2，虚基Common部分距离Base2 vbtable指针的偏移值为12,则有虚基Common在Derived中的总偏移值为16+12。与普通多继承同理，我们在调用非虚拟的虚基成员函数 时，必须将Derived的this指针调整为指向虚基部分的this指针，只有这样才能成功地访问虚基自身的数据成员和虚基的虚拟函数(通过虚基自己的 vftable，为简单起见，上例中我就没弄那么复杂了，大家可以自己玩玩，明白如何举一反三即可)</span></p>
</body></html>