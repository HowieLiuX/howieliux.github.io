<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转] C++ 异常处理 和 win32 异常处理（SEH）区别及其使用问答</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转] C++ 异常处理 和 win32 异常处理（SEH）区别及其使用问答</h2>
<p align="right">发布时间：2010-12-18 18:13
<br>分类名称：SEH</p><br>
<p>最近在看SEH的原理，就顺便对比一下C++ exception handing 和 SEH的区别，以及编译器的不同实现。</p><p></p><h1>A Visual C++ Exception FAQ</h1>  <h3>Copyright ? 2001-2007 Doug Harrison</h3>  <p>This document answers some common questions concerning <b>catch(...)</b> and   exceptions in general as implemented by Visual C++. It's structured mainly as a   conversation, in which one question and answer leads to the next, so you'll get   the most out of it if you read it as a whole. To give you a quick idea of what   I'm going to talk about, the questions are:</p>  <table id="table1"  border="0"  width="100%"  >  <tbody>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q1"  >Q1</a>&nbsp;&nbsp; </td>  <td align="left"  valign="top"  >I wrote the following, and I don't understand why   <b>catch(...)</b> doesn't catch the Win32 structured exception in a release   build, or in general, when compiling with optimizations (e.g. /O1 or   /O2).</td></tr>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q2"  >Q2</a></td>  <td align="left"  valign="top"  >I also wrote the code above, and I don't understand   why the Win32 structured exception (SE) is caught in a debug build or when I   compile with /EHa. Also, I sometimes find that <b>catch(...)</b> catches SEs   even in release builds when I use /GX. Isn't <b>catch(...)</b> supposed to catch   only C++ exceptions?</td></tr>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q3"  >Q3</a> </td>  <td align="left"  valign="top"  >So what are the consequences of catching Win32   Structured Exceptions (SEs) in <b>catch(...)</b> ?</td></tr>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q4"  >Q4</a></td>  <td align="left"  valign="top"  >What about <b>_set_se_translator</b>?</td></tr>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q5"  >Q5</a></td>  <td align="left"  valign="top"  >How do I deal with all this?</td></tr>  <tr>  <td align="left"  valign="top"  ><a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q6"  >Q6</a></td>  <td align="left"  valign="top"  >How do I safely use <b>_com_error</b>,   <b>std::exception</b>, and other non-MFC exception classes in MFC   programs?</td></tr></table>  <p>This document applies to Visual C++ 5 through Visual C++ .NET 2003 and   beyond. The upcoming Visual C++ 2005 release, known also as "Whidbey", corrects   one of the problems discussed below, and this partly affects questions <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q1"  >Q1</a>, <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q2"  >Q2</a>, and <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q5"  >Q5</a>, which are updated   accordingly. The remaining questions and answers apply in full to Visual C++ 5   and later.</p>  <p><b><a name="Q1" rel="nofollow"  >Q1</a>.</b> I wrote the following, and I don't understand why   <b>catch(...)</b> doesn't catch the Win32 structured exception in a release   build, or in general, when compiling with optimizations (e.g. /O1 or /O2).<span style="font-family: monospace;"  ><br></span></p><p><span style="font-family: monospace;"  ></span>#include &lt;stdio.h&gt;</p><p>int main() <br>{ <br>&nbsp;&nbsp;&nbsp; try <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int* p = 0; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *p = 0; // Cause access violation <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; catch (...) <br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; puts("Caught access violation"); <br>&nbsp;&nbsp;&nbsp; } <br>&nbsp;&nbsp;&nbsp; return 0; <br>} <br></p>    <p><b>A.</b> In Visual C++5 through Visual C++ .NET 2003, you're compiling with   /GX or /EHs, which enables the compiler's <i>synchronous</i> exception model.   This model is defined to catch only exceptions resulting from a C++ <b>throw</b>   statement, and there is no such statement in the above. If you were to examine   the assembly language emitted for this program, you would find the compiler has   optimized all the exception handling machinery out of the function, because the   optimizer can determine the tried code cannot throw a C++ exception. This is a   great optimization! It's especially appreciated when writing template code.   Unfortunately, there is a bug that causes <b>catch(...) </b>to catch Win32   structured exceptions in some scenarios, which leads to the next question.</p>  <p><b><a name="Q2" rel="nofollow"  >Q2</a>.</b> I also wrote the code above, and I don't understand   why the Win32 structured exception (SE) is caught in a debug build or when I   compile with /EHa. Also, I sometimes find that <b>catch(...)</b> catches SEs   even in release builds when I use /GX. Isn't <b>catch(...)</b> supposed to catch   only C++ exceptions? </p>  <p><b>A. </b>According to Stroustrup, C++ exception handling (EH) is not   intended to handle signals or other low-level, OS-specific events such as   arithmetic exceptions. Win32 Structured Exceptions (SEs) clearly fall into this   category, and it should not be possible to catch SEs in <b>catch(...)</b>.   However, the C++ Standard doesn't specifically forbid this, and because anytime   you raise an SE you invoke undefined behavior, it's "legal" for   <b>catch(...)</b> to catch SEs, in a<i> very </i>technical sense, because the   C++ Standard imposes no requirements on the behavior of a program that does   something undefined, such as dereferencing a NULL pointer. That said, while it   may <i>seem</i> convenient to catch truly <i>everything</i> in   <b>catch(...)</b>, catching SEs there is the source of numerous problems. Before   discussing why I say that, let's consider how Visual C++ is documented to   behave.</p>  <p>Visual C++ 5 and later define two EH models, called <i>synchronous</i> and   <i>asynchronous</i>. The model chosen is determined by the /EH command line   option. /EHs specifies the synchronous model, while /EHa specifies the   asynchronous model. There is also /GX, which is defined by default for MFC and   other AppWizard applications. /GX is equivalent to /EHsc, so it selects the   synchronous model. (The <i>c</i> indicates that <b><code>extern "C"</code></b>   functions do not throw exceptions.) The VC++ documentation defines the   asynchronous model as follows:</p>  <blockquote>  <p><i>In previous versions of Visual C++, the C++ exception handling mechanism   supported asynchronous (hardware) exceptions by default. Under the asynchronous   model, the compiler assumes any instruction may generate an   exception.</i></p></blockquote>  <p>Under the asynchronous model, <b>catch(...)</b> catches SEs, and you must use   /EHa if this is what you really want. You must also use /EHa if you're expecting   to catch SEs that have been translated into C++ exceptions with the help of   <b>_set_se_translator()</b>. (See <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q4"  >Q4</a>.)</p>  <p>The synchronous model is described as follows:</p>  <blockquote>  <p><i>With the new synchronous exception model, now the default, exceptions can   be thrown only with a <b>throw</b> statement. Therefore, the compiler can assume   that exceptions happen only at a <b>throw</b> statement or at a function call.   This model allows the compiler to eliminate the mechanics of tracking the   lifetime of certain unwindable objects, and to significantly reduce the code   size, if the objects’ lifetimes do not overlap a function call or a <b>throw</b>   statement.</i></p></blockquote>  <p>The synchronous model is intended to provide C++ EH as Stroustrup intended,   but unfortunately, in Visual C++ 5 through Visual C++ .NET 2003,&nbsp; it doesn't   behave exactly as documented, and it's still possible to catch SEs in   <b>catch(...)</b> if you compile without optimizations, or you compile with   optimizations, and the optimizer is unable to determine the tried code cannot   throw a C++ exception. For example, in VC5, if the tried code calls a function,   the optimizer assumes it can throw, while in VC6, the function may need to live   in another translation unit (source file) to cause the optimizer to be   pessimistic.&nbsp;Visual C++ .NET 2005 at last corrects this problem for the   synchronous model.</p>  <p><b><a name="Q3" rel="nofollow"  >Q3</a>.</b> So what are the consequences of catching Win32   Structured Exceptions (SEs) in <b>catch(...)</b> ?</p>  <p><b>A. </b>In order to answer this question, we first need to discuss what C++   exceptions and SEs represent. According to Stroustrup, <i>C++ exception handling   is error handling</i>. For example, failure to acquire a resource such as memory   or running out of disk space while writing to a file is an error that is often   best reported by throwing an exception, especially when the resource is normally   expected to be available. This greatly simplifies code by eliminating the need   to check function return codes, and it helps you centralize error handling. This   sort of error can occur in a <i>correctly</i> written program, and <i>that</i>   is what C++ EH is intended to address.</p>  <p>On the other hand, SEs typically represent program bugs. Everyone is familiar   with access violations resulting from dereferencing NULL pointers. The hardware   detects this and traps, and Windows&nbsp; turns the hardware event into an SE. In   general, SEs represent programmer errors, and correctly written programs have no   such errors. SEs are also used in the normal operation of the system. For   example, it's possible to use <b>VirtualAlloc()</b> to <i>reserve</i> a region   of your address space and dynamically <i>commit</i> pages as a program accesses   uncommitted memory and causes page faults. The program catches the SE in an   <b>__except</b> clause, commits the memory, and resumes execution with the   instruction that caused the fault. This should be invisible to C++ EH, which   should not be able to interfere with it.</p>  <p>C++ exceptions and Win32 structured exceptions represent very different   things. Problems caused by homogenizing them in <b>catch(...)</b> include the   following.</p>  <ol>  <li>If <b>catch(...)</b> is able to catch SEs, it's impossible to write the   following with any confidence:<br><br><code>&nbsp;&nbsp; // Begin exception-free   code<br>&nbsp;&nbsp; ... Update critical data structure<br>&nbsp;&nbsp; // End exception-free   code<br></code><br>If the critical code has a bug that results in an SE, an   outer <b>catch(...)</b> block may catch the SE, creating a completely   unanticipated program state. The program may hobble along, further corrupting   its state. If you're lucky, a subsequent uncaught SE will bring the program down   before it does any serious damage, but debugging the problem may be much more   difficult than if <b>catch(...)</b> hadn't swallowed the initial SE, because the   secondary SE may occur in code far removed from the source of the actual bug.   The OS will report the uncaught secondary SE and give you the opportunity to   debug it, but it will lead you to the source of this SE, <i>not</i> the source   of the actual problem.   </li><li>Code such as the following becomes suspect:<br><br><code>&nbsp;&nbsp; try<br>&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TheFastButResourceHungryWay();<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; catch (...)<br>&nbsp;&nbsp;   {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TheSlowButSureWay();<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;<br></code>If a program bug or   compiler code generation bug causes an access violation in the tried function,   your discovery of the bug is hindered by <b>catch(...)</b> swallowing the SE.   The only manifestation of the bug may be an inexplicable slowness, which may not   be apparent in your testing, while if <b>catch(...)</b> hadn't caught the SE,   you certainly would have discovered the bug while testing. (OS error boxes are   pretty hard to miss!)   </li><li>The normal operation of the system is impaired. For example, the MFC   CPropertySheet::DoModal() documentation describes a scenario in which you should   not use <b>catch(...)</b>. The exception raised by the <b>DebugBreak</b> API can   be caught by <b>catch</b>(...), rendering <b>DebugBreak</b> useless.<b>   </b>Also, if you're using <b>__try/__except</b> to handle SEs <i>properly</i>,   you may have trouble if an interior <b>catch(...)</b> is present, even if it   rethrows. You almost certainly <i>will</i> have trouble if your SE handler   resumes execution with the faulting instruction. You may find the   <b>catch(...)</b> block was entered and local variables destroyed, which is   <i>very </i>bad if execution is resumed in its complementary <b>try</b> block.   And if that <b>try</b> block subsequently throws a C++ exception, you may find   yourself in an infinite loop with your SE filter function.   </li><li>Application frameworks are taking a chance if they guard your code with   <b>catch(...)</b>, which they normally should do. For example, MFC does   <i>not</i> use <b>catch(...)</b>, and as a result, an uncaught C++ exception   terminates an MFC application. </li></ol>  <p><b><a name="Q4" rel="nofollow"  >Q4</a>.</b> What about <b>_set_se_translator</b>?</p>  <p><b>A. _set_se_translator</b> is a function used to register another function   which translates Win32 structured exceptions&nbsp; into true C++ exceptions. It   allows you to partially avoid the <b>catch(...)</b> problems described in <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q3"  >Q3</a> by writing the   following, where <b>se_t</b> is the type of object thrown by the translator   function:</p>  <blockquote><pre>catch (se_t) { throw; }  catch (...) { ... }</pre></blockquote>  <p>This is not a great workaround, because it's easy to forget to augment   <i>every</i> <b>catch(...)</b> as shown above, and you would have to establish a   translator in <i>every</i> thread you create that runs code which uses this   method, because SE handlers are attributes of a thread, and calling   <b>_set_se_translator</b> in one thread has no effect on other threads. Also,   the translator function isn't inherited by new threads; thus,   <b>_set_se_translator</b> has no effect on threads created after it's called.   Besides being difficult and error-prone to implement, this workaround can't   account for code you didn't write and can't modify, and this can be an issue for   library users.</p>  <p>Finally, the documentation does not make it clear that to use   <b>_set_se_translator</b> reliably, you <i>must</i> select the asynchronous EH   model discussed in <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q2"  >Q2</a>,   and that tends to bloat your object code. If you don't do this, your code is   subject to the optimization discussed in <a rel="nofollow" href="http://members.cox.net/doug_web/eh.htm#Q1"  >Q1</a>.</p>  <p><b><a name="Q5" rel="nofollow"  >Q5</a>.</b> How do I deal with all this?</p>  <p><b>A. </b>When using Visual C++ 5 through Visual C++ .NET 2003, the best   course is to avoid <b>catch(...)</b> whenever possible. If you must use   <b>catch(...)</b>, be aware of all the issues described in the preceding   questions. If you're using Visual C++ .NET 2005, the /EHs option behaves as   documented, the synchronous model works correctly, and you don't have to worry   about <b>catch(...)</b> catching SEs.</p>  <p><b><a name="Q6" rel="nofollow"  >Q6</a>.</b> How do I safely use <b>_com_error</b>,   <b>std::exception</b>, and other non-MFC exception classes in MFC programs?</p>  <p><b>A. </b>MFC was designed before Visual C++ supported C++ exception   handling. The original MFC implementation was based on macros such as <b>TRY</b>   and <b>CATCH</b> and used <b>setjmp</b> and <b>longjmp</b> to simulate C++   exception handling. To simplify this initial implementation, MFC threw pointers   to <b>CException</b> objects and pointers to objects of classes derived from   <b>CException</b>, and <b>CException*</b> was the <i>only</i> exception type   supported by early versions of MFC. Though MFC was updated to use C++ exceptions   in Visual C++ 2.0, it was never made aware of other exception types, and the MFC   source code continues to use the macros, which are now defined in terms of C++   EH. For example, MFC defines <b>CATCH_ALL </b>in terms of:&nbsp;</p>  <blockquote><pre>catch (CException* e)</pre></blockquote>  <p>Clearly, this doesn't catch <i>all</i> exceptions if the tried code uses the   C++ Standard Library, compiler COM support, or other libraries that define their   own exception types. MFC does not itself use any exception type other than   <b>CException*</b>, but in many places, it wraps your code as follows:</p><p>TRY<br>{<br>&nbsp;&nbsp; // Call your code<br>}<br>CATCH_ALL(e)<br>{<br>&nbsp;&nbsp; // Clean up and perhaps report the error to the user<br>}<br>END_CATCH_ALL</p><p><br></p><p>For example, an MFC WindowProc is guarded this way, because exceptions aren't   allowed to cross Windows message boundaries. However, <b>CATCH_ALL</b> catches   <i>only</i> MFC exceptions, and if you fail to catch a non-MFC exception   yourself, your program will be terminated due to an uncaught exception. Even if   you do catch the exception yourself, <i>where</i> you catch it is still very   important, because there are a number of functions within MFC that expect to   catch all exceptions so they can clean up or return an error code to the caller   through a normal function return statement. Now, if the <b>try</b> blocks within   these functions call into your code, and you don't translate non-MFC exceptions   into MFC exceptions right then and there, you allow non-MFC exceptions to   propagate through MFC code that expects to catch <i>everything</i>, and as just   described, it can't, and it doesn't. You may end up skipping some important   clean-up code, and even though you catch your non-MFC exception at some outer   level, it may be too late. This suggests the following rule of thumb:</p>  <blockquote>  <p><i>Never allow a non-MFC exception to pass through MFC   code</i></p></blockquote>  <p>At a minimum, this means protecting every message handler that could exit via   a non-MFC exception with <b>try/catch</b>. Now, if a message handler can't do   anything about an exception, and you want it to be reported to the user, it's   often appropriate for the handler to exit via an exception, because MFC will   present the user with a nice message box describing the error, provided it can   catch it. To achieve this result, you need to translate non-MFC exceptions into   MFC exceptions. Macros can help here. For example, consider the code sketched   below:</p>  <blockquote><p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >class MfcGenericException : public CException</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >public:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// CException overrides</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>BOOL GetErrorMessage(</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LPTSTR lpszError,</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>UINT nMaxError,</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PUINT pnHelpContext = 0)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSERT(lpszError != 0);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSERT(nMaxError != 0);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pnHelpContext != 0)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>*pnHelpContext = 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>_tcsncpy(lpszError, m_msg, nMaxError-1);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lpszError[nMaxError-1] = 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return *lpszError != 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >protected:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>explicit MfcGenericException(const CString&amp; msg)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>:<span style="mso-spacerun: yes;"  >&nbsp; </span>m_msg(msg)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >private:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>CString m_msg;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >};</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >class MfcStdException : public MfcGenericException</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >public:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>static MfcStdException* Create(const std::exception&amp; ex)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return new MfcStdException(ex);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >private:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>explicit MfcStdException(const std::exception&amp; ex)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>: MfcGenericException(ex.what())</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >};</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >#define MFC_STD_EH_PROLOGUE <span style="mso-spacerun: yes;"  >&nbsp;</span>try {</span></span></span></p>  <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: rgb(192, 0, 0);"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >#define MFC_STD_EH_EPILOGUE /<span style="mso-spacerun: yes;"  ></span><br></span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >} catch (std::exception&amp; ex) { throw MfcStdException::Create(ex); }</span></span></span></p></blockquote>  <p>The code above defines a class, <b>MfcGenericException</b>, which is derived   from MFC's <b>CException</b>, and which serves as the base class for   <b>MfcStdException</b> and other non-MFC exception types. (We need this base   class because MFC does not provide a generic exception type that encapsulates a   message string.) The macros at the bottom are intended to surround your message   handlers and other code called from MFC that can throw non-MFC exceptions. You   use it like this:</p>  <blockquote><pre>void MyWnd::OnMyCommand()  {  MFC_STD_EH_PROLOGUE</pre><pre>   ... your code which can throw std::exception</pre><pre>MFC_STD_EH_EPILOGUE  }</pre></blockquote>  <p>Together, the macros guard your code in a try block, and the   <b>MFC_STD_EH_EPILOGUE</b> macro translates <b>std::exception</b> into something   MFC can catch, in this case, <b>MfcStdException</b>. Note that   <b>MfcStdException</b> has a private constructor and defines a static   <b>Create</b> function, and the latter provides the only way to create an   <b>MfcStdException</b>. It ensures the exception object is created on the heap,   which we <i>must</i> do, because each object maintains state information in the   form of its error message. We can't simply throw a pointer to a static instance,   as <b>AfxThrowMemoryException</b> does, because that wouldn't be thread-safe due   to our state information, and it's also possible to throw and catch an exception   while handling another, which is ultimately rethrown, and that would tend to   overwrite the first message. We can't take any shortcuts here! Whoever catches   our exception is responsible for calling its <b>Delete</b> member function,   inherited from <b>CException</b>. This function will <b>delete</b> the   <b>MfcStdException</b> object, and it's good to disallow mistakes such as   throwing a pointer to a local object by preventing the creation of local objects   altogether. </p>  <p>Using a technique such as the above is essential to creating MFC programs   which are robust in the presence of heterogeneous exception types. It's much   easier than writing explicit <b>try/catch</b> blocks, and it allows exceptions   to propagate to whoever can best handle them. In fact, explicit <b>try/catch</b>   blocks are relatively rare in well-designed programs, because the code is   written in such a way that the automatic stack unwinding and local variable   destruction does the right thing. Consequently, the final step of handling an   exception often amounts to simply letting the user know something went wrong,   and by translating your non-MFC exceptions into MFC exceptions, MFC can handle   that just fine.</p>  <h1>Comments</h1>  <p>To comment on this page, please send email to <a rel="nofollow" href="mailto:dsh@mvps.org?subject=EH"  >dsh@mvps.org</a>.</p>
</body></html>