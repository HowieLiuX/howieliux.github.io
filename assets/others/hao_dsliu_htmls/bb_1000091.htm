<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：Type Casting</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>Type Casting</h2>
<p align="right">发布时间：2012-12-25 10:29
<br>分类名称：C++</p><br>
<p><strong>From: <a rel="nofollow" href="http://www.cplusplus.com/doc/tutorial/typecasting/"  >http://www.cplusplus.com/doc/tutorial/typecasting/</a>   </strong></p><p><strong><br></strong>Converting an expression of a given type into another type is known as <em>type-casting</em>. We have already seen some ways to type cast:<br><strong>   </strong></p><p><strong>Implicit conversion<br></strong>Implicit conversions do not require any operator. They are automatically performed when a value is copied to a compatible type. For example: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:97px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>short a=2000;<br>int b;<br>b=a;</p></td></tr></table></div><p><br>Here, the value of a has been promoted from short to int and we have not had to specify any type-casting operator. This is known as a standard conversion. Standard conversions affect fundamental data types, and allow conversions such as the conversions between numerical types (short to int, int to float, double to int...), to or from bool, and some pointer conversions. Some of these conversions may imply a loss of precision, which the compiler can signal with a warning. This can be avoided with an explicit conversion.<br>Implicit conversions also include constructor or operator conversions, which affect classes that include specific constructors or operator functions to perform conversions. For example: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:179px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>class A {};<br>class B { public: B (A a) {} };<br><br>A a;<br>B b=a;</p></td></tr></table></div><p><br>Here, an implicit conversion happened between objects of class A and class B, because B has a constructor that takes an object of class A as parameter. Therefore implicit conversions from A to B are allowed.<br><strong>   </strong></p><p><strong>Explicit conversion<br></strong>C++ is a strong-typed language. Many conversions, specially those that imply a different interpretation of the value, require an explicit conversion. We have already seen two notations for explicit type conversion: functional and c-like casting: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:246px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>short a=2000;<br>int b;<br>b = (int) a;    // c-like cast notation<br>b = int (a);    // functional notation </p></td></tr></table></div><p><br>The functionality of these explicit conversion operators is enough for most needs with fundamental data types. However, these operators can be applied indiscriminately on classes and pointers to classes, which can lead to code that while being syntactically correct can cause runtime errors. For example, the following code is syntactically correct:  </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:20px;"  /><col style="width:755px;"  /><col style="width:376px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>// class type-casting<br>#include &lt;iostream&gt;<br>using namespace std;<br><br>class CDummy {<br>    float i,j;<br>};<br><br>class CAddition {<br>&nbsp;&nbsp;&nbsp;&nbsp;int x,y;<br>  public:<br>&nbsp;&nbsp;&nbsp;&nbsp;CAddition (int a, int b) { x=a; y=b; }<br>&nbsp;&nbsp;&nbsp;&nbsp;int result() { return x+y;}<br>};<br><br>int main () {<br>  CDummy d;<br>  CAddition * padd;<br>  padd = (CAddition*) &amp;d;<br>  cout &lt;&lt; padd-&gt;result();<br>  return 0;<br>}</p></td><td style="background: #e7e7e7; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid silver 0.75pt; border-left:  none; border-bottom:  solid silver 0.75pt; border-right:  solid silver 0.75pt;"  ><p> &nbsp;</p></td></tr></table></div><p><br>The program declares a pointer to CAddition, but then it assigns to it a reference to an object of another incompatible type using explicit type-casting: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:9px;"  /><col style="width:164px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>&nbsp;&nbsp;</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>padd = (CAddition*) &amp;d;</p></td></tr></table></div><p><br>Traditional explicit type-casting allows to convert any pointer into any other pointer type, independently of the types they point to. The subsequent call to member result will produce either a run-time error or a unexpected result.<br>In order to control these types of conversions between classes, we have four specific casting operators: dynamic_cast, reinterpret_cast, static_cast and const_cast. Their format is to follow the new type enclosed between angle-brackets (&lt;&gt;) and immediately after, the expression to be converted between parentheses.<br>dynamic_cast &lt;new_type&gt; (expression)<br>reinterpret_cast &lt;new_type&gt; (expression)<br>static_cast &lt;new_type&gt; (expression)<br>const_cast &lt;new_type&gt; (expression)<br>The traditional type-casting equivalents to these expressions would be:<br>(new_type) expression<br>new_type (expression)<br>but each one with its own special characteristics:<br><strong>   </strong></p><p><strong>dynamic_cast</strong><br>dynamic_cast can be used only with pointers and references to objects. Its purpose is to ensure that the result of the type conversion is a valid complete object of the requested class.<br>Therefore, dynamic_cast is always successful when we cast a class to one of its base classes: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:428px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>class CBase { };<br>class CDerived: public CBase { };<br><br>CBase b; CBase* pb;<br>CDerived d; CDerived* pd;<br><br>pb = dynamic_cast&lt;CBase*&gt;(&amp;d);     // ok: derived-to-base<br>pd = dynamic_cast&lt;CDerived*&gt;(&amp;b);  // wrong: base-to-derived </p></td></tr></table></div><p><br>The second conversion in this piece of code would produce a compilation error since base-to-derived conversions are not allowed with dynamic_cast unless the base class is polymorphic.<br>When a class is polymorphic, dynamic_cast performs a special checking during runtime to ensure that the expression yields a valid complete object of the requested class: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:27px;"  /><col style="width:429px;"  /><col style="width:241px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>// dynamic_cast<br>#include &lt;iostream&gt;<br>#include &lt;exception&gt;<br>using namespace std;<br><br>class CBase { virtual void dummy() {} };<br>class CDerived: public CBase { int a; };<br><br>int main () {<br>  try {<br>    CBase * pba = new CDerived;<br>    CBase * pbb = new CBase;<br>    CDerived * pd;<br><br>    pd = dynamic_cast&lt;CDerived*&gt;(pba);<br>    if (pd==0) cout &lt;&lt; "Null pointer on first type-cast" &lt;&lt; endl;<br><br>    pd = dynamic_cast&lt;CDerived*&gt;(pbb);<br>    if (pd==0) cout &lt;&lt; "Null pointer on second type-cast" &lt;&lt; endl;<br><br>  } catch (exception&amp; e) {cout &lt;&lt; "Exception: " &lt;&lt; e.what();}<br>  return 0;<br>}</p></td><td style="background: #e7e7e7; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid silver 0.75pt; border-left:  none; border-bottom:  solid silver 0.75pt; border-right:  solid silver 0.75pt;"  ><p>Null pointer on second type-cast</p></td></tr></table></div><p> &nbsp;</p><div><table style="border-collapse:collapse; background: white;"  border="0"  ><colgroup><col style="width:697px;"  /><tbody valign="top"  ><tr><td vAlign="middle"  style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid black 0.75pt; border-left:  solid black 0.75pt; border-bottom:  solid black 0.75pt; border-right:  solid black 0.75pt;"  ><p><strong>Compatibility note:</strong> dynamic_cast requires the Run-Time Type Information (RTTI) to keep track of dynamic types. Some compilers support this feature as an option which is disabled by default. This must be enabled for runtime type checking using dynamic_cast to work properly.</p></td></tr></table></div><p><br>The code tries to perform two dynamic casts from pointer objects of type CBase* (pba and pbb) to a pointer object of type CDerived*, but only the first one is successful. Notice their respective initializations: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:196px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>CBase * pba = new CDerived;<br>CBase * pbb = new CBase;</p></td></tr></table></div><p><br>Even though both are pointers of type CBase*, pba points to an object of type CDerived, while pbb points to an object of type CBase. Thus, when their respective type-castings are performed using dynamic_cast, pba is pointing to a full object of class CDerived, whereas pbb is pointing to an object of class CBase, which is an incomplete object of class CDerived.<br>When dynamic_cast cannot cast a pointer because it is not a complete object of the required class -as in the second conversion in the previous example- it returns a null pointer to indicate the failure. If dynamic_cast is used to convert to a reference type and the conversion is not possible, an exception of type bad_cast is thrown instead.<br>dynamic_cast can also cast null pointers even between pointers to unrelated classes, and can also cast pointers of any type to void pointers (void*).<br><strong>   </strong></p><p><strong>static_cast<br></strong>static_cast can perform conversions between pointers to related classes, not only from the derived class to its base, but also from a base class to its derived. This ensures that at least the classes are compatible if the proper object is converted, but no safety check is performed during runtime to check if the object being converted is in fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the conversion is safe. On the other side, the overhead of the type-safety checks of dynamic_cast is avoided. </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:278px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>class CBase {};<br>class CDerived: public CBase {};<br>CBase * a = new CBase;<br>CDerived * b = static_cast&lt;CDerived*&gt;(a);</p></td></tr></table></div><p><br>This would be valid, although b would point to an incomplete object of the class and could lead to runtime errors if dereferenced.<br>static_cast can also be used to perform any other non-pointer conversion that could also be performed implicitly, like for example standard conversion between fundamental types: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:171px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>double d=3.14159265;<br>int i = static_cast&lt;int&gt;(d); </p></td></tr></table></div><p><br>Or any conversion between classes with explicit constructors or operator functions as described in "implicit conversions" above.<br><strong>   </strong></p><p><strong>reinterpret_cast<br></strong>reinterpret_cast converts any pointer type to any other pointer type, even of unrelated classes. The operation result is a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked.<br>It can also cast pointers to or from integer types. The format in which this integer value represents a pointer is platform-specific. The only guarantee is that a pointer cast to an integer type large enough to fully contain it, is granted to be able to be cast back to a valid pointer.<br>The conversions that can be performed by reinterpret_cast but not by static_cast are low-level operations, whose interpretation results in code which is generally system-specific, and thus non-portable. For example: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:13px;"  /><col style="width:214px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>class A {};<br>class B {};<br>A * a = new A;<br>B * b = reinterpret_cast&lt;B*&gt;(a);</p></td></tr></table></div><p><br>This is valid C++ code, although it does not make much sense, since now we have a pointer that points to an object of an incompatible class, and thus dereferencing it is unsafe.<br><strong>   </strong></p><p><strong>const_cast<br></strong>This type of casting manipulates the constness of an object, either to be set or to be removed. For example, in order to pass a const argument to a function that expects a non-constant parameter: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:21px;"  /><col style="width:337px;"  /><col style="width:338px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>// const_cast<br>#include &lt;iostream&gt;<br>using namespace std;<br><br>void print (char * str)<br>{<br>  cout &lt;&lt; str &lt;&lt; endl;<br>}<br><br>int main () {<br>  const char * c = "sample text";<br>  print ( const_cast&lt;char *&gt; (c) );<br>  return 0;<br>}</p></td><td style="background: #e7e7e7; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid silver 0.75pt; border-left:  none; border-bottom:  solid silver 0.75pt; border-right:  solid silver 0.75pt;"  ><p>sample text</p></td></tr></table></div><p><br><strong>typeid<br></strong>typeid allows to check the type of an expression: <br>typeid (expression)<br>This operator returns a reference to a constant object of type type_info that is defined in the standard header file &lt;typeinfo&gt;. This returned value can be compared with another one using operators == and != or can serve to obtain a null-terminated character sequence representing the data type or class name by using its name() member. </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:21px;"  /><col style="width:337px;"  /><col style="width:338px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>// typeid<br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>using namespace std;<br><br>int main () {<br>  int * a,b;<br>  a=0; b=0;<br>  if (typeid(a) != typeid(b))<br>  {<br>    cout &lt;&lt; "a and b are of different types:\n";<br>    cout &lt;&lt; "a is: " &lt;&lt; typeid(a).name() &lt;&lt; '\n';<br>    cout &lt;&lt; "b is: " &lt;&lt; typeid(b).name() &lt;&lt; '\n';<br>  }<br>  return 0;<br>}</p></td><td style="background: #e7e7e7; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid silver 0.75pt; border-left:  none; border-bottom:  solid silver 0.75pt; border-right:  solid silver 0.75pt;"  ><p>a and b are of different types:<br>a is: int *<br>b is: int  </p></td></tr></table></div><p><br>When typeid is applied to classes typeid uses the RTTI to keep track of the type of dynamic objects. When typeid is applied to an expression whose type is a polymorphic class, the result is the type of the most derived complete object: </p><div><table style="border-collapse:collapse;"  border="0"  ><colgroup><col style="width:21px;"  /><col style="width:337px;"  /><col style="width:338px;"  /><tbody valign="top"  ><tr><td style="padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-right:  solid #c0c0d0 0.75pt;"  ><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p></td><td style="background: #efefff; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid #c0c0d0 0.75pt; border-left:  none; border-bottom:  solid #c0c0d0 0.75pt; border-right:  solid #c0c0d0 0.75pt;"  ><p>// typeid, polymorphic class<br>#include &lt;iostream&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;exception&gt;<br>using namespace std;<br><br>class CBase { virtual void f(){} };<br>class CDerived : public CBase {};<br><br>int main () {<br>  try {<br>    CBase* a = new CBase;<br>    CBase* b = new CDerived;<br>    cout &lt;&lt; "a is: " &lt;&lt; typeid(a).name() &lt;&lt; '\n';<br>    cout &lt;&lt; "b is: " &lt;&lt; typeid(b).name() &lt;&lt; '\n';<br>    cout &lt;&lt; "*a is: " &lt;&lt; typeid(*a).name() &lt;&lt; '\n';<br>    cout &lt;&lt; "*b is: " &lt;&lt; typeid(*b).name() &lt;&lt; '\n';<br>  } catch (exception&amp; e) { cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; endl; }<br>  return 0;<br>}</p></td><td style="background: #e7e7e7; padding-top: 1px; padding-left: 1px; padding-bottom: 1px; padding-right: 1px; border-top:  solid silver 0.75pt; border-left:  none; border-bottom:  solid silver 0.75pt; border-right:  solid silver 0.75pt;"  ><p>a is: class CBase *<br>b is: class CBase *<br>*a is: class CBase<br>*b is: class CDerived</p></td></tr></table></div><p><br><em>Note: The string returned by member name of <a rel="nofollow" href="http://www.cplusplus.com/type_info"  >type_info</a> depends on the specific implementation of your compiler and library. It is not necessarily a simple string with its typical type name, like in the compiler used to produce this output.</em>   <br>Notice how the type that typeid considers for pointers is the pointer type itself (both a and b are of type class CBase *). However, when typeid is applied to objects (like *a and *b) typeid yields their dynamic type (i.e. the type of their most derived complete object).<br>If the type typeid evaluates is a pointer preceded by the dereference operator (*), and this pointer has a null value, typeid throws a bad_typeid exception.<br>What our compiler returned in the calls <a rel="nofollow" href="http://www.cplusplus.com/type_info"  >type_info</a>::name in the this example, our compiler generated names that are easily understandable by humans, but this is not a requirement: a compiler may just return any string.<br>  </p>
</body></html>