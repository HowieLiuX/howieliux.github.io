<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：[转]Visual C++ 异常（Exception）常见问题 (原文标题：A Visual C++ Exception FAQ)</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>[转]Visual C++ 异常（Exception）常见问题 (原文标题：A Visual C++ Exception FAQ)</h2>
<p align="right">发布时间：2012-7-4 17:56
<br>分类名称：SEH</p><br>
<p style="text-align: center; margin: 0cm 0cm 0pt;"  align="center"  ><span style="font-size: 18pt;"  lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ </span></span><span style="font-family: 宋体; font-size: 18pt; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常（</span><span style="font-size: 18pt;"  lang="EN-US"  ><span style="font-family: Calibri;"  >Exception</span></span><span style="font-family: 宋体; font-size: 18pt; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）常见问题</span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >版权：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Doug Harrison 2001 – 2007</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >翻译：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >magictong</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（童磊） 2011年3月</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >原文地址：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >http://members.cox.net/doug_web/eh.htm</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >本文讨论了一些在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中实现的，关于</span><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: Calibri;"  > <span lang="EN-US"  >try{} catch(…) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >和异常的问题。本文使用一问一答交流的方式来逐步深入的讨论，因此如果你以一个整体来读完全文将会获得更多的知识。为了让你对下面的讨论有一个大体上的认识，我们可以先浏览一下问题列表：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q1 </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >对于下面的代码，我不明白当我使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >release</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式或其他的编译模式，但是使用了优化选项后（例如：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/O1</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >或者</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >O2</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），为什么</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…) </span></strong></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >就不能捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常了。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q2 </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >同样是上面的代码，令我很不能理解的是如果我使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >debug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式或者编译选项加上</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHa</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >后，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常可以被捕获了（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。而且，有时候我发现在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >release</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式下，如果你使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/GX</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译选项</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…) </span></strong></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >居然也可以捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）结构化异常。难道</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…) </span></strong></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >不是仅仅支持</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常吗？</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q3 </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >如果在</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…) </span></strong></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >里面捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），它的影响是什么？</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: Calibri;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >Q4 </span></strong><span style="mso-bidi-font-weight: bold;"  lang="EN-US"  >_set_se_translator</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-weight: bold;"  >是什么？</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: Calibri;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >Q5</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >我应该怎样正确的处理这些问题？</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: Calibri;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >Q6</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >程序中，我应该怎样安全的使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > _com_error</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >std::exception</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，和其他的非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常类？</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >本文适用于</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET 2003</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >以及后续的版本。</span><span style="font-family: Calibri;"  > </span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >即将发布的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 2005</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（译者注：本文的写作时间已经有几年了，不用纠结这个），代号“</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Whidbey</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >”，纠正了下面讨论的一个问题，并且这部分影响到问题</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q1</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q2</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >和</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，它们已经相应地更新了。其它的问题和解答适用于</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >和以后的版本。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > </span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q1</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、对于下面的代码，我不明白当我使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >release</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式或其他的编译模式，但是使用了优化选项后（例如：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/O1</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >或者</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >O2</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），为什么</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} catch(…) </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >就不能捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常了。</span></strong></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >#include &lt;stdio.h&gt;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >int main()</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;try</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int* p = 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*p = 0; // Cause access violation</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;catch (...)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts("Caught access violation");</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp;&nbsp;}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >&nbsp;&nbsp; return 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >}</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >A</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、从</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >到</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET 2003</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的系列中，如果你用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/GX</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >或者</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译选项进行编译，而这两个编译选项的含义是开启编译器的同步异常模式。在这种模式下仅仅捕获通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句抛出的异常，显然，上面的代码中没有</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句。如果你仔细检查这个程序的汇编代码，你会发现编译器优化了整个异常处理机制，整个异常处理无影无踪了，因为编译器可以确定</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中的代码不会抛出一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常。这是多么牛逼的优化！特别是当有大量的模板代码存在时，这种优化特别有效。然而不幸的是，这里有一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，造成在某些情况下</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >会捕获住</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常，这直接导致了下一个问题的产生。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q2 </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >同样是上面的代码，令我很不能理解的是如果我使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >debug</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式或者编译选项加上</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHa</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >后，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常可以被捕获了（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。而且，有时候我发现在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >release</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译模式下，如果你使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/GX</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译选项</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} catch(…) </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >居然也可以捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）结构化异常。难道</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} catch(…) </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >不是仅仅支持</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常吗？</span></strong></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >A</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、根据</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Stroustrup</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的说法，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++ </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常处理（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >EH</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）并没有打算处理信号或者其它的低级的操作系统特殊事件，譬如算术异常之类的。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）明确的归入了这个类别，从某种意义上来讲，</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >try{} catch(…) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >捕获到</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >结构化异常是不可能的。然而，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >标准并没有明确的禁止这种行为，任何时候抛出一个结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）都是一种未定义的行为，因此看起来</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >捕获结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）也是“合法”的行为。从技术的角度来说，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++ </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >标准也并未对这种未定义行为（譬如间接引用一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >NULL</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >指针）强加任何的要求。也就是说，使用</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >正确的捕获所有的异常看起来是很方便的，捕获了结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）就捕获了大量问题的根源，在讨论我为什么这么说之前，我们先看看</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的文档对于这种行为是怎么说的。</span><span style="font-family: Calibri;"  > </span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >及其之后的版本定义了两种异常处理模型，分别称之为同步模型和异步模型。模型的选择可以通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EH</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译命令行来控制，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >表示使用同步模型，而</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHa</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >表示使用异步模型。在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >和其他的一些应用程序框架中默认定义了一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/GX</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译命令行，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/GX</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >和</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHsc</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >是等价的，所以它的意思是选择同步模型（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >c</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的意思是说被</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > extern “C” </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >修饰的函数是不抛出异常的）。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >VC++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的文档中是这样定义异步模型的：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的之前版本中，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的异常处理机制默认是支持处理异步异常（硬件异常）的，在异步模型下，编译器假设任何一条指令都可能引发一个异常。</span></em></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（译注：所谓同步异常和异步异常我的理解是，同步异常就是程序中通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句显示抛出的异常，比如</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >IO</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >错误，内存分配失败，数组越界等等，哪里会抛出异常，可以提前预知，而异步异常一般是指系统的硬件异常，访问空指针，除</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >0</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >错等等，这种异常完全无法预知，在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >VC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >debug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模式下编译器对</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中语句会捕获异步异常，而</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >release</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模式则不会。当然这些是可以通过修改编译选项来控制的）</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在异步模型下，</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…) </span></strong></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >是可以捕获结构化异常的，如果你真的想这样做，你必须设置编译选项</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHa</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >。另外，你可以使用函数</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_set_se_translator()</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >把结构化异常转化为</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，从而像捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常一样捕获结构化异常，但是你也必须使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHa</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编译选项（可以参考</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q4</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  ><span style="font-size: small;"  >同步模型可以参考下面的描述：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >默认情况下，新的同步异常模型只能通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句抛出。因此，编译器就可以作出一个假设，异常只可能在显示调用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句或者调用函数的时候发生。如果对象的生命期和函数调用或者</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >throw</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句不重叠的话，在这种模型下，编译器可以完全删除为了对像进行</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >unwind</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >操作而跟踪对象生命期的代码，从而显著的减少代码的大小。</span></em></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >同步异常模型本来准备想按</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Stroustrup</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >说的那样来仅仅支持</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，不过，从</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >到</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET2003</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，这点都没有用文档进行明确说明，所以，如果你编译的时候没有使用优化，或者使用了编译优化但是优化器不能判断</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句中是否会抛出一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，那么</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >仍然可能捕获到一个结构化异常的（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。举个例子，在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >VC5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中，如果</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句中调用了一个函数，那么优化器就假定它可能抛出一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，但是到了</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >VC6</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中，这个函数可能是在另一个编译单元（源文件）中，这些使优化器感到迷茫不堪（译注：用流行的说话就是杯具）。最终，在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET2005</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中才纠正了同步模型的这些缺陷。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q3 </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >如果在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} catch(…) </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >里面捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），它的影响是什么？</span></strong></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >A</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、要回答这个问题，我们首先需要搞清楚</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常和结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）的特点和特征。根据</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Stroustrup</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的说法，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异 常处理就是错误处理。譬如，申请内存失败或者写文件时磁盘空间不足，这些错误最好的通知的方法就是抛出一个异常，特别是在正常情况下这些资源都是足够的。 这种方法可以极大的简化那些需要检查函数的返回值的代码，而且它可以使你能够集中处理一些错误。这类错误很有可能是在一个正确的程序中发生的（译注：就里 是指这不是程序</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，而是可以预知的错误），而这正是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常处理想要达到的目标。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >另一方面，结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）一般就是标识着一个典型的程序</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >了。大家应该对引用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >NULL</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >指针而造成访问违例耳熟能详。硬件能够检测到这种错误并且能够对其捕获（译注：产生一个中断），然后</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >windows</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >把这种特殊的硬件事件转化为一个结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。出现结构化异常基本上就表示程序写的有点问题了，一个正确的程序不应该产生这种错误。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（结构化异常）也用于系统的一些常规运行，举个例子，你使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >VirtualAlloc()</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在内存中申请预留了一片地址空间并动态的给一些页面开放访问权限，就有可能使程序访问到了未经授权的内存地址，从而导致了一个页错误。使用</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >__try __except</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句程序可以捕获到这种异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）并解除内存的访问权限，然后从导致异常的指令处恢复程序的执行。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常是无法做到的，因为它不能够干预到这种行为。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常和</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的结构化异常是完全不同的东西。如果在</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中一致的予以捕获会产生如下一些问题：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >1</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、如果</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >可以捕获结构化异常，可能你会自信的写下如下的代码：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// Begin exception-free code</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>... Update critical data structure</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// End exception-free code</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >如果关键代码段有一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >并且会导致一个结构化异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），外层的</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >块可能捕获到这个异常，但是这会把整个程序的状态流程引向一个完全意想不到的地方。然后程序可能会像一架失控的飞机一样继续往前运行，结果造成更大的破坏。幸运点的话，在造成严重的破坏之前，随后引发的一个未被捕获的结构化异常将使程序异常终止。但是，如果</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >没有捕获最开始的那个结构化异常，程序调试起来可能更容易点，因为最终造成程序崩溃（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）的地方可能已经离那个真正有</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的地方很远了。操作系统会报告这个未被捕获的结构化异常，让你有机会对程序进行调试，但是这种情况下它可能把你带到了最后一个异常（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）发生的源代码位置，而不是那个实际问题发生的地方。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >2</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、下面的代码更是令人疑惑不解……</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 15.75pt; margin: 0cm 0cm 0pt 21pt; mso-para-margin-left: 2.0gd; mso-char-indent-count: 1.5;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >try</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;</span>TheFastButResourceHungryWay();</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>catch (...)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>TheSlowButSureWay();</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块中，如果程序有一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >或者编译器生成的代码有</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >造成了一次访问违例（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >access violation</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >），因为</span><span style="font-family: Calibri;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  > try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >对结构化异常的捕获使你没法发现这个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >。而它唯一的表现可能就是运行极其的缓慢而已，而且在测试中还不一定出现。如果</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{}catch(...) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >不捕获这个异常的话你肯定会在测试阶段发现这个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >bug</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（操作系统的那个经典的提示程序运行异常终止的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >messagebox</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >不出意外都会蹦出来的）。</span></span></p> <p style="line-height: 15.75pt; text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >3</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、系统的正常运行可能会受到影响甚至破坏，例如，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >CPropertySheet::DoModal()</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的文档中明确说到不要在这个函数里面使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{}catch(...) </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >。</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >DebugBreak</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >API</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）抛出的异常可能会被</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >捕获，导致</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >DebugBreak</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >失去了效果。同样，如果你正在使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > __try __except </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >来捕获结构化异常，而内部代码又有</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码存在，你可能会遇到麻烦，即使内部的</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(...)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码把异常重新抛了出来，如果你的结构化异常处理程序想从错误的指令处恢复执行你几乎百分百会遇到意想不到麻烦，因为你会发现</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > catch(...) </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块已经进入过了而局部变量也已经全部销毁了，更杯具的是如果恢复执行的地方是在与该</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > catch(...) </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >块相匹配的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块里面，而随后这个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{} </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块又抛出一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，此时你会沮丧的发现结构化异常处理函数陷入了一个无限调用死循环中。<em style="mso-bidi-font-style: normal;"  >（译注：感觉此小点原文这个地方讲得有点含糊。有兴趣的可以参照一下原文，大概就是这个意思。按我的理解是这样的，首先</em></span><em style="mso-bidi-font-style: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >__try/__except</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句中，在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__excep</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >后面的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >()</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中是一个表达式，表达式返回值可以是下面三个中的一个：</span></em></span></p> <p style="line-height: 15.75pt; text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >EXCEPTION_CONTINUE_EXECUTION(–1)</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >则表示异常被忽略，控制流将在异常出现的指令点继续恢复运行。</span></em></span></p> <p style="line-height: 15.75pt; text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >EXCEPTION_CONTINUE_SEARCH(0)</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >表示异常未被识别，也就是说当前的这个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__except</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模块不是这个异常错误所对应的正确的异常处理模块。系统将继续到上一层的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__try/__except </span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >域中继续查找一个恰当的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__except</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模块。</span></em></span></p> <p style="line-height: 15.75pt; text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >EXCEPTION_EXECUTE_HANDLER(1) </span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >表示异常已经被识别，也即当前的这个异常错误，系统已经找到了并能够确认，这个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__except</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模块就是正确的异常处理模块。控制流将进入到</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >__except</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >模块中。</span></em></span></p> <p style="line-height: 15.75pt; text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >如果结构化异常处理函数返回</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >-1</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，也就是说希望程序在异常点恢复执行，其实是一种风险很大的行为，很有可能再次异常，然后再次进入异常处理函数，然后函数返回</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >-1</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，再恢复执行……如此死循环在这里。个人觉得适合</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >EXCEPTION_CONTINUE_EXECUTION(–1)</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的场合是很少的。）</span></em></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >4</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、应用程序框架使用</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{}catch(...) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >来防范用户的代码变成了一个有风险的行为（基于以上的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >3</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >点），而通常情况下是应该要这么做的。例如，如果</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >框架不使用</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{}catch(...) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >来保护自己，结果可能由于用户代码中一个未被捕获的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常导致了整个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >应用程序异常终止。</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q4 <span style="mso-bidi-font-weight: bold;"  >_set_se_translator</span></span></span></strong><strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >是什么？</span></strong><strong style="mso-bidi-font-weight: normal;"  ></strong></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >A</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_set_se_translator</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >是一个由</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >运行时库提供的函数，可以用它来注册一个回调异常转换函数，该函数可以用来把一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >win32</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >结构化异常转换成真正的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常。它可以让你部分的避免在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q3</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中描述过的</span><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >try{} catch(…) </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >问题，譬如你可以写下如下的代码，其中</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >se_t</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >是转换函数抛出的异常对象的类型。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >catch (se_t) { throw; }</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >catch (...) { ... }</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >这不是一个特别好的解决方案，因为你容易忘记在每个</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >里面增加像上面那样的代码。如果你要使用这种方法，你必须要在每个线程开始执行代码前设置回调异常转换函数，而且每个结构化异常的处理程序仅仅是某一个线程的属性，你在某个线程中调用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_set_se_translator</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >函数是不会影响到另外一个线程的，而且，回调异常转换函数是不能被新的线程所继承的，因此，在调用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_set_se_translator</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >之后创建的线程，这个函数对该线程是没有任何影响的。除了在实现上比较困难和容易出错之外，这种解决方法也不能对那些既不是你写的并且你也不能修改的代码负责，这对于库的使用者来说可能是个问题。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >而最终，文档对于</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_set_se_translator</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >函数是否可以值得信赖的使用说得也不明确，而且你必须选择</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q2</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中讨论过的异步异常处理模型，在这种模型下，你的目标代码的大小会迅速膨胀。如果你不这么做，你的代码可能会像</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q1</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中讨论过的那样被优化。</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q5 </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >我们应该怎样去处理这些？</span></strong></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="mso-tab-count: 1;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>A</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >、如果你使用的是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ 5</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >到</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET 2003</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的版本，最好的方法就是尽可能的避免使用</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，如果必须要使用的话，你最好意识到上面讨论过的一些问题。不过在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Visual C++ .NET 2005</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >中，编译选项</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >/EHs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的行为已经和文档上描述的一致了，同步异常模型的行为也正常了，在这种模型下你也不用再担心</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{} catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >会捕获结构化异常了（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >SEs</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）。</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  ><span style="font-family: Calibri;"  >Q6 </span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >程序中，怎样才能安全的使用</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > _com_error</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >std::exception</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，和其他的非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span></strong><strong style="mso-bidi-font-weight: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常类？</span></strong></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  ><span style="mso-tab-count: 1;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>A</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >、在</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >Visual C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >支持</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >异常处理之前，</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >就已经被设计出来了，</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >最原始的异常设计是基于宏（</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >macro</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >）的，如</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >TRY</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >和</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CATCH</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >之类，这些宏利用</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >setjmp</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >和</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >longjmp</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >函数来模拟</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的异常处理。为了简化实现，在</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的早期版本中仅仅支持抛出一个</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CException</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的指针类型，譬如一个指向</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CException</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >对象的指针或者一个从</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CException</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >派生类的对象的指针。即使后来</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >更新到</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >Visual C++2.0</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >并且开始支持</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的异常处理之后，也从来没有支持过其他的异常类型，而且</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的源代码中继续使用这套宏，只不过现在它是使用</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >的异常处理来定义的，譬如，在</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >中，它把</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CATCH_ALL</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >定义为：</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  ><span style="font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >catch (CException* e)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  ><span style="mso-tab-count: 1;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >很明显，如果</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >try</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >代码块中使用了</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >标准库，</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >COM</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >库，或者是其它的外部库等等一些定义了自己的异常类型的库，这种方式是不能够捕获所有的</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >C++</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >异常的。</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >MFC</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >除了使用</span><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  >CException*</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Tahoma; mso-font-kerning: 0pt; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma;"  >异常类型外，没有使用任何其他的异常类型，因此很多情况下，你的代码可能被包装成下面这样：</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  ><span style="font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >TRY</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// Call your code</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >CATCH_ALL(e)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// Clean up and perhaps report the error to the user</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >END_CATCH_ALL</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-family: &quot;Tahoma&quot;,&quot;sans-serif&quot;; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt;"  lang="EN-US"  ><span style="font-size: small;"  >&nbsp;</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="mso-tab-count: 1;"  ><span style="font-family: Calibri;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >比如说，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的窗口过程函数就是使用这种方式保护起来的，因为异常是不允许跨越</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >windows</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的消息边界的。不过，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >CATCH_ALL</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >也只捕获</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，如果一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的异常捕获失败，你的程序可能因为未被捕获的异常而异常终止。即使你自己去捕获这些异常，在哪个地方去捕获它们也是非常重要的，因为在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >里面有许多的函数希望捕获住所有的异常，然后它们可以做一些清理工作或者通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >return</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >语句给调用者返回一个错误码。现在，如果</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >块中的函数里面调用到你的代码，而你的代码里面并没有立即把一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常转化成一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，也就是说你允许一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码里面进行传播，并希望全部捕获它们，但是就像刚才说的那样，（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）并不会捕获它，也确实没有捕获它。即使你的非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常是在同层次的外部代码上被捕获的，也可能有点晚了，你最终可能还是会跳过一些重要的清理代码。所有的这些表明，我们应该遵从下面的规则：</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >禁止非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常在</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码中传播（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Never allow a non-MFC exception to pass through MFC code</span></span></em><em style="mso-bidi-font-style: normal;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）</span></em></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="mso-tab-count: 1;"  ><span style="font-family: Calibri;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >就最低限度上来说，通过使用</span><span style="font-family: Calibri;"  > <strong style="mso-bidi-font-weight: normal;"  ><span lang="EN-US"  >try{}catch(…)</span></strong><span lang="EN-US"  > </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >也要保护每一个消息处理程序在遇到一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常的时候能够友好的退出程序。如果一个消息处理程序对一个异常不能进行处理，并且希望把异常报告给用户，那么对于处理程序来讲友好的退出程序可能更合适。假如</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >能捕获这个异常的话，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >将会给用户呈现一个更友好的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >messagebox</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >来描述这个错误。要达到这个目的，你需要把一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常转换成一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，你可以借助宏（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >macro</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）来实现。例如，可以看一下下面的代码：</span><span style="font-family: Calibri;"  > </span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >class MfcGenericException : public CException</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >public:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>// CException overrides</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>BOOL GetErrorMessage(</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LPTSTR lpszError,</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>UINT nMaxError,</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>PUINT pnHelpContext = 0)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSERT(lpszError != 0);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ASSERT(nMaxError != 0);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pnHelpContext != 0)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>*pnHelpContext = 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>_tcsncpy(lpszError, m_msg, nMaxError-1);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lpszError[nMaxError-1] = 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return *lpszError != 0;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >protected:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>explicit MfcGenericException(const CString&amp; msg)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>:<span style="mso-spacerun: yes;"  >&nbsp; </span>m_msg(msg)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >private:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>CString m_msg;</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >};</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >class MfcStdException : public MfcGenericException</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >public:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>static MfcStdException* Create(const std::exception&amp; ex)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return new MfcStdException(ex);</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >private:</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>explicit MfcStdException(const std::exception&amp; ex)</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>: MfcGenericException(ex.what())</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>}</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >};</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >#define MFC_STD_EH_PROLOGUE <span style="mso-spacerun: yes;"  >&nbsp;</span>try {</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >#define MFC_STD_EH_EPILOGUE /</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>} catch (std::exception&amp; ex) { throw MfcStdException::Create(ex); }</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="mso-tab-count: 1;"  ><span style="font-family: Calibri;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >上面的代码定义了一个类：</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcGenericException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >，它是从</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >CException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >继承而来，并且它是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >等其他非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常类的基类（我们需要这个基类的原因是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >并没有提供一个封装异常消息字符串的通用异常类）。底部定义的宏是为了用来方便的包含那些可能会抛出一个非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常的代码，譬如你的消息处理函数或者其他被</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >调用的代码。你可以这样使用它们：</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >void MyWnd::OnMyCommand()</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >{</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >MFC_STD_EH_PROLOGUE</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  ><span style="mso-spacerun: yes;"  >&nbsp;&nbsp; </span>... your code which can throw std::exception</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >MFC_STD_EH_EPILOGUE</span></span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="color: #c00000;"  lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="font-size: small;"  >}</span></span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span lang="EN-US"  ><span style="font-family: Calibri; font-size: small;"  >&nbsp;</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="mso-tab-count: 1;"  ><span style="font-family: Calibri;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在这里，通过这两个宏把你的代码包含的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块，而</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC_STD_EPILOGUE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >宏还把</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >std::exception</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常类型转换成了</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >可以捕获的异常类型，在这里是转换成了</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >。注意的是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >有一个私有的构造函数，并且定义了一个静态</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Create</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >函数，而后者提供的功能就是在堆上创建一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >对象。</span></span></p> <p style="text-indent: 21pt; margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >总之，这些宏通过</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >try</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >代码块来保护你的代码，并且</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC_STD_EH_EPILOGUE</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >宏把</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >std::exception</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常转换成了</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常重新抛出，上面代码里面是转换成了</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常对象。需要注意的是</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >这个异常类只有一个私有（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >private</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）的构造函数并且定义了一个静态</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Create</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >函数，而后者提供的功能就是在堆上创建一个</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >对象。这样就确保了异常类只能在堆上被创建，而这正是我们所需要的，因为每个对象都维护着一份错误的状态信息，如果我们像</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >AfxThrowMemoryException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >那 样简单的抛出一个静态对象的指针，那样线程安全就是一个很大的问题，可能会发生这样的情况，这个线程正在抛出和处理异常，此时另一个线程也抛出了一个异 常，那么后一个抛出的异常可能会覆盖前一次的异常信息。在这种情况下我们无任何捷径可走！无论谁捕获了异常都有责任调用异常对象从</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >CException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >继承下来的</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >Delete</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >成员函数。该函数的作用是删除</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MfcStdException</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >对象，通过禁止局部异常对象的创建，可以很好的避免抛出局部异常对象指针的错误行为。</span></span></p> <p style="margin: 0cm 0cm 0pt;"  ><span style="font-size: small;"  ><span lang="EN-US"  ><span style="mso-tab-count: 1;"  ><span style="font-family: Calibri;"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >在进行</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >编程的时候，如果混用各种各样的异常类型，要想保持程序的健壮性，使用一种类似于上面的技术是必不可少的。这也比直接写</span><span lang="EN-US"  ><span style="font-family: Calibri;"  > try{}catch(...) </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >来捕获更容易一点，而且它会把异常抛给最适合处理该异常的代码块。实际上，在一个良好设计的程序中直接写</span><span lang="EN-US"  ><span style="font-family: Calibri;"  ><span style="mso-spacerun: yes;"  >&nbsp; </span>try{}catch(...) </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >很少见的，使用这种方法写的代码能够通过堆栈的自动展开（</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >unwinding</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >）和局部变量的自动析构来做保证程序是正确的。因此，异常处理的最后一步往往就是简单的告诉用户哪里出了问题，通过把非</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常转成</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >异常，</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >MFC</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >就可以很轻松的搞掂最后的处理工作</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >o(</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >∩</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >_</span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >∩</span><span lang="EN-US"  ><span style="font-family: Calibri;"  >)o </span></span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;"  >。</span></span></p>
</body></html>