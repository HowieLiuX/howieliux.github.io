<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8"><title>163 blogs的博客：CppUnit源码解读 I</title>
<style type="text/css">
a{color: #000000;text-decoration : none;font-size: 10pt;}
a:hover {color: red;text-decoration : underline;}
.replyBox{padding:4px;border:1px solid #D8D8D8;}
</style></head><body><h2>CppUnit源码解读 I</h2>
<p align="right">发布时间：2010-2-12 11:55
<br>分类名称：Private</p><br>
<h1><a rel="nofollow"   ><br></a></h1>  <div>    </div>  <div><div></div></div>  <h2><a rel="nofollow"   >序言</a></h2>  <div>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >引言</a></h3>  <div>    <p>  如何将诸多技术综合运用到一个实际的framework中来，笔者以为，CppUnit为我们提供了一个难易适中的参考范例。这应该是一个很好的例子，因  为它不甚复杂，却汇聚了一个framework所必需的某些设计思想以及实现技巧。在这里，我们可以看到STL的实际使用（包括一些简单的traits技  法），Design   Pattern的灵活运用（比如：Composite，Factory，Decorator，Singleton，Observer等）。  </p>    <p>  当然，也应该指出，由于CppUnit还在不断改进中，其代码中未免还有“败笔”及不尽如人意之处。但是，瑕不掩瑜，并且从中我们也可以感受到一个成熟框  架的演进过程。  </p>    <p>  由于有过一点framework的设计经验和体会，笔者在阅读CppUnit源码的过程中，时常能有共鸣，并且对于框架的设计者在某些细节的处理方法，也  深以为然，偶尔也有“英雄所见略同”的感叹。希望可以通过笔者的讲解，使大家也能够同样有亲历之感。    </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >CppUnit的简单身世</a></h3>  <div>    <p>  CppUnit是xUnit系列中的c++实现版本，它是从JUnit移植过来的，第一个移植版本由Michael   Feathers完成，相关信息可以在<a title="http://www.xprogramming.com/software.htm" target="_blank" rel="nofollow" href="http://www.xprogramming.com/software.htm"    >http://www.xprogramming.com/software.htm</a>找  到。它是操作系统相关的，随后，Jerome   Lacoste将之移植到了Unix/Solaris，在上述连接中也能找到该版本的相关信息。CppUnit项目就是基于这些版本建立起来的。有关   CppUnit的讨论可以在<a title="http://c2.com/cgi/wiki?CppUnit" target="_blank" rel="nofollow" href="http://c2.com/cgi/wiki?CppUnit"    >http://c2.com/cgi/wiki?CppUnit</a>找  到，在那里你还可以找到CppUnit先前的版本以及许多其它操作系统环境下的移植版本。这个库受GNU LGPL（Lesser General   Public License）的保护。作者包括：Eric Sommerlade (sommerlade@gmx.net)，Michael   Feathers (mfeathers@objectmentor.com)，Jerome Lacoste   (lacostej@altern.org)，J.E. Hoffmann ，Baptiste Lepilleur ，Bastiaan Bakker   ，Steve Robbins   </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >CppUnit的总体构成</a></h3>  <div>    <p>  作为一个完整的CppUnit framework，虽然源码所在的实际路径可能不尽相关，但从逻辑上讲它们被划为如下几个部分：   </p>  <ul><li><div> core：CppUnit的核心部分</div>  </li><li><div> output：掌管结果输出</div>  </li><li><div> helper：一些辅助类</div>  </li><li><div> extension：作为单元测试的延伸，对CppUnit   core部分的扩展（比如：常规测试，重复测试）</div>  </li><li><div> listener：监视测试进程和测试结果</div>  </li><li><div> textui：一个运行单元测试的文本环境</div>  </li><li><div> portability：提供针对不同平台的移植设置 </div>  </li></ul>    <p>   上述所有的内容均被置于CppUnit名字空间之内。    </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >几点说明</a></h3>  <div>  <ul><li><div>   本文主要内容依据CppUnit源码而来，部分内容还来自于源码自身所附的注释、ChangeLog等</div>  </li><li><div>   本文只作源码解读，至于xUnit家族的相关背景及基本知识笔者不准备叙述，读者可以参看相关文章</div>  </li><li><div> 对于文中所涉及的Design   Pattern，Refactoring，STL等相关知识，请读者参看相关资料。</div>  </li><li><div>   除了文章本身，文中所列源码，也夹带了morning的一些注释，用以进一步说明代码意图，注释中方括号内为morning的疑问</div>  </li><li><div>   为了节省篇幅、简化内容、突出主题，文中未列出全部代码，而是有选择的给出部分代码 </div>  </li></ul>    </div>  <div><div></div></div>  <h2><a rel="nofollow"   >核心部分（Core）</a></h2>  <div>    <p>  在CppUnit中，有一个贯穿始终的最基本的pattern，那便是Composite   Pattern。在GoF中对该pattern有如下描述：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象  和组合对象的使用具有一致性。在CppUnit的框架中，测试类分为两种，某些测试类代表单个测试，比如稍后讲到的TestCase（测试用例），另一些  则由若干测试类共同构成，比如稍后讲到的TestSuite（测试包）。彼此相关的TestCase共同构成一个TestSuite，而  TestSuite也可以嵌套包含。两者分别对应Composite Pattern中的Leaf和Composite。  </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >基本测试类</a></h3>  <div>    </div>    <h4><a rel="nofollow"   >Test</a></h4>  <div>    <p>  相关文件：Test.h  </p>    <p>  这是所有测试类的抽象基类，规定了所有测试类都应该具有的行为，对应于Composite   Pattern中的Component，除了标准的virtual dtor外，还定义了四个纯虚函数：  </p>  <pre>    <span>// 运行测试内容，并利用传入其内的TestResult搜集测试结果，类似Component的Operation操作</span><br>    <span>virtual</span> <span>void</span> run <span>(</span>TestResult *result<span>)</span> = <span>0</span>;<br>&nbsp;<br>    <span>// 返回当前包含的测试对象的个数，若为TestCase，则返回1。</span><br>    <span>virtual</span> <span>int</span> countTestCases <span>(</span><span>)</span> <span>const</span> = <span>0</span>;<br>&nbsp;<br>    <span>// 返回测试的名称，每个测试都有一个名称，就像是标识，用以查找或显示</span><br>    <span>virtual</span> std::<span>string</span> getName <span>(</span><span>)</span> <span>const</span> = <span>0</span>;<br>&nbsp;<br>    <span>// 本测试的简短描述，用于调试输出。</span><br>    <span>// 对测试的描述除了名称外，可能还有其他信息，</span><br>    <span>// 比如：一个名为“complex_add”的测试包可能被描述成“suite complex_add”</span><br>    <span>virtual</span> std::<span>string</span> toString <span>(</span><span>)</span> <span>const</span> = <span>0</span>;</pre>  </div>    <h4><a rel="nofollow"   >TestFixture</a></h4>  <div>    <p>  相关文件：TestFixture.h  </p>    <p>  该类也是抽象类，用于包装测试类使之具有setUp方法和tearDown方法。利用它，可以为一组相关的测试提供运行所需的公用环境（即所谓的  fixture）。要实现这一目的，你需要：   </p>  <ul><li><div>   从TestFixture派生一个子类（事实上，一般的做法是从TestCase派生，这样比较方便，具体见后）</div>  </li><li><div> 定义实例变量（instance variables）以形成fixture</div>  </li><li><div> 重载setUp初始化fixture的状态</div>  </li><li><div> 重载tearDown在测试结束后作资源回收工作 </div>  </li></ul>    <p>     此外，作为完整的测试类，还要定义一些执行具体测试任务的测试方法，然后使用TestCaller进行测试。关于TestCaller，在helper部  分将会讲到。  </p>    <p>  因为每个测试对象运行在其自身的fixture中，所以测试对象之间不会有副作用（side   effects），而测试对象内部的测试方法则共同使用同一个fixture。  </p>    <p>  来看一下TestFixture的定义，除了标准的virtual dtor外，还定义了两个纯虚函数：   </p>  <pre><span>// 在运行测试之前设置其上下文，即fixture</span><br><span>// 一般而言setUp更为重要些，除非实例变量创建于heap中，否则其资源的回收就无需手工处理了</span><br><span>virtual</span> <span>void</span> setUp<span>(</span><span>)</span> <span>{</span><span>}</span>;<br>&nbsp;<br><span>// 在测试运行结束之后进行资源回收</span><br><span>virtual</span> <span>void</span> tearDown<span>(</span><span>)</span> <span>{</span><span>}</span>;</pre>  </div>    <h4><a rel="nofollow"   >TestCase</a></h4>  <div>    <p>  相关文件：TestCase.h，TestCase.cpp  </p>    <p>  派生自Test和TestFixture（多重继承），兼具两者特性，用于实现一个简单的测试用例。你所要做的就是派生该类，并重载runTest方法。  不过通常你不必如此，而是使用TestCaller结合TestFixture的方法，这样很方便。当你发现TestCaller无法满足，你需要重写一  个功能近似的类时，再使用TestCase也不迟。关于TestCaller，在helper部分将会讲到。  </p>    <p>  TestCase中最重要的方法是run方法，来看一下代码，并请留意注释：   </p>  <pre><span>void</span> TestCase::<span>run</span><span>(</span> TestResult *result <span>)</span><br><span>{</span><br>  <span>// 不必关心startTest的具体行为，在讲到TestResult时自然会明白</span><br>  <span>// 末尾的endTest亦是如此</span><br>  result-&gt;startTest<span>(</span><span>this</span><span>)</span>;<br>&nbsp;<br>  <span>try</span> <span>{</span><br>    <span>// 设置fixture，具体内容需留待派生类解决</span><br>    <span>// 可能有异常抛出，处理方式见后</span><br>    setUp<span>(</span><span>)</span>;<br>&nbsp;<br>    <span>// runTest具有protected属性，是真正执行测试的函数</span><br>    <span>// 但具体行为需留待派生类解决</span><br>    <span>try</span> <span>{</span><br>      runTest<span>(</span><span>)</span>;<br>    <span>}</span><br>    <span>// 在运行测试时可能会抛出异常，以下是异常处理</span><br>    <span>catch</span> <span>(</span> Exception &amp;e <span>)</span> <span>{</span><br>      <span>// Prototype  Pattern的一个应用</span><br>      <span>// e是临时对象，addFailure调用之后即被销毁，所以需要创建一个副本</span><br>      Exception *copy = e.<span>clone</span><span>(</span><span>)</span>;<br>      result-&gt;addFailure<span>(</span> <span>this</span>, copy <span>)</span>;<br>    <span>}</span><br>    <span>catch</span> <span>(</span> std::<span>exception</span> &amp;e <span>)</span> <span>{</span><br>      <span>// 异常处理的常用方法——转意</span><br>      result-&gt;addError<span>(</span> <span>this</span>, <span>new</span> Exception<span>(</span> e.<span>what</span><span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>    <span>}</span><br>    <span>catch</span> <span>(</span>...<span>)</span> <span>{</span><br>      <span>// 截获其余未知异常，一网打尽</span><br>      Exception *e = <span>new</span> Exception<span>(</span> <span>"caught unknown exception"</span> <span>)</span>;<br>      result-&gt;addError<span>(</span> <span>this</span>, e <span>)</span>;<br>    <span>}</span><br>&nbsp;<br>    <span>// 资源回收</span><br>    <span>try</span> <span>{</span><br>      tearDown<span>(</span><span>)</span>;<br>    <span>}</span><br>    <span>catch</span> <span>(</span>...<span>)</span> <span>{</span><br>      result-&gt;addError<span>(</span> <span>this</span>, <span>new</span> Exception<span>(</span> <span>"tearDown() failed"</span> <span>)</span> <span>)</span>;<br>    <span>}</span><br>  <span>}</span> <br>  <span>catch</span> <span>(</span>...<span>)</span> <span>{</span><br>    result-&gt;addError<span>(</span> <span>this</span>, <span>new</span> Exception<span>(</span> <span>"setUp() failed"</span> <span>)</span> <span>)</span>;<br>  <span>}</span><br>&nbsp;<br>  result-&gt;endTest<span>(</span> <span>this</span> <span>)</span>;<br><span>}</span></pre>  <p>   可以看到，run方法定义了一个测试类运行的基本行为及其顺序：   </p>  <ul><li><div> setUp：准备</div>  </li><li><div> runTest：开始</div>  </li><li><div> tearDown：结束 </div>  </li></ul>    <p>   而TestCase作为抽象类无法确定测试的具体行为，因此需要留待派生类解决，这就是Template Method   Pattern。事实上，该pattern在framework中是很常见的。因此一个完整测试的简单执行方法是，从TestCase派生一个类，重载相  关方法，并直接调用run方法（正如TestFixture中所提到的）。  </p>    <p>  有意思的是，TestCase中还有run的另一个版本，它没有形参，而是创建一个缺省的   TestResult，然后调用前述run方法。不过好像没怎么用到，大概是先前调试时未及清理的垃圾代码，也难怪会有“FIXME: what is   this for?”这样的注释了。  </p>    <p>  TestCase有两个ctor：   </p>  <pre>TestCase<span>(</span> std::<span>string</span> Name <span>)</span>;        <span>// 测试类的名称</span><br>TestCase<span>(</span><span>)</span>;</pre>  <p>  后者主要用于TestCaller，因为在使用TestCaller时，需要一个default ctor  </p>    <p>  此外，TestCase将copy ctor和operator=声明为private属性，以防止误用。  </p>    </div>    <h4><a rel="nofollow"   >TestSuite</a></h4>  <div>    <p>  相关文件：TestSuite.h，TestSuite.cpp  </p>    <p>  一组相互关联的测试用例，构成了一个测试包，这就是TestSuite，也就是Composite   Pattern中的Composite。和TestCase一样，也派生自Test，只是没有fixture特性。除了测试类的名称外，在   TestSuite中还维护了一个测试对象数组，它被声明为private属性：   </p>  <pre>std::<span>vector</span>&lt;Test *&gt; m_tests;<br><span>const</span> std::<span>string</span> m_name;</pre>  <p>  来看一下TestSuite的run方法是如何实现的，并请留意morning的注释：   </p>  <pre><span>void</span> TestSuite::<span>run</span><span>(</span> TestResult *result <span>)</span><br><span>{</span><br>  <span>// 遍历vector&lt;Test *&gt;</span><br>  <span>for</span> <span>(</span> std::<span>vector</span>&lt;Test *&gt;::<span>iterator</span> it = m_tests.<span>begin</span><span>(</span><span>)</span>;<br>        it != m_tests.<span>end</span><span>(</span><span>)</span>;<br>        ++it <span>)</span><br>  <span>{</span><br>    <span>// 可能中途终止</span><br>    <span>if</span> <span>(</span> result-&gt;shouldStop<span>(</span><span>)</span> <span>)</span><br>      <span>break</span>;<br>&nbsp;<br>    Test *test = *it;<br>    <span>// 调用每个test自己的run</span><br>    <span>// 可能是TestCase实例，也可能是TestSuite实例，</span><br>    <span>// 后者形成递归，但此处却全然不知</span><br>    test-&gt;run<span>(</span> result <span>)</span>;<br>  <span>}</span><br><span>}</span></pre>  <p>   关于TestResult及其shouldStop方法，稍后会讲到。不过此处的break，到也算是活用 Composite   Pattern的一个简单范例。从效率的角度考虑，当确信不必再执行后续的test时，即可直接返回，而不是照葫芦画瓢，简单的调用一下test的run   方法。  </p>    <p>  既然TestResult派生自Test，那么countTestCases又是如何实现的呢：   </p>  <pre><span>int</span> TestSuite::<span>countTestCases</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>int</span> count = <span>0</span>;<br>&nbsp;<br>  <span>// 遍历vector&lt;Test *&gt;</span><br>  <span>for</span> <span>(</span> std::<span>vector</span>&lt;Test *&gt;::<span>const_iterator</span> it = m_tests.<span>begin</span><span>(</span><span>)</span>;<br>        it != m_tests.<span>end</span><span>(</span><span>)</span>;<br>        ++it <span>)</span><br>    count += <span>(</span>*it<span>)</span>-&gt;countTestCases<span>(</span><span>)</span>;   <span>// 递归调用每个test的countTestCases，并累加</span><br>  <span>return</span> count;<br><span>}</span></pre>  <p>   至于addTest，自然是不能少的，它对应于Composite的Add方法：   </p>  <pre><span>void</span> TestSuite::<span>addTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  m_tests.<span>push_back</span><span>(</span> test <span>)</span>;   <span>// 将test添加到测试对象数组的尾端</span><br><span>}</span></pre>  <p>   不过请注意，addTest方法并未出现于抽象类Test中，关于这类设计上的权衡在GoF中，Composite Pattern一节有专门的论述。  </p>    <p>  TestSuite管理着其下所属诸测试对象的生命周期，在dtor中，它会调用deleteContents方法：   </p>  <pre><span>void</span> TestSuite::<span>deleteContents</span><span>(</span><span>)</span><br><span>{</span><br>  <span>for</span> <span>(</span> std::<span>vector</span>&lt;Test *&gt;::<span>iterator</span> it = m_tests.<span>begin</span><span>(</span><span>)</span>;<br>        it != m_tests.<span>end</span><span>(</span><span>)</span>;<br>        ++it<span>)</span><br>    <span>delete</span> *it;<br>  m_tests.<span>clear</span><span>(</span><span>)</span>;<br><span>}</span></pre>  <p>   此外，TestSuite还为外部访问其所属测试对象提供了接口，因为返回值是const &amp;类型的，所以是read-on<wbr>ly的：   </p>  <pre><span>const</span> std::<span>vector</span>&lt;Test *&gt; &amp;getTests<span>(</span><span>)</span> <span>const</span>;</pre>  </div>  <div><div></div></div>  <h3><a rel="nofollow"   >测试结果记录</a></h3>  <div>    <p>    从这里开始，将要讲述core中，测试结果记录的相关部分。  </p>    <p>  CppUnit是支持多线程的，你可以在一个线程中执行测试，在另一个线程中收集测试结果；或者在不同线程中并行执行多个测试，而用一个线程收集测试结  果。framework中为此提供了简单而必要的支持。    </p>    </div>    <h4><a rel="nofollow"   >SynchronizedObject</a></h4>  <div>    <p>  相关文件：SynchronizedObject.h，SynchronizedObject.cpp  </p>    <p>  SynchronizedObject用来管理一个被同步对象，前面提到的TestResult就是从该类派生的。所谓被同步对象，是指其成员会被多个线  程并发使用。  </p>    <p>  SynchronizedObject定义了一个public属性的abstract inner   class——SynchronizationObject，代表具备同步属性的对象：   </p>  <pre><span>class</span> SynchronizationObject<br><span>{</span><br>  <span>public</span>:<br>    SynchronizationObject<span>(</span><span>)</span> <span>{</span><span>}</span><br>    <span>virtual</span> ~SynchronizationObject<span>(</span><span>)</span> <span>{</span><span>}</span><br>    <span>virtual</span> <span>void</span> lock<span>(</span><span>)</span> <span>{</span><span>}</span><br>    <span>virtual</span> <span>void</span> unlock<span>(</span><span>)</span> <span>{</span><span>}</span><br><span>}</span>;</pre>  <p>     此类定义了互斥锁功能，但具体行为需在其派生类中实现。不同环境下的实现方式想必也不尽相同。随CppUnit源码所附的范例中有个  MfcSynchronizationObject就是SynchronizationObject的子类，它使用了MFC的   CCriticalSection：   </p>  <pre><span>class</span> MfcSynchronizationObject<br>    : <span>public</span> CppUnit::<span>SynchronizedObject</span>::<span>SynchronizationObject</span><br><span>{</span><br>  CCriticalSection m_syncObject;<br><span>public</span>:<br>  <span>void</span> lock<span>(</span><span>)</span><br>  <span>{</span><br>    m_syncObject.<span>Lock</span><span>(</span><span>)</span>;<br>  <span>}</span><br>&nbsp;<br>  <span>void</span> unlock<span>(</span><span>)</span><br>  <span>{</span><br>    m_syncObject.<span>Unlock</span><span>(</span><span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  <p>   SynchronizedObject还定义了一个protected属性的inner   class——ExclusiveZone，作为内部使用的辅助类。它用于在当前作用域内锁定一个SynchronizationObject的实例。其  实现类似于std::auto_ptr，它持有一个指向SynchronizationObject对象的指针，ctor中调用lock，dtor中调用   unlock：   </p>  <pre><span>class</span> ExclusiveZone<br><span>{</span><br>  SynchronizationObject *m_syncObject;<br>&nbsp;<br><span>public</span>:<br>  ExclusiveZone<span>(</span> SynchronizationObject *syncObject <span>)</span><br>      : m_syncObject<span>(</span> syncObject <span>)</span><br>  <span>{</span><br>    m_syncObject-&gt;lock<span>(</span><span>)</span>;<br>  <span>}</span><br>&nbsp;<br>  ~ExclusiveZone<span>(</span><span>)</span><br>  <span>{</span><br>    m_syncObject-&gt;unlock <span>(</span><span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  <p>   除去这些，SynchronizedObject就很简单了。它持有一个指向SynchronizationObject实例的指针：   </p>  <pre>SynchronizationObject *m_syncObject;</pre>  <p>  并管理其生命周期，在dtor中delete之。至于如何传入该指针，则提供了两种方法：   </p>  <pre>SynchronizedObject::<span>SynchronizedObject</span><span>(</span> SynchronizationObject *syncObject <span>)</span><br>    : m_syncObject<span>(</span> syncObject == <span>0</span> ? <span>new</span> SynchronizationObject<span>(</span><span>)</span> : <br>                                                                  syncObject <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br><span>void</span> SynchronizedObject::<span>setSynchronizationObject</span><span>(</span> SynchronizationObject *syncObject <span>)</span><br><span>{</span><br>  <span>delete</span> m_syncObject; <br>  m_syncObject = syncObject;<br><span>}</span></pre>  <p>   在讲述TestResult之前，还有一些障碍要扫清。    </p>    </div>    <h4><a rel="nofollow"   >TestListener</a></h4>  <div>    <p>  相关文件：TestListener.h  </p>    <p>  CppUnit的测试结果记录使用了Observer   Pattern，在GoF中对该pattern有如下描述：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通  知并被自动更新。在测试执行的过程中，当发生错误时，TestResult就会被告知，而后它会将该信息传递给TestListener。因此，   TestResult对应了Observer Pattern中的Subject，而TestListener则对应了Observer。  </p>    <p>  不过TestListener只是一个什么事都没做的基类，像输出测试结果这样事情还得留待派生类来解决，比如outputter部分要提到的  TextTestProgressListener。此外，还是尽量不要使用Listener进行测试结果的输出为好，应该使用outputter中所提  供的专有工具。  </p>    <p>  从TestListener的定义可以看到，在如下三类事件发生时，TestListener将会被通知到   </p>  <ul><li><div> 测试执行之前</div>  </li><li><div> 测试失败</div>  </li><li><div> 测试执行之后 </div>  </li></ul>    <p>   来看一下代码：   </p>  <pre><span>// 在一个测试运行前被调用</span><br><span>virtual</span> <span>void</span> startTest<span>(</span> Test *test <span>)</span> <span>{</span><span>}</span><br>&nbsp;<br><span>// 运行测试失败时被调用</span><br><span>virtual</span> <span>void</span> addFailure<span>(</span> <span>const</span> TestFailure &amp;failure <span>)</span><br>&nbsp;<br><span>// 在一个测试运行后被调用</span><br><span>virtual</span> <span>void</span> endTest<span>(</span> Test *test <span>)</span></pre>  <p>     addFailure中的failure是临时对象，在该方法调用之后即被销毁，和Exception一样（参见TestCase的run函数），也需要  使用其自身提供的clone方法来创建一个副本。有关TestFailure，稍后将会提到。  </p>    <p>  至于endTest，即便测试失败，该函数也会被调用，参见TestCase的run函数。   </p>    </div>    <h4><a rel="nofollow"   >TestResult</a></h4>  <div>    <p>  相关文件：TestResult.h，TestResult.cpp  </p>    <p>  真是千呼万唤始出来啊。TestResult用以收集测试过程中的相关信息，它派生自SynchronizedObject，从而支持多线程。有了前面的  铺垫，对TestResult的理解就变得非常容易了。  </p>    <p>  TestResult维护了一个指向TestListener对象的指针队列：   </p>  <pre><span>protected</span>:<br>  <span>typedef</span> std::<span>deque</span>&lt;TestListener *&gt; TestListeners;<br>  TestListeners m_listeners;<br>&nbsp;<br>为获取到测试相关信息，TestListener需要注册到TestResult中，于是就有了addListener方法：<br>&nbsp;<br><span>void</span> TestResult::<span>addListener</span><span>(</span> TestListener *listener <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;     <span>// ExclusiveZone终于有用武之地了</span><br>  m_listeners.<span>push_back</span><span>(</span> listener <span>)</span>;<br><span>}</span></pre>  <p>   当然还少不了removeListener：   </p>  <pre><span>void</span> TestResult::<span>removeListener</span> <span>(</span> TestListener *listener <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  m_listeners.<span>erase</span><span>(</span> std::<span>remove</span><span>(</span> m_listeners.<span>begin</span><span>(</span><span>)</span>, <br>                        m_listeners.<span>end</span><span>(</span><span>)</span>, <br>                        listener <span>)</span>,<br>                     m_listeners.<span>end</span><span>(</span><span>)</span><span>)</span>;<br><span>}</span></pre>  <p>   我们再来看看TestResult作为Subject的那些Notify方法：   </p>  <pre><span>void</span> TestResult::<span>addError</span><span>(</span> Test *test, Exception *e <span>)</span><br><span>{</span><br>  addFailure<span>(</span> TestFailure<span>(</span> test, e, <span>true</span> <span>)</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>addFailure</span><span>(</span> Test *test, Exception *e <span>)</span><br><span>{</span><br>  addFailure<span>(</span> TestFailure<span>(</span> test, e, <span>false</span> <span>)</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>addFailure</span><span>(</span> <span>const</span> TestFailure &amp;failure <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>// 遍历deque&lt;TestListener *&gt;</span><br>  <span>for</span> <span>(</span> TestListeners::<span>iterator</span> it = m_listeners.<span>begin</span><span>(</span><span>)</span>;<br>      it != m_listeners.<span>end</span><span>(</span><span>)</span>;<br>      ++it <span>)</span><br>    <span>(</span>*it<span>)</span>-&gt;addFailure<span>(</span> failure <span>)</span>;   <span>// 调用TestListener的addFailure</span><br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>startTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>// 遍历deque&lt;TestListener *&gt;</span><br>  <span>for</span> <span>(</span> TestListeners::<span>iterator</span> it = m_listeners.<span>begin</span><span>(</span><span>)</span>;<br>      it != m_listeners.<span>end</span><span>(</span><span>)</span>; <br>      ++it <span>)</span><br>    <span>(</span>*it<span>)</span>-&gt;startTest<span>(</span> test <span>)</span>;   <span>// 调用TestListener的startTest</span><br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>endTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>// 遍历deque&lt;TestListener *&gt;</span><br>  <span>for</span> <span>(</span> TestListeners::<span>iterator</span> it = m_listeners.<span>begin</span><span>(</span><span>)</span>;<br>      it != m_listeners.<span>end</span><span>(</span><span>)</span>;<br>      ++it <span>)</span><br>    <span>(</span>*it<span>)</span>-&gt;endTest<span>(</span> test <span>)</span>;   <span>// 调用TestListener的endTest</span><br><span>}</span></pre>  <p>   此处的注释足以说明问题，至于error和failure的区别，在讲到TestFailure时自然会明了。  </p>    <p>  最后再来看看有关shouldStop的代码，该函数曾在TestSuite的run中出现过：   </p>  <pre>TestResult::<span>TestResult</span><span>(</span> SynchronizationObject *syncObject <span>)</span><br>    : SynchronizedObject<span>(</span> syncObject <span>)</span><br><span>{</span><br>  reset<span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>reset</span><span>(</span><span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  m_stop = <span>false</span>;<br><span>}</span><br>&nbsp;<br><span>bool</span> TestResult::<span>shouldStop</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>return</span> m_stop;<br><span>}</span><br>&nbsp;<br><span>void</span> TestResult::<span>stop</span><span>(</span><span>)</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  m_stop = <span>true</span>;<br><span>}</span></pre>  <p>   没有什么特别的，只是一个m_stop在掌控着一切，而m_stop则是TestResult的一个protected属性的成员变量：   </p>  <pre><span>bool</span> m_stop;</pre>  </div>  <div><div></div></div>  <h3><a rel="nofollow"   >错误处理</a></h3>  <div>    </div>    <h4><a rel="nofollow"   >TestFailure</a></h4>  <div>    <p>  相关文件：TestFailure.h，TestFailure.cpp  </p>    <p>  CppUnit中有两种类型的错误，它们分别是：failure和error。一个failure是可预期的，并可以为断言（assert）所侦测到；而  error则是不可预期的，由异常标示，它并非框架代码所产生。  </p>    <p>  CppUnit使用TestFailure这一个类同时表示failure和error，请看TestFailure的成员变量定义：   </p>  <pre><span>protected</span>:<br>  <span>// 指向失败的测试对象</span><br>  Test *m_failedTest;<br>  <span>// 指向异常对象（如果有）</span><br>  Exception *m_thrownException;<br>  <span>// 区分failure和error的标记</span><br>  <span>bool</span> m_isError;</pre>  <p>   再来看相关代码：   </p>  <pre><span>// 依据failedTest和thrownException，构建一个TestFailure</span><br>TestFailure::<span>TestFailure</span><span>(</span> Test *failedTest, <br>        Exception *thrownException,<br>        <span>bool</span> isError <span>)</span> :<br>    m_failedTest<span>(</span> failedTest <span>)</span>, <br>    m_thrownException<span>(</span> thrownException <span>)</span>,<br>    m_isError<span>(</span> isError <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br><span>// 返回m_isError，判断是否error的函数</span><br><span>bool</span> TestFailure::<span>isError</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_isError;<br><span>}</span></pre>  <p>   另外，再来看看有关clone的代码，十分简单：   </p>  <pre>TestFailure *TestFailure::<span>clone</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>// 创建一个和自身一模一样的实例后返回其指针</span><br>  <span>return</span> <span>new</span> TestFailure<span>(</span> m_failedTest, m_thrownException-&gt;clone<span>(</span><span>)</span>, m_isError <span>)</span>;<br><span>}</span></pre>  <p>   除了m_isError之外，TestFailure也为另两个成员变量提供了外界访问的接口：   </p>  <pre>std::<span>string</span> TestFailure::<span>failedTestName</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_failedTest-&gt;getName<span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br>Exception *TestFailure::<span>thrownException</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_thrownException;<br><span>}</span></pre>  <p>   最后，对于执行失败的测试，TestFailure还记录了其错误所在位置，包括源文件路径和文件内的行号，通过如下接口可以访问到：   </p>  <pre>SourceLine TestFailure::<span>sourceLine</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_thrownException-&gt;sourceLine<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>   可以看到，TestFailure调用了Exception的sourceLine方法。为使外部方便的引用   SourceLine，选择增加自身接口（sourceLine方法），而接口实现仅仅是简单的delegate，这种设计权衡在很多地方都是经常用到  的。关于SourceLine的具体实现，随后就会讲到。   </p>    </div>    <h4><a rel="nofollow"   >SourceLine</a></h4>  <div>    <p>  相关文件：SourceLine.h，SourceLine.cpp  </p>    <p>  记录了有关某个失败测试的错误所在位置，包括源文件路径和文件内的行号。有了它，我们就可以准确定位导致测试失败的原因了。在和Asserter相关的一  些宏中将会用到该类，Exception中也引用了该类。  </p>    <p>  SourceLine中有两个成员变量，分别对应源文件路径和文件内的行号：   </p>  <pre><span>private</span>:<br>  std::<span>string</span> m_fileName;<br>  <span>int</span> m_lineNumber;</pre>  <p>   除了为这两个成员变量提供外界访问的接口外，SourceLine还重载了operator==和operator!=：   </p>  <pre><span>int</span> SourceLine::<span>lineNumber</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_lineNumber;<br><span>}</span><br>&nbsp;<br>std::<span>string</span> SourceLine::<span>fileName</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_fileName;<br><span>}</span><br>&nbsp;<br><span>bool</span> SourceLine::<span>operator</span> ==<span>(</span> <span>const</span> SourceLine &amp;other <span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> m_fileName == other.<span>m_fileName</span>  &amp;&amp;<br>          m_lineNumber == other.<span>m_lineNumber</span>;<br><span>}</span><br>&nbsp;<br><span>bool</span> SourceLine::<span>operator</span> !=<span>(</span> <span>const</span> SourceLine &amp;other <span>)</span> <span>const</span><br><span>{</span><br>  <span>// 调用operator==，即保证了语义的正确，又避免了代码重复</span><br>  <span>// 此类做法是库设计中经常用到的，在STL源码中随处可见</span><br>  <span>return</span> !<span>(</span> *<span>this</span> == other <span>)</span>;<br><span>}</span></pre>  <p>     可以看出，SourceLine只是简单的包装了错误位置这一信息，至于该信息的设定还需外界决定，那么如何才能记录下源文件中错误所在的位置  呢，SourceLine中还有一个宏，全部的秘密都在这里：   </p>  <pre><span>#define CPPUNIT_SOURCELINE() ::CppUnit::SourceLine( __FILE__, __LINE__ )</span></pre>  <p>     在需要处调用该宏，比如某个断言，一个SourceLine对象即被构造，m_fileName和m_lineNumber便被初始化为宏展开处的位置信  息。在讲到TestAssert时，你将会看到，这些工作都无需你操心了，因为framework已经安排好一切了。   </p>    </div>    <h4><a rel="nofollow"   >Exception</a></h4>  <div>    <p>  相关文件：Exception.h，Exception.cpp  </p>    <p>  这就是前面多次提到过的异常。它派生自std::exception，调用其what方法可以得到有关本次异常的描述信息，在某个断言失败时会抛出异常。  </p>    <p>  Exception中有一个标识异常类型的inner   class——Type，它具有public属性，内部仅有一个常量成员变量m_Type，代表具体类型。唯一的ctor在初始化成员列表中为  m_type赋值，此外还有一个operator==函数：   </p>  <pre><span>class</span> Type<br><span>{</span><br><span>public</span>:<br>  Type<span>(</span> std::<span>string</span> type <span>)</span> : m_type <span>(</span> type <span>)</span> <span>{</span><span>}</span><br>&nbsp;<br>  <span>bool</span> operator ==<span>(</span> <span>const</span> Type &amp;other <span>)</span> <span>const</span><br>  <span>{</span><br>    <span>return</span> m_type == other.<span>m_type</span>;<br>  <span>}</span><br>&nbsp;<br><span>private</span>:<br>  <span>const</span> std::<span>string</span> m_type;<br><span>}</span>;</pre>  <p>   将类型信息用类来封装，应该是典型的OO风格了，这在refactoring一书中被称为“Replace Type Co<wbr>de with   Class”技法，另外，读者还可以在该书中找到其它几项相关内容：Replace Conditional with   Polymorphism，Replace Type Co<wbr>de with Subclasses，Replace Type Co<wbr>de with   State/Strategy，Replace Da<wbr>ta Value with Object。  </p>    <p>  与Type相关的两个函数是type和isInstanceOf：   </p>  <pre><span>// 返回Exception的类型</span><br>Exception::<span>Type</span> Exception::<span>type</span><span>(</span><span>)</span><br><span>{</span><br>  <span>return</span> Type<span>(</span> <span>"CppUnit::Exception"</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>// 判断exceptionType是否是“CppUnit::Exception”</span><br><span>bool</span> Exception::<span>isInstanceOf</span><span>(</span> <span>const</span> Type &amp;exceptionType <span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> exceptionType == type<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>   isInstanceOf实现了一个简单的运行期类型检查，类似于MFC中的IsKindOf。在Exception的派生类中还将见到它。  </p>    <p>  Exception有两个私有成员变量：   </p>  <pre><span>private</span>:<br>  std::<span>string</span> m_message;     <span>// 与本次异常相关的描述信息</span><br>  SourceLine m_sourceLine;   <span>// 异常发生的具体位置</span></pre>  <p>   查看Exception的ctor发现有两个不同版本：   </p>  <pre>Exception<span>(</span> std::<span>string</span>  message = <span>""</span>, <br>        SourceLine sourceLine = SourceLine<span>(</span><span>)</span> <span>)</span>;<br>&nbsp;<br><span>#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED</span><br>Exception<span>(</span> std::<span>string</span>  message, <span>long</span> lineNumber, std::<span>string</span> fileName <span>)</span>;<br><span>#endif</span></pre>  <p>     关于这个CPPUNIT_ENABLE_SOURCELINE_DEPRECATED的来历，在随CppUnit所附的ChangeLog中有过“记  载”。早先版本的CppUnit中，Exception并未引用SourceLine类（也就是说没有第一个ctor，当时SourceLine还没“出  世”呢），而是代之以fileName和lineNumber这两个成员变量，这一点从第二个ctor的声明中也能看出来。在随后的一次  refactoring过程中，这两个可怜的家伙被“Introduce Parameter   Object”消灭掉了，于是SourceLine取而代之。但是，作为一个发布了的framework，需要考虑到兼容问题，因此以前的接口必须保留，  所以第二个ctor仍然存在，只是其内部实现已偷梁换柱了：   </p>  <pre>Exception::<span>Exception</span><span>(</span> std::<span>string</span> message, <span>long</span> lineNumber, std::<span>string</span> fileName <span>)</span> : <br>    m_message<span>(</span> message <span>)</span>, <br>    m_sourceLine<span>(</span> fileName, lineNumber <span>)</span>  <span>// 仍然转交给SourceLine</span><br><span>{</span><span>}</span></pre>  <p>     既然是“DEPRECATED”，那么这样的接口当然是不推荐使用的，在Exception源码中还有多处与此有关，这里就不多说了。总之，缺省情况下  CPPUNIT_ENABLE_SOURCELINE_DEPRECATED没有被定义，因此被#ifdef   CPPUNIT_ENABLE_SOURCELINE_DEPRECATED……#endif所包围的代码大可不必关心。不过，像这类“历史遗留”问题，  想必很多库设计中都会遇到。  </p>    <p>  还有几个函数，代码如下：   </p>  <pre><span>const</span> <span>char</span>* Exception::<span>what</span><span>(</span><span>)</span> <span>const</span> throw<span>(</span><span>)</span><br><span>{</span><br>  <span>return</span> m_message.<span>c_str</span> <span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br>Exception *Exception::<span>clone</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> <span>new</span> Exception<span>(</span> *<span>this</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br>Exception::<span>operator</span> =<span>(</span> <span>const</span> Exception&amp; other <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> &amp;other != <span>this</span> <span>)</span><br>  <span>{</span><br>    m_message = other.<span>m_message</span>;<br>    m_sourceLine = other.<span>m_sourceLine</span>;<br>  <span>}</span><br>  <span>return</span> *<span>this</span>;<br><span>}</span></pre>  </div>    <h4><a rel="nofollow"   >NotEqualException</a></h4>  <div>    <p>  相关文件：NotEqualException.h，NotEqualException.cpp  </p>    <p>  派生自Exception，当判断相等的断言失败时会抛出该异常。和基类相比，多了三个private成员变量：  </p>  <pre><span>private</span>:<br>  std::<span>string</span> m_expected;    <span>// 预期值</span><br>  std::<span>string</span> m_actual;          <span>// 实际值，是否仅支持字符串比较呢，稍后再做讲解</span><br>  std::<span>string</span> m_additionalMessage;     <span>// 附加信息</span></pre>  <p>   NotEqualException还覆盖了基类的type、isInstanceOf、clone、operator=这几个函数：  </p>  <pre><span>// 返回NotEqualException类型</span><br>Exception::<span>Type</span> NotEqualException::<span>type</span><span>(</span><span>)</span><br><span>{</span><br>  <span>return</span> Type<span>(</span> <span>"CppUnit::NotEqualException"</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>// 调用了基类的isInstanceOf，因此若传入的值为Exception的Type，</span><br><span>// 返回亦为true，这一点与常理相符</span><br><span>bool</span> NotEqualException::<span>isInstanceOf</span><span>(</span> <span>const</span> Type &amp;exceptionType <span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> exceptionType == type<span>(</span><span>)</span>  ||<br>          Exception::<span>isInstanceOf</span><span>(</span> exceptionType <span>)</span>;<br><span>}</span><br>&nbsp;<br>Exception *NotEqualException::<span>clone</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>return</span> <span>new</span> NotEqualException<span>(</span> *<span>this</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br>NotEqualException &amp;<br>NotEqualException::<span>operator</span> =<span>(</span> <span>const</span> NotEqualException &amp;other <span>)</span><br><span>{</span><br>  Exception::<span>operator</span> =<span>(</span> other <span>)</span>;     <span>// 切勿忘记调用基类的operator=</span><br>&nbsp;<br>  <span>if</span> <span>(</span> &amp;other != <span>this</span> <span>)</span><br>  <span>{</span><br>    m_expected = other.<span>m_expected</span>;<br>    m_actual = other.<span>m_actual</span>;<br>    m_additionalMessage = other.<span>m_additionalMessage</span>;<br>  <span>}</span><br>  <span>return</span> *<span>this</span>;<br><span>}</span></pre>  </div>  <div><div></div></div>  <h3><a rel="nofollow"   >断言</a></h3>  <div>    <p>  从这里开始，将要讲述core中，与断言相关的部分。  </p>    </div>    <h4><a rel="nofollow"   >Asserter</a></h4>  <div>    <p>  相关文件：Asserter.h，Asserter.cpp  </p>    <p>  Asserter并非类名，而是一个name space，它内嵌于CppUnit name   space之中。该域中一共有四个函数，用来帮助编写和断言有关的宏，它们分别  是：fail，failIf，failNotEqual，failNotEqualIf。  </p>    <p>  函数fail仅抛出一个Exception对象，里面包含了和产生的错误相关的信息：   </p>  <pre><span>void</span> fail<span>(</span> std::<span>string</span> message, SourceLine sourceLine <span>)</span><br><span>{</span><br>  throw Exception<span>(</span> message, sourceLine <span>)</span>;<br><span>}</span></pre>  <p>   函数failIf加上了条件控制，仅当shouldFail为true时才抛异常（调用fail函数）：   </p>  <pre><span>void</span> failIf<span>(</span> <span>bool</span> shouldFail, std::<span>string</span> message, SourceLine location <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> shouldFail <span>)</span><br>    fail<span>(</span> message, location <span>)</span>;<br><span>}</span></pre>  <p>  类似的，函数failNotEqual抛出NotEqualException对象，表明expected字串和actual字串不相  等，NotEqualException对象包含了和产生的错误相关的信息：   </p>  <pre><span>void</span> failNotEqual<span>(</span> std::<span>string</span> expected, std::<span>string</span> actual, <br>        SourceLine sourceLine, std::<span>string</span> additionalMessage <span>)</span><br><span>{</span><br>  throw NotEqualException<span>(</span> expected, actual, sourceLine, additionalMessage <span>)</span>;<br><span>}</span></pre>  <p>   而函数failNotEqualIf则加上了条件控制：   </p>  <pre><span>void</span> failNotEqualIf<span>(</span> <span>bool</span> shouldFail, std::<span>string</span> expected, std::<span>string</span> actual, <br>        SourceLine sourceLine, std::<span>string</span> additionalMessage <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> shouldFail <span>)</span><br>    failNotEqual<span>(</span> expected, actual, sourceLine, additionalMessage <span>)</span>;<br><span>}</span></pre>  <p>   下面的例子演示了如何使用上面提供的函数编写与断言相关的宏，这个例子选自随CppUnit源码所附的范例中：   </p>  <pre><span>#include &lt;cppunit/SourceLine.h&gt;</span><br><span>#include &lt;cppunit/TestAssert.h&gt;</span><br>&nbsp;<br><span>// 检查XML字串是否与预期值相等</span><br><span>void</span>  checkXmlEqual<span>(</span> std::<span>string</span> expectedXml, <br>        std::<span>string</span> actualXml, <br>        CppUnit::<span>SourceLine</span> sourceLine <span>)</span><br><span>{</span><br>  <span>// 预期之XML字串</span><br>  std::<span>string</span> expected = XmlUniformiser<span>(</span> expectedXml <span>)</span>.<span>stripped</span><span>(</span><span>)</span>;<br>  <span>// 实际之XML字串</span><br>  std::<span>string</span> actual = XmlUniformiser<span>(</span> actualXml <span>)</span>.<span>stripped</span><span>(</span><span>)</span>;<br>&nbsp;<br>  <span>if</span> <span>(</span> expected == actual <span>)</span>    <span>// 实际值和预期值相符，则相安无事</span><br>    <span>return</span>;<br>&nbsp;<br>  <span>// 不符，则报之以异常</span><br>  ::<span>CppUnit</span>::<span>Asserter</span>::<span>failNotEqual</span><span>(</span> expected, actual, sourceLine <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>/// 断言：两个XML字串相等</span><br><span>#define CPPUNITTEST_ASSERT_XML_EQUAL( expected, actual ) \</span><br>        checkXmlEqual<span>(</span> expected, actual, CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span></pre>  </div>    <h4><a rel="nofollow"   >TestAssert</a></h4>  <div>    <p>  相关文件：TestAssert.h，TestAssert.cpp  </p>    <p>  TestAssert并非类名，而是一个name space，它内嵌于CppUnit name   space之中。该域中也有CPPUNIT_ENABLE_SOURCELINE_DEPRECATED的痕迹，去除与之相关的代码，剩下两个函数：   assertEquals和assertDoubleEquals，其余均是宏。  </p>    <p>  assertEauals为模板函数，其大致功能类似前面的checkXmlEqual函数，若实际值和预期值不相符，则调用  Asserter::failNotEqual，来看一下代码：   </p>  <pre><span>template</span> &lt;class T&gt;<br><span>void</span> assertEquals<span>(</span> <span>const</span> T&amp; expected, <span>const</span> T&amp; actual, <br>        SourceLine sourceLine, <span>const</span> std::<span>string</span> &amp;message =<span>""</span> <span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> !assertion_traits&lt;T&gt;::<span>equal</span><span>(</span>expected,actual<span>)</span> <span>)</span><br>  <span>{</span><br>    <span>// 在需要时才调用toString，此之谓“lazy toString conversion”</span><br>    Asserter::<span>failNotEqual</span><span>(</span> assertion_traits&lt;T&gt;::<span>toString</span><span>(</span>expected<span>)</span>, <br>            assertion_traits&lt;T&gt;::<span>toString</span><span>(</span>actual<span>)</span>, <br>            sourceLine, <br>            message <span>)</span>;<br>  <span>}</span><br><span>}</span></pre>  <p>     之所以采用模板是为了使之支持多种类型，但是assertion_traits&lt;T&gt;::equal又是何方神圣呢。看到这个traits，  想必大家一定会想到在泛型编程中大名鼎鼎的特性萃取技法。不错，这就是traits技法在此处的一个小小的应用。   assertion_traits的定义和TestAssert同在一个文件中：   </p>  <pre><span>template</span> &lt;class T&gt;<br><span>struct</span> assertion_traits<br><span>{</span><br>  <span>static</span> <span>bool</span> equal<span>(</span> <span>const</span> T&amp; x, <span>const</span> T&amp; y <span>)</span><br>  <span>{</span><br>    <span>return</span> x == y;<br>  <span>}</span><br>&nbsp;<br>  <span>static</span> std::<span>string</span> toString<span>(</span> <span>const</span> T&amp; x <span>)</span><br>  <span>{</span><br>    OStringStream ost;<br>    ost &lt;&lt; x;<br>    <span>return</span> ost.<span>str</span><span>(</span><span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  <p>     assertion_traits的功能就是从T中萃取与断言相关的两个特征：equal和toString，上面提供的是泛化版本，根据需要你还可以定  义特化版本，比如专门为std::string定制的代码如下：   </p>  <pre>template&lt;&gt;<br><span>struct</span> assertion_traits&lt;std::<span>string</span>&gt;<br><span>{</span><br>  <span>static</span> <span>bool</span> equal<span>(</span> <span>const</span> std::<span>string</span>&amp; x, <span>const</span> std::<span>string</span>&amp; y <span>)</span><br>  <span>{</span><br>    <span>return</span> x == y;<br>  <span>}</span><br>&nbsp;<br>  <span>static</span> std::<span>string</span> toString<span>(</span> <span>const</span> std::<span>string</span>&amp; x <span>)</span><br>  <span>{</span><br>    std::<span>string</span> text = <span>'"'</span> + x + <span>'"'</span>;    <span>// 两边加上引号以留空</span><br>    OStringStream ost;<br>    ost &lt;&lt; text;<br>    <span>return</span> ost.<span>str</span><span>(</span><span>)</span>;<br>  <span>}</span><br><span>}</span>;</pre>  <p>   assertEquals中利用assertion_traits&lt;T&gt;::equal判断   expected与actual是否相等，若不等则调用Asserter::failNotEqual函数。到此，对于   NotEqualException中仅对字串作比较的疑问，相信读者已经明白缘由了。有了assertion_traits&lt;T&gt;::   toString，不管什么类型，一个string版的NotEqualException足以应对。  </p>    <p>  理解了assertEquals之后，再来看assertDoubleEquals函数就十分简单了，该函数用于作模糊相等判断，针对的是double类  型的数据：   </p>  <pre><span>void</span> TestAssert::<span>assertDoubleEquals</span><span>(</span> <span>double</span> expected,<br>        <span>double</span> actual,<br>        <span>double</span> delta,<br>        SourceLine sourceLine <span>)</span><br><span>{</span><br>  Asserter::<span>failNotEqualIf</span><span>(</span> <span>fabs</span><span>(</span> expected - actual <span>)</span> &gt; delta,<br>    assertion_traits&lt;double&gt;::<span>toString</span><span>(</span>expected<span>)</span>,<br>    assertion_traits&lt;double&gt;::<span>toString</span><span>(</span>actual<span>)</span>,<br>    sourceLine <span>)</span>;<br><span>}</span></pre>  <p>     当expected和actual的差值的绝对值大于限值delta，则调用Asserter::failNotEqualIf，此处再次使用了  assertion_traits&lt;T&gt;::toString，T以double代之。  </p>    <p>  好了，现在万事俱备，有了这些工具，就可以编写与断言相关的宏了，正如前面的checkXmlEqual函数。用这些宏，我们可以得到错误发生的文件物理  位置和行号：   </p>  <pre><span>#if CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION</span><br><span>// 断言条件condition为真</span><br><span>#define CPPUNIT_ASSERT(condition)                          \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>Asserter</span>::<span>failIf</span><span>(</span> !<span>(</span>condition<span>)</span>,             \<br>        <span>(</span><span>#condition),             \</span><br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span><br><span>#else</span><br><span>#define CPPUNIT_ASSERT(condition)                          \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>Asserter</span>::<span>failIf</span><span>(</span> !<span>(</span>condition<span>)</span>,             \<br>        <span>""</span>,                       \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span><br><span>#endif</span><br>&nbsp;<br><span>// 断言条件condition为真，若为假，message中指明了诊断信息</span><br><span>#define CPPUNIT_ASSERT_MESSAGE(message,condition)          \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>Asserter</span>::<span>failIf</span><span>(</span> !<span>(</span>condition<span>)</span>,             \<br>        <span>(</span>message<span>)</span>,                \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span><br>&nbsp;<br><span>// 表示失败，message中指明了诊断信息</span><br><span>#define CPPUNIT_FAIL( message )                            \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>Asserter</span>::<span>fail</span><span>(</span> message,                    \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span><br>&nbsp;<br><span>// 断言两个值相等，若不相等，则会打印诊断信息</span><br><span>#define CPPUNIT_ASSERT_EQUAL(expected,actual)                     \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>TestAssert</span>::<span>assertEquals</span><span>(</span> <span>(</span>expected<span>)</span>,              \<br>        <span>(</span>actual<span>)</span>,                \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span><br>&nbsp;<br><span>// 断言两个值相等，message中指明了附加的诊断信息</span><br><span>#define CPPUNIT_ASSERT_EQUAL_MESSAGE(message,expected,actual)     \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>TestAssert</span>::<span>assertEquals</span><span>(</span> <span>(</span>expected<span>)</span>,              \<br>        <span>(</span>actual<span>)</span>,                \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span>,    \<br>        <span>(</span>message<span>)</span> <span>)</span> <span>)</span><br>&nbsp;<br><span>// 断言两个值不精确相等</span><br><span>#define CPPUNIT_ASSERT_DOUBLES_EQUAL(expected,actual,delta)       \</span><br>  <span>(</span> ::<span>CppUnit</span>::<span>TestAssert</span>::<span>assertDoubleEquals</span><span>(</span> <span>(</span>expected<span>)</span>,        \<br>        <span>(</span>actual<span>)</span>,          \<br>        <span>(</span>delta<span>)</span>,           \<br>        CPPUNIT_SOURCELINE<span>(</span><span>)</span> <span>)</span> <span>)</span></pre>  <p>     关于CPPUNIT_ASSERT_EQUAL还有一点要说明，该宏对于expected和actual是有要求的，也就是所谓的  Requirement：   </p>  <ul><li><div> 具有相同的类型（比如都是std::string）</div>  </li><li><div>   可以使用?序列化到std::strstream（assertion_traits&lt;T&gt;::toString中指明）</div>  </li><li><div>   能用==作比较（assertion_traits&lt;T&gt;::equal中指明） </div>  </li></ul>    <p>   不过，后两条可以通过为assertion_traits定制特化版本去除掉。  </p>    <p>  最后，TestAssert还定义了与上述宏功能相当的另一组宏，依据ChangeLog的描述，这又是“历史遗留”问题：为了与早先版本兼容，即早先使  用的是如下这组宏。若你仍需使用这些宏，只要在所有CppUnit包含文件之前将宏   CPPUNIT_ENABLE_NAKED_ASSERT定义为1即可：   </p>  <pre><span>#if CPPUNIT_ENABLE_NAKED_ASSERT</span><br>&nbsp;<br><span>#undef assert</span><br><span>#define assert(c)                 CPPUNIT_ASSERT(c)</span><br><span>#define assertEqual(e,a)          CPPUNIT_ASSERT_EQUAL(e,a)</span><br><span>#define assertDoublesEqual(e,a,d) CPPUNIT_ASSERT_DOUBLES_EQUAL(e,a,d)</span><br><span>#define assertLongsEqual(e,a)     CPPUNIT_ASSERT_EQUAL(e,a)</span><br>&nbsp;<br><span>#endif</span></pre>  </div>  <div><div></div></div>  <h2><a rel="nofollow"   >输出部分（Output）</a></h2>  <div>    <p>  这一部分主要提供了一些用于输出测试结果的工具类，输出的方式可以有多种，比如：以纯文本方式输出，以XML标记语言方式输出，基于IDE开发环境的输出  等。由此足见，CppUnit的实现者想得还是很周到的。   </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >基础部件</a></h3>  <div>    </div>    <h4><a rel="nofollow"   >Outputter</a></h4>  <div>    <p>  相关文件：Outputter.h  </p>    <p>  这是一系列测试结果输出类的抽象基类，只有寥寥几行代码，唯一的作用是定义了一个write操作和一个virtual dtor：  </p>  <pre><span>virtual</span> ~Outputter<span>(</span><span>)</span> <span>{</span><span>}</span><br><span>virtual</span> <span>void</span> write<span>(</span><span>)</span> =<span>0</span>;</pre>  <p>  由于各种输出方式，其具体实现大相径庭，所以Outputter所能做的也止于此了。   </p>    </div>    <h4><a rel="nofollow"   >TestResultCollector</a></h4>  <div>    <p>  相关文件：TestResultCollector.h，TestResultCollector.cpp  </p>    <p>  该类派生自TestSucessListener，同样也是TestListener和   SynchronizedObject，因为前者派生自后二者。关于TestSucessListener请见listener部分，关于   TestListener请见core部分。TestResultCollector的作用是搜集正在执行的测试用例的结果。依源码中的   documentation comments所述，这是Collecting Parameter   Pattern的一个应用[该Pattern在GoF中没有提及，morning有些孤陋寡闻]  </p>    <p>  TestSucessListene定义了三个成员变量，用来记录测试相关信息：   </p>  <pre>std::<span>deque</span>&lt;Test *&gt; m_tests;            <span>// 指针队列用以记录测试对象</span><br>std::<span>deque</span>&lt;TestFailure *&gt; m_failures;  <span>// 指针队列用以记录测试失败信息</span><br><span>int</span> m_testErrors;                      <span>// 用以记录测试错误个数</span></pre>  <p>   TestSucessListene还覆盖了基类TestListener的startTest，reset和addFailure方法：   </p>  <pre><span>void</span> TestResultCollector::<span>startTest</span><span>(</span> Test *test <span>)</span><br><span>{</span><br>  ExclusiveZone zone <span>(</span>m_syncObject<span>)</span>; <br>  m_tests.<span>push_back</span><span>(</span> test <span>)</span>;               <span>// 将测试对象加入链表中</span><br><span>}</span><br>&nbsp;<br><span>void</span> TestResultCollector::<span>reset</span><span>(</span><span>)</span><br><span>{</span><br>  TestSucessListener::<span>reset</span><span>(</span><span>)</span>;<br>&nbsp;<br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>; <br>  m_testErrors = <span>0</span>;<br>  m_tests.<span>clear</span><span>(</span><span>)</span>;<br>  m_failures.<span>clear</span><span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> TestResultCollector::<span>addFailure</span><span>(</span> <span>const</span> TestFailure &amp;failure <span>)</span><br><span>{</span><br>  TestSucessListener::<span>addFailure</span><span>(</span> failure <span>)</span>;<br>&nbsp;<br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>; <br>  <span>if</span> <span>(</span> failure.<span>isError</span><span>(</span><span>)</span> <span>)</span>                   <span>// 若failure实为error，则m_testErrors加1</span><br>    ++m_testErrors;<br>  m_failures.<span>push_back</span><span>(</span> failure.<span>clone</span><span>(</span><span>)</span> <span>)</span>;   <span>// 此处用了clone</span><br><span>}</span></pre>  <p>     这里使用了ExclusiveZone，关于failure和error的差别，以及clone方法，请见core部分。由于使用了clone方法，所以  在addFailure中创建的failure需要在dtor中回收：   </p>  <pre>TestResultCollector::~TestResultCollector()<br>{<br>  TestFailures::iterator itFailure = m_failures.begin();<br>  while ( itFailure != m_failures.end() )<br>    delete *itFailure++;<br>}<br></pre>    <p>   此外，就是几个getter方法了：   </p>  <pre><span>// 获取运行的测试个数</span><br><span>int</span> TestResultCollector::<span>runTests</span><span>(</span><span>)</span> <span>const</span><br><span>{</span> <br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>; <br>  <span>return</span> m_tests.<span>size</span><span>(</span><span>)</span>; <br><span>}</span><br>&nbsp;<br><span>// 获取运行错误的测试个数</span><br><span>int</span> TestResultCollector::<span>testErrors</span><span>(</span><span>)</span> <span>const</span><br><span>{</span> <br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>return</span> m_testErrors;<br><span>}</span><br>&nbsp;<br><span>// 获取运行失败的测试个数</span><br><span>int</span> TestResultCollector::<span>testFailures</span><span>(</span><span>)</span> <span>const</span><br><span>{</span> <br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>; <br>  <span>return</span> m_failures.<span>size</span><span>(</span><span>)</span> - m_testErrors;<br><span>}</span><br>&nbsp;<br><span>// 获取运行错误及失败的测试的总个数</span><br><span>int</span> TestResultCollector::<span>testFailuresTotal</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>; <br>  <span>return</span> m_failures.<span>size</span><span>(</span><span>)</span>;<br><span>}</span><br>&nbsp;<br><span>// 获取记录测试失败的链表</span><br><span>const</span> TestResultCollector::<span>TestFailures</span> &amp; <br>TestResultCollector::<span>failures</span><span>(</span><span>)</span> <span>const</span><br><span>{</span> <br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>return</span> m_failures; <br><span>}</span><br>&nbsp;<br><span>// 获取记录测试对象的链表</span><br><span>const</span> TestResultCollector::<span>Tests</span> &amp;<br>TestResultCollector::<span>tests</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  ExclusiveZone zone<span>(</span> m_syncObject <span>)</span>;<br>  <span>return</span> m_tests;<br><span>}</span></pre>  <p>     这里还想提一下有关TestResult和TestResultCollector的区别。根据随CppUnit所附的ChangeLog中的“记载”，  早先版本的CppUnit中只有TestResult，它所实现的功能和TestResultCollector完全一样，像failures、  testFailuresTotal等方法，原来都是在TestResult中的。不过在随后的refactoring过程中，由于引入了  Observer   Pattern，TestResultCollector应运而生，TestResult成了Subject，其原有记录测试运行结果的责任被移交给了   TestResultCollector，而后者则是一个地道的Listener。于是原来在TestResult中出现的那些方法在Extract   Method的“协助”之下被转移到了TestResultCollector中。   </p>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >衍生类</a></h3>  <div>    </div>    <h4><a rel="nofollow"   >TextOutputter</a></h4>  <div>    <p>  相关文件：TextOutputter.h，TextOutputter.cpp  </p>    <p>  Outputter的派生类，以纯文本格式输出TestResultCollector中的内容。通过ctor将所要输出的  TestResultCollector对象以及输出设备对象传入其中：   </p>  <pre>TextOutputter::<span>TextOutputter</span><span>(</span> TestResultCollector *result,<br>                              std::<span>ostream</span> &amp;stream <span>)</span><br>    : m_result<span>(</span> result <span>)</span><br>    , m_stream<span>(</span> stream <span>)</span><br><span>{</span><br><span>}</span></pre>  <p>   还覆盖了基类Outputter的write方法：   </p>  <pre><span>void</span> TextOutputter::<span>write</span><span>(</span><span>)</span> <br><span>{</span><br>  printHeader<span>(</span><span>)</span>;<br>  m_stream &lt;&lt; std::<span>endl</span>;<br>  printFailures<span>(</span><span>)</span>;<br>  m_stream &lt;&lt; std::<span>endl</span>;<br><span>}</span></pre>  <p>     至于pringHeader，printFailures以及其他辅助函数的具体实现，此处不再叙述，这些内容多半是复杂的格式化输出，感兴趣的读者可以  查看源码。   </p>    </div>    <h4><a rel="nofollow"   >CompilerOutputter</a></h4>  <div>    <p>  相关文件：CompilerOutputter.h，CompilerOutputter.cpp  </p>    <p>  Outputter的又一个派生类，功能类似于TextOutputter，以编译器兼容方式（compiler   compatible）输出TestResultCollector中的内容，以使你在IDE环境下可以跳转至相应的assertion   failure。这就好像在IDE环境下编译程序产生了错误，而你可以在错误结果输出窗口中点击错误所在行跳转至对应的源码处。   CompilerOutputter会在编译期间的末尾运行测试，在IDE的监视窗口中提供反馈结果，并且同样具有跳转至对应源码处的功能。  </p>    <p>  来看看CompilerOutputter到底有何神奇之处，能有如此非凡功能。  </p>    <p>  与TextOutputter类似，通过ctor将所要输出的TestResultCollector对象以及输出设备对象传入其中：   </p>  <pre>CompilerOutputter::<span>CompilerOutputter</span><span>(</span> TestResultCollector *result,<br>                                      std::<span>ostream</span> &amp;stream <span>)</span> :<br>    m_result<span>(</span> result <span>)</span>,<br>    m_stream<span>(</span> stream <span>)</span><br><span>{</span><br><span>}</span></pre>  <p>   同样也覆盖了基类Outputter的write方法：   </p>  <pre><span>void</span> CompilerOutputter::<span>write</span><span>(</span><span>)</span><br><span>{</span><br>  <span>if</span> <span>(</span> m_result-&gt;wasSuccessful<span>(</span><span>)</span> <span>)</span><br>    printSucess<span>(</span><span>)</span>;<br>  <span>else</span><br>    printFailureReport<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>     然后是一些以print打头的格式化输出函数，此处不再鏊述。略有不同的是，多了一个splitMessageIntoLines函数和一个wrap函  数。splitMessageIntoLines用于将一个字符串按行（即以“\n”为界）拆成一个字符串数组：   </p>  <pre>CompilerOutputter::<span>Lines</span> <br>CompilerOutputter::<span>splitMessageIntoLines</span><span>(</span> std::<span>string</span> message <span>)</span><br><span>{</span><br>  Lines lines;<br>&nbsp;<br>  std::<span>string</span>::<span>iterator</span> itStart = message.<span>begin</span><span>(</span><span>)</span>;<br>  <span>while</span> <span>(</span> <span>true</span> <span>)</span><br>  <span>{</span><br>    std::<span>string</span>::<span>iterator</span> itEol = std::<span>find</span><span>(</span> itStart, <br>                                             message.<span>end</span><span>(</span><span>)</span>, <br>                                             <span>'<span>\n</span>'</span> <span>)</span>;<br>    lines.<span>push_back</span><span>(</span> message.<span>substr</span><span>(</span> itStart - message.<span>begin</span><span>(</span><span>)</span>,<br>                                     itEol - itStart <span>)</span> <span>)</span>;<br>    <span>if</span> <span>(</span> itEol == message.<span>end</span><span>(</span><span>)</span> <span>)</span><br>      <span>break</span>;<br>    itStart = itEol <span>+1</span>;<br>  <span>}</span><br>  <span>return</span> lines;<br><span>}</span></pre>  <p>     至于wrap，则是在调用splitMessageIntoLines后，对每行以80列为限，若超过就作折行处理。这些处理都是为了方便在IDE监视窗  口中查看输出结果。即，不用因为单行内容太多，而来回移动横向滚动条：   </p>  <pre>std::<span>string</span><br>CompilerOutputter::<span>wrap</span><span>(</span> std::<span>string</span> message <span>)</span><br><span>{</span><br>  Lines lines = splitMessageIntoLines<span>(</span> message <span>)</span>;<br>  std::<span>string</span> wrapped;<br>  <span>for</span> <span>(</span> Lines::<span>iterator</span> it = lines.<span>begin</span><span>(</span><span>)</span>; it != lines.<span>end</span><span>(</span><span>)</span>; ++it <span>)</span><br>  <span>{</span><br>    std::<span>string</span> line<span>(</span> *it <span>)</span>;<br>    <span>const</span> <span>int</span> maxLineLength = <span>80</span>;<br>    <span>int</span> index =<span>0</span>;<br>    <span>while</span> <span>(</span> index &lt; line.<span>length</span><span>(</span><span>)</span> <span>)</span><br>    <span>{</span><br>      std::<span>string</span> line<span>(</span> line.<span>substr</span><span>(</span> index, maxLineLength <span>)</span> <span>)</span>;<br>      wrapped += line;<br>      index += maxLineLength;<br>      <span>if</span> <span>(</span> index &lt; line.<span>length</span><span>(</span><span>)</span> <span>)</span><br>        wrapped += <span>"<span>\n</span>"</span>;<br>    <span>}</span><br>    wrapped += <span>'<span>\n</span>'</span>;<br>  <span>}</span><br>  <span>return</span> wrapped;<br><span>}</span></pre>  <p>     到此为止，还是没有看到CompilerOutputter有何特殊之处，我们来看一下，实际调用CompilerOutputter的例子，以下这段代  码是从随CppUnit源码所附的范例中抽取出来的：   </p>  <pre><span>int</span> main<span>(</span> <span>int</span> argc, <span>char</span>* argv<span>[</span><span>]</span> <span>)</span> <span>{</span><br>  <span>// if command line contains "-selftest" then this is the post build check</span><br>  <span>// =&gt; the output must be in the compiler error format.</span><br>  <span>bool</span> selfTest = <span>(</span>argc &gt; <span>1</span><span>)</span>  &amp;&amp;  <br>                  <span>(</span>std::<span>string</span><span>(</span><span>"-selftest"</span><span>)</span> == argv<span>[</span><span>1</span><span>]</span><span>)</span>;<br>&nbsp;<br>  CppUnit::<span>TextUi</span>::<span>TestRunner</span> runner;<br>  runner.<span>addTest</span><span>(</span> CppUnitTest::<span>suite</span><span>(</span><span>)</span> <span>)</span>;   <span>// Add the top suite to the test runner</span><br>&nbsp;<br>  <span>if</span> <span>(</span> selfTest <span>)</span><br>  <span>{</span> <span>// Change the default outputter to a compiler error format outputter</span><br>    <span>// The test runner owns the new outputter.</span><br>    runner.<span>setOutputter</span><span>(</span> CppUnit::<span>CompilerOutputter</span>::<span>defaultOutputter</span><span>(</span> <br>                                                       &amp;runner.<span>result</span><span>(</span><span>)</span>,<br>                                                        std::<span>cerr</span> <span>)</span> <span>)</span>;<br>  <span>}</span><br>&nbsp;<br>  <span>// Run the test and don't wait a key if post build check.</span><br>  <span>bool</span> wasSucessful = runner.<span>run</span><span>(</span> <span>""</span>, !selfTest <span>)</span>;<br>&nbsp;<br>  <span>// Return error co<wbr>de 1 if the on<wbr>e of test failed.</span><br>  <span>return</span> wasSucessful ? <span>0</span> : <span>1</span>;<br><span>}</span></pre>  <p>   从注释中可以看到，针对本例，关键环节，只是在Project Settings的Post-build   step处加上一个自定义命令，当然这是针对VC IDE而言的：  </p>    <p>  $(TargetPath) -selftest  </p>    <p>  $(TargetPath)代表编译后生成的exe文件，-selftest则是命令行参数。有了这项设置，IDE的compiler就会在编译结束之  后，即刻运行本测试程序。以下是一个运行结果的实例：   </p>  <pre>1  --------------------Configuration: CppUnitTestMain - Win32 Debug--------------------<br>2  Compiling...<br>3  ExceptionTest.cpp<br>4  Linking...<br>5  self test<br>6  .F...................................................................................<br>7  c:\program\cppunit-1.8.0\examples\cppunittest\exceptiontest.cpp(43) : Assertion<br>8  Test name: ExceptionTest.testConstructor<br>9  sourceLine != e.sourceLine()<br>10 Failures !!!<br>11 Run: 112   Failure total: 1   Failures: 1   Errors: 0<br>12 Error executing c:\winnt\system32\cmd.exe.<br>13<br>14 CppUnitTestMain.exe - 1 error(s), 0 warning(s)<br></pre>    <p>   其中，第1~4行以及第12~14是程序编译链接的正常输出，第5行是Post-build   step中所指定的command的描述性文字，第6行是TextTestProgressListener的输出内容，第7~11行就是   CompilerOutputter的输出内容。此处表明，在exceptiontest.cpp的第43行，有一个断言失败了，鼠标双击该行，即可转到  相应的源文件处。   </p>    </div>    <h4><a rel="nofollow"   >XmlOutputter</a></h4>  <div>    <p>  相关文件：XmlOutputter.h，XmlOutputter.cpp  </p>    <p>  Outputter的又一个派生类，其功能是以XML格式输出TestResultCollector中的内容。与前述的TextOutputter和  CompilerOutputter类似，XmlOutputter也覆盖了基类Outputter的write方法：   </p>  <pre><span>void</span> XmlOutputter::<span>write</span><span>(</span><span>)</span><br><span>{</span><br>  writeProlog<span>(</span><span>)</span>;<br>  writeTestsResult<span>(</span><span>)</span>;<br><span>}</span></pre>  <p>     不同的是，XmlOutputter多了一个成员变量m_encoding，它用来标记XML的编码方式，缺省值是ISO-8859-1。由此，ctor  也略有不同了：   </p>  <pre>XmlOutputter::<span>XmlOutputter</span><span>(</span> TestResultCollector *result,<br>                            std::<span>ostream</span> &amp;stream,<br>                            std::<span>string</span> encoding <span>)</span> :<br>    m_result<span>(</span> result <span>)</span>,<br>    m_stream<span>(</span> stream <span>)</span>,<br>    m_encoding<span>(</span> encoding <span>)</span><br><span>{</span><br><span>}</span></pre>  <p>   writeProlog函数的作用是填写XML的头信息，很简单，不再多说。至于writeTestsResult，则是用来输出整个XML数据流的：     </p>  <pre><span>void</span> XmlOutputter::<span>writeTestsResult</span><span>(</span><span>)</span><br><span>{</span><br>  Node *rootNode = makeRootNode<span>(</span><span>)</span>;<br>  m_stream  &lt;&lt;  rootNode-&gt;toString<span>(</span><span>)</span>;<br>  <span>delete</span> rootNode;<br><span>}</span></pre>  <p>   writeTestsResult首先调用makeRootNode方法生成XML数据流的根节点，然后调用节点的   toString方法输出实际数据流，最后回收资源。这里出现了Node类，关于Node类的细节，稍后会讲到。先来看看与   writeTestsResult相关的几个函数   </p>  <pre>XmlOutputter::<span>Node</span> *XmlOutputter::<span>makeRootNode</span><span>(</span><span>)</span><br><span>{</span><br>  Node *rootNode = <span>new</span> Node<span>(</span> <span>"TestRun"</span> <span>)</span>;<br>&nbsp;<br>  FailedTests failedTests;<br>  fillFailedTestsMap<span>(</span> failedTests <span>)</span>;<br>&nbsp;<br>  addFailedTests<span>(</span> failedTests, rootNode <span>)</span>;<br>  addSucessfulTests<span>(</span> failedTests, rootNode <span>)</span>;<br>  addStatistics<span>(</span> rootNode <span>)</span>;<br>&nbsp;<br>  <span>return</span> rootNode;<br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>fillFailedTestsMap</span><span>(</span> FailedTests &amp;failedTests <span>)</span><br><span>{</span><br>  <span>const</span> TestResultCollector::<span>TestFailures</span> &amp;failures = m_result-&gt;failures<span>(</span><span>)</span>;<br>  TestResultCollector::<span>TestFailures</span>::<span>const_iterator</span> itFailure = failures.<span>begin</span><span>(</span><span>)</span>;<br>  <span>while</span> <span>(</span> itFailure != failures.<span>end</span><span>(</span><span>)</span> <span>)</span><br>  <span>{</span><br>    TestFailure *failure = *itFailure++;<br>    failedTests.<span>insert</span><span>(</span> std::<span>make_pair</span><span>(</span>failure-&gt;failedTest<span>(</span><span>)</span>, failure <span>)</span> <span>)</span>;<br>  <span>}</span><br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addFailedTests</span><span>(</span> FailedTests &amp;failedTests,<br>                                   Node *rootNode <span>)</span><br><span>{</span><br>  Node *testsNode = <span>new</span> Node<span>(</span> <span>"FailedTests"</span> <span>)</span>;<br>  rootNode-&gt;addNode<span>(</span> testsNode <span>)</span>;<br>&nbsp;<br>  <span>const</span> TestResultCollector::<span>Tests</span> &amp;tests = m_result-&gt;tests<span>(</span><span>)</span>;<br>  <span>for</span> <span>(</span> <span>int</span> testNumber = <span>0</span>; testNumber &lt; tests.<span>size</span><span>(</span><span>)</span>; ++testNumber <span>)</span><br>  <span>{</span><br>    Test *test = tests<span>[</span>testNumber<span>]</span>;<br>    <span>if</span> <span>(</span> failedTests.<span>find</span><span>(</span> test <span>)</span> != failedTests.<span>end</span><span>(</span><span>)</span> <span>)</span><br>      addFailedTest<span>(</span> test, failedTests<span>[</span>test<span>]</span>, testNumber<span>+1</span>, testsNode <span>)</span>;<br>  <span>}</span><br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addSucessfulTests</span><span>(</span> FailedTests &amp;failedTests,<br>                                      Node *rootNode <span>)</span><br><span>{</span><br>  Node *testsNode = <span>new</span> Node<span>(</span> <span>"SucessfulTests"</span> <span>)</span>;<br>  rootNode-&gt;addNode<span>(</span> testsNode <span>)</span>;<br>&nbsp;<br>  <span>const</span> TestResultCollector::<span>Tests</span> &amp;tests = m_result-&gt;tests<span>(</span><span>)</span>;<br>  <span>for</span> <span>(</span> <span>int</span> testNumber = <span>0</span>; testNumber &lt; tests.<span>size</span><span>(</span><span>)</span>; ++testNumber <span>)</span><br>  <span>{</span><br>    Test *test = tests<span>[</span>testNumber<span>]</span>;<br>    <span>if</span> <span>(</span> failedTests.<span>find</span><span>(</span> test <span>)</span> == failedTests.<span>end</span><span>(</span><span>)</span> <span>)</span><br>      addSucessfulTest<span>(</span> test, testNumber<span>+1</span>, testsNode <span>)</span>;<br>  <span>}</span><br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addStatistics</span><span>(</span> Node *rootNode <span>)</span><br><span>{</span><br>  Node *statisticsNode = <span>new</span> Node<span>(</span> <span>"Statistics"</span> <span>)</span>;<br>  rootNode-&gt;addNode<span>(</span> statisticsNode <span>)</span>;<br>  statisticsNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Tests"</span>, m_result-&gt;runTests<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>  statisticsNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"FailuresTotal"</span>, <br>                                     m_result-&gt;testFailuresTotal<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>  statisticsNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Errors"</span>, m_result-&gt;testErrors<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>  statisticsNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Failures"</span>, m_result-&gt;testFailures<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addFailedTest</span><span>(</span> Test *test,<br>                                  TestFailure *failure,<br>                                  <span>int</span> testNumber,<br>                                  Node *testsNode <span>)</span><br><span>{</span><br>  Exception *thrownException = failure-&gt;thrownException<span>(</span><span>)</span>;<br>&nbsp;<br>  Node *testNode = <span>new</span> Node<span>(</span> <span>"FailedTest"</span>, thrownException-&gt;what<span>(</span><span>)</span> <span>)</span>;<br>  testsNode-&gt;addNode<span>(</span> testNode <span>)</span>;<br>  testNode-&gt;addAttribute<span>(</span> <span>"id"</span>, testNumber <span>)</span>;<br>  testNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Name"</span>, test-&gt;getName<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>  testNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"FailureType"</span>, <br>                               failure-&gt;isError<span>(</span><span>)</span> ? <span>"Error"</span> : <span>"Assertion"</span> <span>)</span> <span>)</span>;<br>&nbsp;<br>  <span>if</span> <span>(</span> failure-&gt;sourceLine<span>(</span><span>)</span>.<span>isValid</span><span>(</span><span>)</span> <span>)</span><br>    addFailureLocation<span>(</span> failure, testNode <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addFailureLocation</span><span>(</span> TestFailure *failure,<br>                                       Node *testNode <span>)</span><br><span>{</span><br>  Node *locationNode = <span>new</span> Node<span>(</span> <span>"Location"</span> <span>)</span>;<br>  testNode-&gt;addNode<span>(</span> locationNode <span>)</span>;<br>  SourceLine sourceLine = failure-&gt;sourceLine<span>(</span><span>)</span>;<br>  locationNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"File"</span>, sourceLine.<span>fileName</span><span>(</span><span>)</span> <span>)</span> <span>)</span>;<br>  locationNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Line"</span>, sourceLine.<span>lineNumber</span><span>(</span><span>)</span> <span>)</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>addSucessfulTest</span><span>(</span> Test *test, <br>                                     <span>int</span> testNumber,<br>                                     Node *testsNode <span>)</span><br><span>{</span><br>  Node *testNode = <span>new</span> Node<span>(</span> <span>"Test"</span> <span>)</span>;<br>  testsNode-&gt;addNode<span>(</span> testNode <span>)</span>;<br>  testNode-&gt;addAttribute<span>(</span> <span>"id"</span>, testNumber <span>)</span>;<br>  testNode-&gt;addNode<span>(</span> <span>new</span> Node<span>(</span> <span>"Name"</span>, test-&gt;getName<span>(</span><span>)</span> <span>)</span> <span>)</span>;<br><span>}</span></pre>  <p>   依据上述代码可以大致勾画出XML数据流的生成流程：  </p>    <p>  makeRootNode函数虽名曰创建根节点，实则创建整个XML数据流。在创建了一个名为   “TestRun”的根节点之后，随即调用了fillFailedTestsMap方法，后者调用成员变量m_result的failures方法，得到  所有失败之测试，填充一个FailedTests结构的变量以备后用(实为map&lt;Test *,TestFailure*&gt;)。  </p>    <p>  addFailedTests方法，生成了一个名为“FailedTests”的节点，作为   “TestRun”的子节点，并调用了m_result的tests方法，针对每个测试，若能在前面填充的FailedTests结构的变量中找到(即为  失败测试)，则调用addFailedTest方法。后者生成一个名为“FailedTest”的节点，作为“FailedTests”的子节点，   “FailedTest”节点的content描述了错误原因，这是通过调用Exception的what方法得到的，而Excetpion的实例则是通  过调用失败测试的thrownException方法获取的。“FailedTest”节点有一个属性，表示测试的ID号，另外其下还有两个子节点，一个  是测试名称，另一个是失败类型(Error/Assertion)。若有可能，还会记录错误所在的文件位置和行号。  </p>    <p>  与addFailedTests方法类似的另一个函数是addStatistics，它用来生成和成功测试相关的节点。此处不再鏊述。  </p>    <p>  addStatistics方法在最后被调用，用以生成统计信息，包括：测试个数（名为   “Tests”的节点），失败测试总数（名为“FailuresTotal”的节点），错误个数（名为“Errors”的节点），失败个数（名为   “Failures”的节点）。它们都从属于“Statistics”节点，而该节点则直接从属于根节点。  </p>    <p>  最后，再捎带提一下Node类，该类内嵌于XmlOutputter中，实现了一个功能简单的 XML节点类，在后续版本中可能为一个Abstract   Builder所取代。节点的内容(content）支持int型和string型数据，这一点可以从其两个不同版本的ctor中看到：   </p>  <pre>XmlOutputter::<span>Node</span>::<span>Node</span><span>(</span> std::<span>string</span> elementName,<br>                          std::<span>string</span> content <span>)</span> :<br>    m_name<span>(</span> elementName <span>)</span>,<br>    m_content<span>(</span> content <span>)</span><br><span>{</span><br><span>}</span><br>&nbsp;<br>XmlOutputter::<span>Node</span>::<span>Node</span><span>(</span> std::<span>string</span> elementName,<br>                          <span>int</span> numericContent <span>)</span> :<br>    m_name<span>(</span> elementName <span>)</span><br><span>{</span><br>  m_content = asString<span>(</span> numericContent <span>)</span>;<br><span>}</span></pre>  <p>     其中的asString是Node的一个辅助方法，用以将int型数据转换成string型数据。m_name和m_content分别代表节点对应的名  称和内容。  </p>    <p>  Node中的m_attributes成员，代表了节点包含的属性，事实上，它对应的是一个   deque类型的变量，而deque的每个元素则是std::pair&lt;std::string,std::string&gt;类型的，其中前一  个string代表属性名，后一个string代表属性值。有了上述认识，我们就可以理解Node的addAttribute方法的含义了，同样是为了支  持int型数据和string型数据，addAttribute具有两个版本：   </p>  <pre><span>void</span> XmlOutputter::<span>Node</span>::<span>addAttribute</span><span>(</span> std::<span>string</span> attributeName,<br>                                       std::<span>string</span> value  <span>)</span><br><span>{</span><br>  m_attributes.<span>push_back</span><span>(</span> Attribute<span>(</span> attributeName, value <span>)</span> <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>void</span> XmlOutputter::<span>Node</span>::<span>addAttribute</span><span>(</span> std::<span>string</span> attributeName,<br>                                       <span>int</span> numericValue <span>)</span><br><span>{</span><br>  addAttribute<span>(</span> attributeName, asString<span>(</span> numericValue <span>)</span> <span>)</span>;<br><span>}</span></pre>  <p>   这里的Attribute即std::pair&lt;std::string,std::string&gt;：   </p>  <pre><span>typedef</span> std::<span>pair</span>&lt;std::<span>string</span>,std::<span>string</span>&gt; Attribute;</pre>  <p>   由于XML的标记呈现树状结构的特点，因此作为标记对应物的Node类也应该支持这种节点嵌套的特性。因此，Node   类中引入了m_nodes成员，用以代表当前节点下属的子节点，其实际类型是std::deque&lt;Node   *&gt;。与之对应的addNode方法用以为当前节点添加一个新的子节点：   </p>  <pre><span>void</span> XmlOutputter::<span>Node</span>::<span>addNode</span><span>(</span> Node *node <span>)</span><br><span>{</span><br>  m_nodes.<span>push_back</span><span>(</span> node <span>)</span>;<br><span>}</span></pre>  <p>     接下来是至为关键的toString方法，前面提到的XmlOutputter正是调用了根节点的toString方法才完成整个XML数据流的输出的：     </p>  <pre>std::<span>string</span> XmlOutputter::<span>Node</span>::<span>toString</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  <span>// 添加begin tag</span><br>  std::<span>string</span> element = <span>"&lt;"</span>;<br>  element += m_name;<br>  element += <span>" "</span>;<br>  element += attributesAsString<span>(</span><span>)</span>;<br>  element += <span>" &gt;<span>\n</span>"</span>;<br>&nbsp;<br>  <span>// 递归调用子节点的toString方法</span><br>  Nodes::<span>const_iterator</span> itNode = m_nodes.<span>begin</span><span>(</span><span>)</span>;<br>  <span>while</span> <span>(</span> itNode != m_nodes.<span>end</span><span>(</span><span>)</span> <span>)</span><br>  <span>{</span><br>    <span>const</span> Node *node = *itNode++;<br>    element += node-&gt;toString<span>(</span><span>)</span>;<br>  <span>}</span><br>&nbsp;<br>  <span>// 添加tag content</span><br>  element += m_content;<br>&nbsp;<br>  <span>// 添加end tag</span><br>  element += <span>"&lt;/"</span>;<br>  element += m_name;<br>  element += <span>"&gt;<span>\n</span>"</span>;<br>&nbsp;<br>  <span>return</span> element;<br><span>}</span></pre>  <p>   代码中的注释已清楚描述了toString的执行流程，需要再解释一下的是在生成启始标记时出现的attributesAsString方法：   </p>  <pre>std::<span>string</span> XmlOutputter::<span>Node</span>::<span>attributesAsString</span><span>(</span><span>)</span> <span>const</span><br><span>{</span><br>  std::<span>string</span> attributes;<br>  Attributes::<span>const_iterator</span> itAttribute = m_attributes.<span>begin</span><span>(</span><span>)</span>;<br>  <span>while</span> <span>(</span> itAttribute != m_attributes.<span>end</span><span>(</span><span>)</span> <span>)</span><br>  <span>{</span><br>    <span>const</span> Attribute &amp;attribute = *itAttribute++;<br>    attributes += attribute.<span>first</span>;<br>    attributes += <span>"=<span>\"</span>"</span>;<br>    attributes += escape<span>(</span> attribute.<span>second</span> <span>)</span>;<br>    attributes += <span>"<span>\"</span>"</span>;<br>  <span>}</span><br>  <span>return</span> attributes;<br><span>}</span></pre>  <p>     可以看出，attributesAsString的作用是把当前节点的属性转换成字符串，并逐个拼接起来。至于escape方法，则是用来替换字符串中的  某些特殊字符的，但其做法似乎简陋了些，怪不得作者要在旁边加上safe?这样的注释。   </p>  <pre>std::<span>string</span> XmlOutputter::<span>Node</span>::<span>escape</span><span>(</span> std::<span>string</span> value <span>)</span> <span>const</span><br><span>{</span><br>  std::<span>string</span> escaped;<br>  <span>for</span> <span>(</span> <span>int</span> index =<span>0</span>; index &lt; value.<span>length</span><span>(</span><span>)</span>; ++index <span>)</span><br>  <span>{</span><br>    <span>char</span> c = value<span>[</span>index <span>]</span>;<br>    <span>switch</span> <span>(</span> c <span>)</span>    <span>// escape all predefined XML entity (safe?)</span><br>    <span>{</span><br>    <span>case</span> <span>'&lt;'</span>: <br>      escaped += <span>"&lt;"</span>;<br>      <span>break</span>;<br>    <span>case</span> <span>'&gt;'</span>: <br>      escaped += <span>"&gt;"</span>;<br>      <span>break</span>;<br>    <span>case</span> <span>'&amp;'</span>: <br>      escaped += <span>"&amp;"</span>;<br>      <span>break</span>;<br>    <span>case</span> <span>'<span>\'</span>'</span>: <br>      escaped += <span>"'"</span>;<br>      <span>break</span>;<br>    <span>case</span> <span>'"'</span>: <br>      escaped += <span>""</span>;<br>      <span>break</span>;<br>    <span>default</span>:<br>      escaped += c;<br>    <span>}</span><br>  <span>}</span><br>&nbsp;<br>  <span>return</span> escaped;<br><span>}</span></pre>  <p>   至此，XmlOutputter部分的讲解就完成了。   </p>    </div>  <div><div></div></div>  <h2><a rel="nofollow"   >辅助部分（Helper）</a></h2>  <div>    </div>  <div><div></div></div>  <h3><a rel="nofollow"   >创建机制</a></h3>  <div>    <p>  这一部分提供了一些辅助类，多数与创建Test类的实例有关，其中包括用于创建Test的工厂类，用于管理工厂类的注册类，可以单独运行某个测试的  TestCaller，还有为方便使用而定义的一组宏。   </p>    </div>    <h4><a rel="nofollow"   >TypeInfoHelper</a></h4>  <div>    <p>  相关文件：TypeInfoHelper.h，TypeInfoHelper.cpp  </p>    <p>  为了扫清理解障碍，TypeInfoHelper是首先需要解释的。该类的作用是根据指定类的   type_info返回一个代表其类名的字符串。为了使用此功能，你必须定义CPPUNIT_USE_TYPEINFO_NAME宏，即你必须确认你所使  用的c++编译器提供了type_info机制。TypeInfoHelper仅有一个static成员函数getClassName，请留意   morning的注释：   </p>  <pre>std::<span>string</span> <br>TypeInfoHelper::<span>getClassName</span><span>(</span> <span>const</span> std::<span>type_info</span> &amp;info <span>)</span><br><span>{</span><br>  <span>static</span> std::<span>string</span> classPrefix<span>(</span> <span>"class "</span> <span>)</span>;<br>  std::<span>string</span> name<span>(</span> info.<span>name</span><span>(</span><span>)</span> <span>)</span>;      <span>// 调用info的name以得到类名信息</span><br>&nbsp;<br>  <span>// 确定类名中是否有"class"字样</span><br>  <span>bool</span> has_class_prefix = <span>0</span> ==<br><span>#if CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST</span><br>    name.<span>compare</span><span>(</span> classPrefix, <span>0</span>, classPrefix.<span>length</span><span>(</span><span>)</span> <span>)</span>;<br><span>#else</span><br>    name.<span>compare</span><span>(</span> <span>0</span>, classPrefix.<span>length</span><span>(</span><span>)</span>, classPrefix <span>)</span>;<br><span>#endif</span><br>&nbsp;<br>  <span>// 返回不带有"class"字样的类名</span><br>  <span>return</span> has_class_prefix ? name.<span>substr</span><span>(</span> classPrefix.<span>length</span><span>(</span><span>)</span> <span>)</span> : name;<br><span>}</span></pre>  <p>   关于此处用到的std::string::compare函数，在bcb和vc中的调用方式不一样，所以就有了   CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST宏。参见config-msvc6.h和config-bcb5.h   中的相关定义以及portability部分的说明。    </p>    </div>    <h4><a rel="nofollow"   >TestFactory</a></h4>  <div>    <p>  相关文件：TestFactory.h  </p>    <p>  是Test的抽象类工厂（Abstract Factory），用于创建一个Test实例，它仅仅包含了一个纯虚函数makeTest的声明：   </p>  <pre><span>virtual</span> Test* makeTest<span>(</span><span>)</span> = <span>0</span>;</pre>  </div>    <h4><a rel="nofollow"   >TestFactoryRegistry，NamedRegistries</a></h4>  <div>    <p>  相关文件：TestFactoryRegistry.cpp，TestFactoryRegistry.cpp  </p>    <p>  某次测试的运行可能包含了许多测试实例，它们彼此间可能呈现层状结构，而每个测试实例的创建都是由某个与之对应的类工厂完成的。为了较好的管理这些类工  厂，实现其生命周期的自动操控，CppUnit采用了一种注册机制。类   TestFactoryRegistry和类NamedRegistries就是用来实现该机制的。  </p>    <p>  NamedRegistries是一个管理类，用以管理所有的注册项——TestFactoryRegistry类的实例，由它全权负责  TestFactoryRegistry的生命周期。TestFactoryRegistry在稍后会讲到。  </p>    <p>  NamedRegistries采用了Singleton   Pattern，以保证其“全局性”的唯一访问点。此处是通过在函数内定义静态变量的方式来实现的：   </p>  <pre>NamedRegistries &amp;<br>NamedRegistries::<span>getInstance</span><span>(</span><span>)</span><br><span>{</span><br>  <span>static</span> NamedRegistries namedRegistries;<br>  <span>return</span> namedRegistries;<br><span>}</span></pre>  <p>   NamedRegistries内部有三个private属性的成员变量：   </p>  <pre>Registries m_registries;        <span>// 代表一个注册名称-注册项的映射表</span><br>Factories m_factoriesToDestroy; <span>// 代表即将被销毁的注册项序列</span><br>Factories m_destroyedFactories; <span>// 代表已经被销毁的注册项序列</span></pre>  <p>   其中，Registries和Factories的定义如下：   </p>  <pre><span>typedef</span> std::<span>map</span>&lt;std::<span>string</span>, TestFactoryRegistry *&gt; Registries;<br><span>typedef</span> std::<span>set</span>&lt;TestFactory *&gt; Factories;</pre>  <p>   为了使外界可以访问到注册项，NamedRegistries提供了getRegistry方法，请留意morning的注释：   </p>  <pre>TestFactoryRegistry &amp;<br>NamedRegistries::<span>getRegistry</span><span>(</span> std::<span>string</span> name <span>)</span><br><span>{</span><br>  <span>// 根据name在m_registries中查找注册项</span><br>  Registries::<span>const_iterator</span> foundIt = m_registries.<span>find</span><span>(</span> name <span>)</span>;<br>  <span>// 若没有找到，则创建一个TestFactoryRegistry实例，并赋以name作为名称</span><br>  <span>// 将之分别插入m_registries和m_factoriesToDestroy中</span><br>  <span>// 再返回该TestFactoryRegistry实例</span><br>  <span>if</span> <span>(</span> foundIt == m_registries.<span>end</span><span>(</span><span>)</span> <span>)</span><br>  <span>{</span><br>    TestFactoryRegistry *factory = <span>new</span> TestFactoryRegistry<span>(</span> name <span>)</span>;<br>    m_registries.<span>insert</span><span>(</span> std::<span>make_pair</span><span>(</span> name, factory <span>)</span> <span>)</span>;<br>    m_factoriesToDestroy.<span>insert</span><span>(</span> factory <span>)</span>;<br>    <span>return</span> *factory;<br>  <span>}</span><br>  <span>// 若找到，则直接返回</span><br>  <span>return</span> *foundIt-&gt;second;<br><span>}</span></pre>  <p>   在NamedRegistries被销毁（即dtor被调用）的同时，其下所属的TestFactoryRegistry实例也将被销毁：   </p>  <pre>NamedRegistries::~NamedRegistries<span>(</span><span>)</span><br><span>{</span><br>  Registries::<span>iterator</span> it = m_registries.<span>begin</span><span>(</span><span>)</span>;<br>  <span>while</span> <span>(</span> it != m_registries.<span>end</span><span>(</span><span>)</span> <span>)</span><br>  <span>{</span><br>    TestFactoryRegistry *registry = <span>(</span>it++<span>)</span>-&gt;second;<br>    <span>if</span> <span>(</span> needDestroy<span>(</span> registry <span>)</span> <span>)</span><br>      <span>delete</span> registry;<br>  <span>}</span><br><span>}</span></pre>  <p>     这里加上needDestroy的判断是为了防止出现多次销毁同一个TestFactoryRegistry实例的现象，稍后可以发现这和  TestFactoryRegistry的dtor实现有关，另外一个wasDestroyed方法，也与此有关，它们的实现代码分别如下：   </p>  <pre><span>void</span> <br>NamedRegistries::<span>wasDestroyed</span><span>(</span> TestFactory *factory <span>)</span><br><span>{</span><br>  <span>// 从m_factoriesToDestroy中摘除factory</span><br>  m_factoriesToDestroy.<span>erase</span><span>(</span> factory <span>)</span>;<br>  <span>// 将factory插入m_destroyedFactories</span><br>  m_destroyedFactories.<span>insert</span><span>(</span> factory <span>)</span>;<br><span>}</span><br>&nbsp;<br><span>bool</span> <br>NamedRegistries::<span>needDestroy</span><span>(</span> TestFactory *factory <span>)</span><br><span>{</span><br>  <span>// 判断m_destroyedFactories是否存在factory</span><br>  <span>return</span> m_destroyedFactories.<span>count</span><span>(</span> factory <span>)</span> == <span>0</span>;<br><span>}</span></pre>  <p>   根据约定，TestFactory的注册项必须调用wasDestroyed方法，以表明一个   TestFactoryRegistry实例已经被成功销毁了。同时，它也需要调用needDestroy以确信一个给定的TestFactory可以被  允许销毁，即事先没有被其他TestFactoryRegistry实例销毁。  </p>    <p>  我们再来看看TestFactoryRegistry。其ctor只是简单的将传入其中的字符串赋给成员变量m_name，它代表了注册项的名称：   </p>  <pre>TestFactoryRegistry::<span>TestFactoryRegistry</span><span>(</span> std::<span>string</span> name <span>)</span> :<br>    m_name<span>(</span> name <span>)</span><br><span>{</span><br><span>}</span></pre>  <p>   dtor稍微复杂一些，请留意morning的注释：   </p>  <pre>TestFactoryRegistry::~TestFactoryRegistry<span>(</span><span>)</span><br><span>{</span><br>  <span>// 还记得前面提到的约定吗？</span><br>  NamedRegistries::<span>getInstance</span><span>(</span><span>)</span>.<span>wasDestroyed</span><span>(</span> <span>this</span> <span>)</span>;<br>&nbsp;<br>  <span>// 遍历其下所属的各个TestFactory实例</span><br>  <span>for</span> <span>(</span> Factories::<span>iterator</span> it = m_factories.<span>begin</span><span>(</span><span>)</span>; it != m_factories.<span>end</span><span>(</span><span>)</span>; ++it <span>)</span><br>  <span>{</span><br>    TestFactory *factory = it-&gt;second;<br>    <span>// 若factory没有存在于NamedRegistries::m_destroyedFactories中</span><br>    <span>// 则可以放心销毁之。factory的销毁可能形成连锁反应，亦即，若factory本身</span><br>    <span>// 也是TestFactoryRegistry类型的，其dtor又将被调用，上述过程将再次重现</span><br>    <span>if</span> <span>(</span> NamedRegistries::<span>getInstance</span><span>(</span><span>)</span>.<span>needDestroy</span><span>(</span> factory <span>)</span> <span>)</span><br>      <span>delete</span> factory;<br>  <span>}</span><br><span>}</span></pre></div>
</body></html>